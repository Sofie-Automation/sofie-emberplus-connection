This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-01-16T09:59:53.330Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.github/
  workflows/
    node.yaml
    publish.yaml
  dependabot.yml
  PULL-REQUEST-TEMPLATE.md
.husky/
  pre-commit
examples/
  mc2_mock.js
src/
  Ber/
    __tests__/
      index.spec.ts
      writer.spec.ts
    BERDataTypes.ts
    functions.ts
    index.ts
    Reader.ts
    Writer.ts
  Ember/
    Client/
      __tests__/
        index.spec.ts
        index.test.ts_
      index.ts
      StreamManager.ts
    Lib/
      index.ts
      util.ts
    Server/
      index.ts
    Socket/
      index.ts
      S101Client.ts
      S101Server.ts
      S101Socket.ts
  encodings/
    ber/
      __tests__/
        Command.spec.ts
        Connection.spec.ts
        DecodeResult.spec.ts
        EmberFunction.spec.ts
        EmberNode.spec.ts
        FunctionArgument.spec.ts
        index.spec.ts
        Invocation.spec.ts
        InvocationResult.spec.ts
        Label.spec.ts
        Matrix.spec.ts
        Parameter.spec.ts
        StreamDescription.spec.ts
        StreamEntry.spec.ts
        StringIntegerCollection.spec.ts
        Template.spec.ts
      decoder/
        Command.ts
        Connection.ts
        DecodeResult.ts
        EmberFunction.ts
        EmberNode.ts
        FunctionArgument.ts
        Invocation.ts
        InvocationResult.ts
        Label.ts
        Matrix.ts
        Parameter.ts
        StreamDescription.ts
        StreamEntry.ts
        StringIntegerCollection.ts
        Template.ts
        Tree.ts
      encoder/
        Command.ts
        Connection.ts
        EmberElement.ts
        EmberFunction.ts
        EmberNode.ts
        FunctionArgument.ts
        Invocation.ts
        InvocationResult.ts
        Label.ts
        Matrix.ts
        Parameter.ts
        Qualified.ts
        RootElement.ts
        StreamDescription.ts
        StreamEntry.ts
        StringIntegerCollection.ts
        Template.ts
        Tree.ts
      constants.ts
      index.ts
  model/
    __tests__/
      EmberElement.test.ts
      Parameter.test.ts
    Command.ts
    Connection.ts
    EmberElement.ts
    EmberFunction.ts
    EmberNode.ts
    FunctionArgument.ts
    index.ts
    Invocation.ts
    InvocationResult.ts
    Label.ts
    Matrix.ts
    Parameter.ts
    StreamDescription.ts
    StreamEntry.ts
    Template.ts
    Tree.ts
  S101/
    index.ts
    S101Codec.ts
  types/
    index.ts
    types.ts
  Errors.ts
  index.ts
.editorconfig
.eslintignore
.eslintrc.json
.gitattributes
.gitignore
.prettierignore
.repopackignore
.yarnrc.yml
CHANGELOG.md
CONTRIBUTING.md
jest.config.js
LICENSE
package.json
README.md
tsconfig.build.json
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .github/workflows/node.yaml
================
name: Node CI

on:
  push:
    branches:
      - '**'
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+*'
  pull_request:

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    continue-on-error: true
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js 18.x
        uses: actions/setup-node@v3
        with:
          node-version: 18.x
      - name: Prepare Environment
        run: |
          yarn install
          yarn build
        env:
          CI: true
      - name: Run typecheck and linter
        run: |
          yarn lint
        env:
          CI: true

  test:
    name: Test
    runs-on: ubuntu-latest
    timeout-minutes: 15

    strategy:
      fail-fast: false
      matrix:
        node-version: [14.x, 16.x, 18.x, 20.x]

    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
      - name: Prepare Environment
        run: |
          yarn install
        env:
          CI: true
      - name: Run tests
        run: |
          yarn unit
        env:
          CI: true
      - name: Send coverage
        if: matrix.node-version == '18.x'
        uses: codecov/codecov-action@v3

  release:
    name: Release
    runs-on: ubuntu-latest
    timeout-minutes: 15

    # only run for tags
    if: contains(github.ref, 'refs/tags/')

    needs:
      - test
      - validate-dependencies

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Use Node.js 18.x
        uses: actions/setup-node@v3
        with:
          node-version: 18.x
      - name: Check release is desired
        id: do-publish
        run: |
          if [ -z "${{ secrets.NPM_TOKEN }}" ]; then
            echo "No Token"
          else

            PUBLISHED_VERSION=$(yarn npm info --json . | jq -c '.version' -r)
            THIS_VERSION=$(node -p "require('./package.json').version")
            # Simple bash helper to comapre version numbers
            verlte() {
              [  "$1" = "`echo -e "$1\n$2" | sort -V | head -n1`" ]
            }
            verlt() {
              [ "$1" = "$2" ] && return 1 || verlte $1 $2
            }
            if verlt $PUBLISHED_VERSION $THIS_VERSION
            then
              echo "Publishing latest"
              echo "tag=latest" >> $GITHUB_OUTPUT
            else
              echo "Publishing hotfix"
              echo "tag=hotfix" >> $GITHUB_OUTPUT
            fi

          fi
      - name: Prepare build
        if: ${{ steps.do-publish.outputs.tag }}
        run: |
          yarn install
          yarn build
        env:
          CI: true
      - name: Publish to NPM
        if: ${{ steps.do-publish.outputs.tag }}
        run: |
          yarn config set npmAuthToken $NPM_AUTH_TOKEN

          NEW_VERSION=$(node -p "require('./package.json').version")
          yarn npm publish --access=public --tag ${{ steps.do-publish.outputs.tag }}

          echo "**Published:** $NEW_VERSION" >> $GITHUB_STEP_SUMMARY
        env:
          NPM_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          CI: true

  validate-dependencies:
    name: Validate production dependencies
    runs-on: ubuntu-latest
    continue-on-error: true
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js 18.x
        uses: actions/setup-node@v3
        with:
          node-version: 18.x
      - name: Prepare Environment
        run: |
          yarn install
        env:
          CI: true
      - name: Validate production dependencies
        run: |
          if ! git log --format=oneline -n 1 | grep -q "\[ignore-audit\]"; then
            yarn validate:dependencies
          else
            echo "Skipping audit"
          fi
        env:
          CI: true

  validate-all-dependencies:
    name: Validate all dependencies
    runs-on: ubuntu-latest
    continue-on-error: true
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js 18.x
        uses: actions/setup-node@v3
        with:
          node-version: 18.x
      - name: Prepare Environment
        run: |
          yarn install
        env:
          CI: true
      - name: Validate production dependencies
        run: |
          yarn validate:dependencies
        env:
          CI: true
      - name: Validate dev dependencies
        run: |
          yarn validate:dev-dependencies
        env:
          CI: true

================
File: .github/workflows/publish.yaml
================
name: Publish prerelease

on:
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    timeout-minutes: 15

    strategy:
      fail-fast: false
      matrix:
        node-version: [14.x, 16.x, 18.x, 20.x]

    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
      - name: Prepare Environment
        run: |
          yarn install
        env:
          CI: true
      - name: Run tests
        run: |
          yarn unit
        env:
          CI: true

  prerelease:
    name: Prerelease
    runs-on: ubuntu-latest
    timeout-minutes: 15

    needs:
      - test

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Use Node.js 18.x
        uses: actions/setup-node@v3
        with:
          node-version: 18.x
      - name: Check release is desired
        id: do-publish
        run: |
          if [ -z "${{ secrets.NPM_TOKEN }}" ]; then
            echo "No Token"
          elif [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            echo "Publish nightly"
            echo "publish=nightly" >> $GITHUB_OUTPUT
          else
            echo "Publish experimental"
            echo "publish=experimental" >> $GITHUB_OUTPUT
          fi
      - name: Prepare Environment
        if: ${{ steps.do-publish.outputs.publish }}
        run: |
          yarn install
        env:
          CI: true
      - name: Bump version and build
        if: ${{ steps.do-publish.outputs.publish }}
        run: |
          PRERELEASE_TAG=nightly-$(echo "${{ github.ref_name }}" | sed -r 's/[^a-z0-9]+/-/gi')
          yarn release --prerelease $PRERELEASE_TAG
          yarn build
        env:
          CI: true
      - name: Publish to NPM
        if: ${{ steps.do-publish.outputs.publish }}
        run: |
          yarn config set npmAuthToken $NPM_AUTH_TOKEN

          NEW_VERSION=$(node -p "require('./package.json').version")
          yarn npm publish --access=public --tag "${{ steps.do-publish.outputs.publish }}"

          echo "**Published:** $NEW_VERSION" >> $GITHUB_STEP_SUMMARY
        env:
          NPM_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          CI: true

================
File: .github/dependabot.yml
================
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
    reviewers:
      - "@nrkno/sofie-ops"

================
File: .github/PULL-REQUEST-TEMPLATE.md
================
<!--
Before you open a PR, be sure to read our Contribution guidelines:
https://nrkno.github.io/sofie-core/docs/for-developers/contribution-guidelines
-->

## About the Contributor
<!--
Tell us who / which organization you are representing, and how the Sofie team will be able to contact you.
Example: "This pull request is posted on behalf of the NRK."
-->


## Type of Contribution

This is a: 
<!-- (pick one) -->
Bug fix / Feature / Code improvement / Documentation improvement / Other (please specify)


## Current Behavior
<!--
Please describe how things worked before this PR.
If it's a bug fixe: Describe the bug (what was happening?)
-->


## New Behavior
<!--
What is the new behavior?
-->


## Testing Instructions
<!--
Please provide some instructions and other information for how to verify that the feature works.
Examples:
* "Do a Take for a part that contains an adlib, verify that the adlib plays out."
* "Open the Switchboard panel and toggle a route, verify that the route toggles in the GUI."
* "This feature also affects 'feature X', so that needs to be tested for regressions as well."
-->


## Other Information
<!-- The more information you can provide, the easier the pull request will be to merge -->


## Status
<!--
Before you open the PR, make sure the items below are done.
If they're not, please open the PR as a Draft.
-->

- [ ] PR is ready to be reviewed.
- [ ] The functionality has been tested by the author.
- [ ] Relevant unit tests has been added / updated.
- [ ] Relevant documentation (code comments, [system documentation](https://nrkno.github.io/sofie-core/)) has been added / updated.

================
File: .husky/pre-commit
================
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

yarn lint-staged

================
File: examples/mc2_mock.js
================
process.env.DEBUG = 'emberplus-connection:*'
const { EmberClient } = require('../dist/index')

//-------------------------------------------------------------------------
// Client
// ------------------------------------------------------------------------

const client2 = new EmberClient('192.168.1.67', 9000)

client2.on('disconnected', () => {
	console.error('Client 2 Lost Ember connection')
	client2.tree = []
})

// Handle successful connection
client2.on('connected', () => {
	console.log('Client 2 Found Ember connection')
	client2.tree = []

	client2
		.getDirectory(client2.tree)
		.then((req) => {
			console.log(' Req:', req)
			return req.response
		})
		.then(() => {
			console.log(' Getting node...')

			const path_1 = 'Channels.Inputs._1.Fader'
			return client2.getElementByPath(path_1)
		})
		.then((node1) => {
			if (!node1) {
				throw new Error(' Could not find node 1')
			}
			console.log('Found node number:', node1.number)

			// Subscribe to changes
			client2.subscribe(node1, (node1) => {
				const value = node1.contents
				console.log('Node 1 subscription :', value)
			})

			// This debug show the fail in the getElementByPath:
			const path2 = 'Channels.Groups._1'
			console.log(' Getting node 1 :', path2)
			client2
				.getElementByPath(path2)
				.then((node) => {
					if (!node) {
						throw new Error(' Could not find node')
					}
					console.log('Found node number:', node.number, 'for Path', path2)
				})
				.catch((error) => {
					console.error('Path', path2, 'Error:', error)
				})
			const path3 = 'Channels.Inputs'
			console.log(' Getting node :', path3)
			client2
				.getElementByPath(path3)
				.then((node) => {
					if (!node) {
						throw new Error(' Could not find node')
					}
					console.log('Found node number:', node.number, 'for Path', path3)
				})
				.catch((error) => {
					console.error('Path', path3, 'Error:', error)
				})
			// The last one is resolved as node2
			const path4 = 'Channels.Groups._1.Fader'
			console.log(' Getting node :', path4)
			return client2.getElementByPath(path4)
		})
		.then((node2) => {
			if (!node2) {
				throw new Error('Could not find node2')
			}
			console.log('Found node 2 number:', node2.number)

			// Subscribe to changes
			client2.subscribe(node2, (node) => {
				const value = node.contents.value
				console.log('Node 2 subscription :', value)
			})
		})
		.then(() => {
			console.log('Successfully subscribed to node 2')
		})
		.catch((error) => {
			console.error(' Error:', error)
		})
})
client2.on('streamUpdate', (path, value) => {
	console.log('Stream Update:', {
		path: path,
		value: value,
	})
})

console.log('-----------------------------------------------------------------------------')
console.log('Connecting to Client 2...')
client2.connect().catch((error) => {
	console.error('Client 2 Error when connecting:', error)
})

================
File: src/Ber/__tests__/index.spec.ts
================
import { Writer } from '../Writer'
import { BERDataTypes } from '..'
import { Reader } from '../Reader'
import { ParameterType } from '../../model/Parameter'

describe('BER', () => {
	describe('Roundtrip', () => {
		test('writeReal - readReal', () => {
			const w = new Writer()
			w.writeReal(8.32, BERDataTypes.REAL)

			const r = new Reader(w.buffer)
			const tag = r.peek()
			expect(tag).toEqual(BERDataTypes.REAL)
			const s = r.readReal()
			expect(s).toEqual(8.32)
		})
		test('writeReal - readValue', () => {
			const w = new Writer()
			w.writeReal(8.32, BERDataTypes.REAL)

			const r = new Reader(w.buffer)
			const tag = r.peek()
			expect(tag).toEqual(BERDataTypes.REAL)
			const s = r.readValue()
			expect(s).toEqual({ value: 8.32, type: ParameterType.Real })
		})
		test('writeValue - readValue', () => {
			const w = new Writer()
			w.writeValue({ value: 8.32, type: ParameterType.Real })

			const r = new Reader(w.buffer)
			const tag = r.peek()
			expect(tag).toEqual(BERDataTypes.REAL)
			const s = r.readValue()
			expect(s).toEqual({ value: 8.32, type: ParameterType.Real })
		})
		test('writeValue - readValue (input int)', () => {
			const w = new Writer()
			w.writeValue({ value: 4, type: ParameterType.Real })

			const r = new Reader(w.buffer)
			const tag = r.peek()
			expect(tag).toEqual(BERDataTypes.REAL)
			const s = r.readValue()
			expect(s).toEqual({ value: 4, type: ParameterType.Real })
		})
	})
})

================
File: src/Ber/__tests__/writer.spec.ts
================
import { Writer } from '../Writer'
import { BERDataTypes } from '../BERDataTypes'

describe('BER', () => {
	describe('Writer', () => {
		test('Real', () => {
			const w = new Writer()
			w.writeReal(8.32, BERDataTypes.REAL)

			const expected = Buffer.from([0x09, 0x09, 0x80, 0x03, 0x04, 0x28, 0xf5, 0xc2, 0x8f, 0x5c, 0x29])
			expect(w.buffer).toEqual(expected)
		})
	})
})

================
File: src/Ber/BERDataTypes.ts
================
/**  ITU-TX.690 (08/2015) Chapter 8 */

enum BERDataTypes {
	BOOLEAN = 1,
	INTEGER = 2,
	BITSTRING = 3,
	OCTETSTRING = 4,
	NULL = 5,
	OBJECTIDENTIFIER = 6,
	OBJECTDESCRIPTOR = 7,
	EXTERNAL = 8,
	REAL = 9,
	ENUMERATED = 10,
	EMBEDDED = 11,
	STRING = 12,
	RELATIVE_OID = 13,
	SEQUENCE = 0x20 | 16,
	SET = 0x20 | 17,
}

export { BERDataTypes }

================
File: src/Ber/functions.ts
================
/**  ITU-TX.690 (08/2015) 8.1.2 */
function APPLICATION(x: number): number {
	return x | 0x60
}
function CONTEXT(x: number): number {
	return x | 0xa0
}
function UNIVERSAL(x: number): number {
	return x
}

export { APPLICATION, CONTEXT, UNIVERSAL }

================
File: src/Ber/index.ts
================
import { Reader } from './Reader'
import { Writer } from './Writer'
import { BERDataTypes } from './BERDataTypes'
import { APPLICATION, CONTEXT, UNIVERSAL } from './functions'

export { Reader, Writer, BERDataTypes, APPLICATION, CONTEXT, UNIVERSAL }

================
File: src/Ber/Reader.ts
================
import { Reader } from 'asn1'
import Long from 'long'
import { ASN1Error, UnimplementedEmberTypeError } from '../Errors'
import { BERDataTypes } from './BERDataTypes'
import { UNIVERSAL } from './functions'
import { EmberTypedValue } from '../types/types'
import { ParameterType } from '../model/Parameter'

export { ExtendedReader as Reader }

class ExtendedReader extends Reader {
	constructor(data: Buffer) {
		super(data)
	}

	// This is bad. No need to create a new reader for every tag!
	// getSequence(tag: number): ExtendedReader {
	// 	const buf = this.readString(tag, true)
	// 	return new ExtendedReader(buf)
	// }

	readValue(): EmberTypedValue {
		const tag = this.peek()
		if (!tag) {
			throw new Error('No tag available')
		}

		switch (tag) {
			case BERDataTypes.STRING:
				return { type: ParameterType.String, value: this.readString(BERDataTypes.STRING) }
			case BERDataTypes.INTEGER:
				return { type: ParameterType.Integer, value: this.readInt() }
			case BERDataTypes.REAL:
				return { type: ParameterType.Real, value: this.readReal() }
			case BERDataTypes.BOOLEAN:
				return { type: ParameterType.Boolean, value: this.readBoolean() }
			case BERDataTypes.OCTETSTRING:
				return { type: ParameterType.Octets, value: this.readString(UNIVERSAL(4), true) }
			case BERDataTypes.RELATIVE_OID:
				return { type: ParameterType.String, value: this.readOID(BERDataTypes.RELATIVE_OID) }
			case BERDataTypes.NULL: // Note: No readNull in BER library but writer writes 2 bytes
				this.readByte(false) // Read past - ASN1.NULL tag 0x05
				this.readByte(false) // and - 0x00 length
				return { type: ParameterType.Null, value: null }
			default:
				throw new UnimplementedEmberTypeError(tag)
		}
	}

	readReal(tag?: number): number | null {
		if (tag !== null) {
			tag = UNIVERSAL(9)
		}

		const b = this.peek()
		if (b === null) {
			return null
		}

		const buf = this.readString(b, true)
		if (buf.length === 0) {
			return 0
		}

		const preamble = buf.readUInt8(0)
		let o = 1

		if (buf.length === 1) {
			switch (preamble) {
				case 0x40:
					return Infinity
				case 0x41:
					return -Infinity
				case 0x42:
					return NaN
			}
		}

		const sign = preamble & 0x40 ? -1 : 1
		const exponentLength = 1 + (preamble & 3)
		const significandShift = (preamble >> 2) & 3

		let exponent = 0

		if (buf.readUInt8(o) & 0x80) {
			exponent = -1
		}

		if (buf.length - o < exponentLength) {
			throw new ASN1Error('Invalid ASN.1; not enough length to contain exponent')
		}

		for (let i = 0; i < exponentLength; i++) {
			exponent = (exponent << 8) | buf.readUInt8(o++)
		}

		let significand = new Long(0, 0, true)
		while (o < buf.length) {
			significand = significand.shl(8).or(buf.readUInt8(o++))
		}

		significand = significand.shl(significandShift)

		while (significand.and(Long.fromBits(0x00000000, 0x7ffff000, true)).eq(0)) {
			significand = significand.shl(8)
		}

		while (significand.and(Long.fromBits(0x00000000, 0x7ff00000, true)).eq(0)) {
			significand = significand.shl(1)
		}

		significand = significand.and(Long.fromBits(0xffffffff, 0x000fffff, true))

		let bits = Long.fromNumber(exponent).add(1023).shl(52).or(significand)
		if (sign < 0) {
			bits = bits.or(Long.fromBits(0x00000000, 0x80000000, true))
		}

		const fbuf = Buffer.alloc(8)
		fbuf.writeUInt32LE(bits.getLowBitsUnsigned(), 0)
		fbuf.writeUInt32LE(bits.getHighBitsUnsigned(), 4)

		return fbuf.readDoubleLE(0)
	}
}

================
File: src/Ber/Writer.ts
================
import Long from 'long'
import { Writer, WriterOptions } from 'asn1'

import { CONTEXT, UNIVERSAL } from './functions'
import { BERDataTypes } from './BERDataTypes'
import { Parameter, ParameterType, isParameter } from '../model/Parameter'
import { EmberValue, EmberTypedValue } from '../types/types'

export { ExtendedWriter as Writer }

class ExtendedWriter extends Writer {
	constructor(options?: WriterOptions) {
		super(options)
	}

	writeReal(value: number, tag: number): void {
		if (tag === undefined) {
			tag = UNIVERSAL(9)
		}

		this.writeByte(tag)

		switch (value) {
			case 0:
				this.writeLength(0)
				return
			case Infinity:
				this.writeLength(1)
				this.writeByte(0x40)
				return
			case -Infinity:
				this.writeLength(1)
				this.writeByte(0x41)
				return
			default:
				if (isNaN(value)) {
					this.writeLength(1)
					this.writeByte(0x42)
					return
				}
		}

		const fbuf = Buffer.alloc(8)
		fbuf.writeDoubleLE(value, 0)

		const bits = Long.fromBits(fbuf.readUInt32LE(0), fbuf.readUInt32LE(4), true)

		let significand = bits
			.and(Long.fromBits(0xffffffff, 0x000fffff, true))
			.or(Long.fromBits(0x00000000, 0x00100000, true))

		let exponent: Long.Long | number = bits
			.and(Long.fromBits(0x00000000, 0x7ff00000, true))
			.shru(52)
			.sub(1023)
			.toSigned()

		while (significand.and(0xff).toNumber() === 0) {
			significand = significand.shru(8)
		}

		while (significand.and(0x01).toNumber() === 0) {
			significand = significand.shru(1)
		}

		exponent = exponent.toNumber()

		const shortExp = shorten(exponent)
		const shortSig = shortenLong(significand)

		this.writeLength(1 + shortExp.size + shortSig.size)

		const preamble = value < 0 ? 0x80 | 0x40 : 0x80 // in what case will 0x80|0x40 be anything but 0xC0?
		this.writeByte(preamble)

		for (let i = 0; i < shortExp.size; i++) {
			this.writeByte((shortExp.value & 0xff000000) >> 24)
			shortExp.value <<= 8
		}

		const mask = Long.fromBits(0x00000000, 0xff000000, true)
		for (let i = 0; i < shortSig.size; i++) {
			this.writeByte(shortSig.value.and(mask).shru(56).toNumber())
			shortSig.value = shortSig.value.shl(8)
		}
	}

	writeValue(value: EmberValue, tag?: number): void
	writeValue(typedValue: EmberTypedValue): void
	writeValue(arg1: EmberValue | EmberTypedValue, tag?: number): void {
		let value: EmberValue
		if (arg1 && typeof arg1 === 'object' && 'type' in arg1) {
			value = arg1.value
			tag = parameterTypetoBERTAG(arg1.type)
		} else {
			value = arg1 as EmberValue
		}

		if (tag === BERDataTypes.NULL && (value === null || value === undefined)) {
			this.writeNull()
			return
		}
		if (value === null || value === undefined) {
			this.writeNull()
			return
		}

		if (typeof value === 'number') {
			if (tag !== BERDataTypes.REAL && Number.isInteger(value)) {
				if (tag === undefined) {
					tag = BERDataTypes.INTEGER
				}
				this.writeInt(value, tag)
				return
			}

			if (tag === undefined) {
				tag = BERDataTypes.REAL
			}
			this.writeReal(value, tag)
			return
		}

		if (typeof value == 'boolean') {
			if (tag === undefined) {
				tag = BERDataTypes.BOOLEAN
			}
			this.writeBoolean(value, tag)
			return
		}

		if (Buffer.isBuffer(value) && tag) {
			if (value.length === 0) {
				this.writeByte(tag)
				this.writeLength(0)
			} else {
				this.writeBuffer(value, tag)
			}
			return
		}

		if (tag === undefined) {
			tag = BERDataTypes.STRING
		}
		this.writeString(value.toString(), tag)
	}

	writeEmberParameter(value: Parameter): void {
		if (isParameter(value)) {
			switch (value.parameterType) {
				case ParameterType.Real:
					this.writeReal(value.value as number, BERDataTypes.REAL)
					break
				case ParameterType.Integer:
					this.writeInt(value.value as number, BERDataTypes.INTEGER)
					break
				case ParameterType.Boolean:
					this.writeBoolean(value.value as boolean, BERDataTypes.BOOLEAN)
					break
				case ParameterType.Octets:
					if (!Buffer.isBuffer(value.value)) {
						value.value = Buffer.from(`${value.value}`)
					}
					if (value.value.length) {
						this.writeByte(BERDataTypes.OCTETSTRING)
						this.writeLength(0)
					} else {
						this.writeBuffer(value.value, BERDataTypes.OCTETSTRING)
					}
					break
				case ParameterType.Null:
					this.writeNull()
					break
				default:
					this.writeString(value.value as string, BERDataTypes.STRING)
			}
		} else {
			this.writeValue((value as any).value, undefined)
		}
	}

	writeIfDefined<T>(
		property: T | undefined,
		writer: (value: T, tag: number) => void,
		outer: number,
		inner: number
	): void {
		if (property != null) {
			this.startSequence(CONTEXT(outer))
			writer.call(this, property, inner)
			this.endSequence()
		}
	}
}

function shorten(value: number): { size: number; value: number } {
	let size = 4
	while (((value & 0xff800000) === 0 || (value & 0xff800000) === 0xff800000 >> 0) && size > 1) {
		size--
		value <<= 8
	}

	return { size, value }
}

function shortenLong(value: Long): { size: number; value: Long } {
	const mask = Long.fromBits(0x00000000, 0xff800000, true)
	value = value.toUnsigned()

	let size = 8
	while (value.and(mask).eq(0) || (value.and(mask).eq(mask) && size > 1)) {
		size--
		value = value.shl(8)
	}

	return { size, value }
}

function parameterTypetoBERTAG(parameterType: ParameterType): number {
	switch (parameterType) {
		case ParameterType.Integer:
			return BERDataTypes.INTEGER
		case ParameterType.Real:
			return BERDataTypes.REAL
		case ParameterType.String:
			return BERDataTypes.STRING
		case ParameterType.Boolean:
			return BERDataTypes.BOOLEAN
		case ParameterType.Trigger:
			return BERDataTypes.STRING // TODO: this is a guess
		case ParameterType.Enum:
			return BERDataTypes.ENUMERATED
		case ParameterType.Octets:
			return BERDataTypes.OCTETSTRING
		case ParameterType.Null:
			return BERDataTypes.NULL
		default:
			throw new Error(``)
	}
}

================
File: src/Ember/Client/__tests__/index.spec.ts
================
import {
	NumberedTreeNode,
	EmberElement,
	NumberedTreeNodeImpl,
	EmberNodeImpl,
	ParameterImpl,
	ParameterType,
	QualifiedElementImpl,
	StreamFormat,
} from '../../../model'
import { Collection, EmberTypedValue, Root, RootElement } from '../../../types/types'
import { EmberClient } from '../'
import S101ClientMock from '../../../__mocks__/S101Client'
import { DecodeResult } from '../../../encodings/ber/decoder/DecodeResult'
import { StreamDescriptionImpl } from '../../../model/StreamDescription'
import { StreamEntry, StreamEntryImpl } from '../../../model/StreamEntry'
// import { EmberTreeNode, RootElement } from '../../../types/types'
// import { ElementType, EmberElement } from '../../../model/EmberElement'
// import { Parameter, ParameterType } from '../../../model/Parameter'

jest.mock('../../Socket/S101Client', () => require('../../../__mocks__/S101Client'))

describe('client', () => {
	const onSocketCreate = jest.fn()
	const onConnection = jest.fn()
	const onSocketClose = jest.fn()
	const onSocketWrite = jest.fn()
	const onConnectionChanged = jest.fn()

	function setupSocketMock() {
		S101ClientMock.mockOnNextSocket((socket: any) => {
			onSocketCreate()

			socket.onConnect = onConnection
			socket.onWrite = onSocketWrite
			socket.onClose = onSocketClose
		})
	}

	beforeEach(() => {
		setupSocketMock()
	})
	afterEach(() => {
		const sockets = S101ClientMock.openSockets()
		// Destroy any lingering sockets, to prevent a failing test from affecting other tests:
		sockets.forEach((s) => s.destroy())

		S101ClientMock.clearMockOnNextSocket()
		onSocketCreate.mockClear()
		onConnection.mockClear()
		onSocketClose.mockClear()
		onSocketWrite.mockClear()
		onConnectionChanged.mockClear()

		// Just a check to ensure that the unit tests cleaned up the socket after themselves:
		// eslint-disable-next-line jest/no-standalone-expect
		expect(sockets).toHaveLength(0)
	})

	async function runWithConnection(fn: (connection: EmberClient, socket: S101ClientMock) => Promise<void>) {
		const client = new EmberClient('test')
		try {
			expect(client).toBeTruthy()

			await client.connect()

			// Wait for connection
			await new Promise(setImmediate)

			// Should be connected
			expect(client.connected).toBeTruthy()

			const sockets = S101ClientMock.openSockets()
			expect(sockets).toHaveLength(1)
			expect(onSocketWrite).toHaveBeenCalledTimes(0)

			await fn(client, sockets[0])
		} finally {
			// Ensure cleaned up
			await client.disconnect()
			client.discard()

			await new Promise(setImmediate)
		}
	}

	function createQualifiedNodeResponse(
		path: string,
		content: EmberElement,
		children: Collection<NumberedTreeNode<EmberElement>> | undefined
	): DecodeResult<Root> {
		const parent = new QualifiedElementImpl<EmberElement>(path, content, children)

		const fixLevel = (node: NumberedTreeNode<EmberElement>, parent: NumberedTreeNode<EmberElement>) => {
			node.parent = parent

			for (const child of Object.values<NumberedTreeNode<EmberElement>>(node.children ?? {})) {
				fixLevel(child, node)
			}
		}
		if (children) {
			for (const child of Object.values<NumberedTreeNode<EmberElement>>(children)) {
				fixLevel(child, parent as any as NumberedTreeNode<EmberElement>)
			}
		}
		return {
			value: {
				0: parent as Exclude<RootElement, NumberedTreeNode<EmberElement>>,
			},
		}
	}

	function createStreamParameter(opts: {
		identifier: string
		streamId: number
		value?: number
		offset?: number
		format?: StreamFormat
	}) {
		return new ParameterImpl(
			ParameterType.Real,
			opts.identifier,
			undefined, // description
			opts.value ?? 0.0,
			undefined, // maximum
			undefined, // minimum
			undefined, // access
			undefined, // format
			undefined, // enumeration
			undefined, // factor
			undefined, // isOnline
			undefined, // formula
			undefined, // step
			undefined, // defaultValue
			opts.streamId,
			undefined, // enumMap
			new StreamDescriptionImpl(opts.format ?? StreamFormat.Float32LE, opts.offset ?? 0)
		)
	}

	function createStreamEntryResponse(entries: Array<{ identifier: number; value: EmberTypedValue }>) {
		return {
			value: entries.map((entry) => new StreamEntryImpl(entry.identifier, entry.value)),
		}
	}

	it('getDirectory resolves', async () => {
		await runWithConnection(async (client, socket) => {
			// Do initial load
			const getRootDirReq = await client.getDirectory(client.tree)
			getRootDirReq.response?.catch(() => null) // Ensure uncaught response is ok
			expect(onSocketWrite).toHaveBeenCalledTimes(1)
			// TODO: should the value of the call be checked?

			// Mock a valid response
			socket.mockData({
				value: {
					1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Ruby', undefined, undefined, true)),
				},
			})

			// Should have a response
			const res = (await getRootDirReq.response) as NumberedTreeNodeImpl<EmberElement>
			expect(res).toMatchObject(new NumberedTreeNodeImpl(1, new EmberNodeImpl('Ruby', undefined, undefined, true)))
		})
	})

	it('getElementByPath', async () => {
		await runWithConnection(async (client, socket) => {
			// Do initial load
			const getRootDirReq = await client.getDirectory(client.tree)
			getRootDirReq.response?.catch(() => null) // Ensure uncaught response is ok
			expect(onSocketWrite).toHaveBeenCalledTimes(1)
			onSocketWrite.mockClear()

			// Mock a valid response
			socket.mockData({
				value: {
					1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Ruby', undefined, undefined, true)),
				},
			})
			await getRootDirReq.response

			// Run the tree
			const getByPathPromise = client.getElementByPath('Ruby.Sums.On')

			// First lookup
			expect(onSocketWrite).toHaveBeenCalledTimes(1)
			socket.mockData({
				value: {
					1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Ruby', undefined, undefined, true), {
						1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Sums', undefined, undefined, true)),
					}),
				},
			})

			await new Promise(setImmediate)

			// Second lookup
			expect(onSocketWrite).toHaveBeenCalledTimes(2)
			socket.mockData({
				value: {
					1: new QualifiedElementImpl<EmberElement>('1.1', new EmberNodeImpl('Sums', undefined, undefined, false), {
						1: new NumberedTreeNodeImpl(1, new ParameterImpl(ParameterType.Boolean, 'On', undefined, false)),
					}) as Exclude<RootElement, NumberedTreeNode<EmberElement>>,
				},
			})

			await new Promise(setImmediate)

			// lookup on the parameter
			expect(onSocketWrite).toHaveBeenCalledTimes(3)
			socket.mockData({
				value: {
					1: new QualifiedElementImpl<EmberElement>(
						'1.1.1',
						new ParameterImpl(ParameterType.Boolean, 'On', undefined, false)
					) as Exclude<RootElement, NumberedTreeNode<EmberElement>>,
				},
			})

			await new Promise(setImmediate)

			const res = await getByPathPromise
			expect(res).toBeTruthy()
			expect(res?.contents).toMatchObject(new ParameterImpl(ParameterType.Boolean, 'On', undefined, false))
		})
	})

	it('getElementByPath concurrent', async () => {
		await runWithConnection(async (client, socket) => {
			// Do initial load
			const getRootDirReq = await client.getDirectory(client.tree)
			getRootDirReq.response?.catch(() => null) // Ensure uncaught response is ok
			expect(onSocketWrite).toHaveBeenCalledTimes(1)
			onSocketWrite.mockClear()

			// Mock a valid response
			socket.mockData({
				value: {
					1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Ruby', undefined, undefined, true)),
				},
			})
			await getRootDirReq.response

			// Run the tree
			const getByPathPromise = client.getElementByPath('Ruby.Sums.MAIN.On')
			const getByPathPromise2 = client.getElementByPath('Ruby.Sums.MAIN.Second')

			// First lookup from both
			expect(onSocketWrite).toHaveBeenCalledTimes(2)
			socket.mockData(
				createQualifiedNodeResponse('1', new EmberNodeImpl('Ruby', undefined, undefined, true), {
					1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Sums', undefined, undefined, false)),
				})
			)

			socket.mockData(
				createQualifiedNodeResponse('1', new EmberNodeImpl('Ruby', undefined, undefined, true), {
					1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Sums', undefined, undefined, false)),
				})
			)

			await new Promise(setImmediate)

			// Second lookup
			expect(onSocketWrite).toHaveBeenCalledTimes(4)
			socket.mockData(
				createQualifiedNodeResponse('1.1', new EmberNodeImpl('Sums', undefined, undefined, false), {
					1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('MAIN', undefined, undefined, false)),
				})
			)
			await new Promise(setImmediate)
			socket.mockData(
				createQualifiedNodeResponse('1.1', new EmberNodeImpl('Sums', undefined, undefined, false), {
					1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('MAIN', undefined, undefined, false)),
				})
			)

			await new Promise(setImmediate)

			// Final tree node
			expect(onSocketWrite).toHaveBeenCalledTimes(6)
			socket.mockData(
				createQualifiedNodeResponse('1.1.1', new EmberNodeImpl('MAIN', undefined, undefined, false), {
					1: new NumberedTreeNodeImpl(1, new ParameterImpl(ParameterType.Boolean, 'On', undefined, false)),
					2: new NumberedTreeNodeImpl(2, new ParameterImpl(ParameterType.Boolean, 'Second', undefined, false)),
				})
			)

			await new Promise(setImmediate)

			// last call to the parameters just in case
			expect(onSocketWrite).toHaveBeenCalledTimes(8)
			socket.mockData(
				createQualifiedNodeResponse(
					'1.1.1.1',
					new ParameterImpl(ParameterType.Boolean, 'On', undefined, false),
					undefined
				)
			)
			socket.mockData(
				createQualifiedNodeResponse(
					'1.1.1.2',
					new ParameterImpl(ParameterType.Boolean, 'Second', undefined, false),
					undefined
				)
			)

			// Both completed successfully
			const res = await getByPathPromise
			expect(res).toBeTruthy()

			const res2 = await getByPathPromise2
			expect(res2).toBeTruthy()
		})
	})

	it('getElementByPath empty node in the root', async () => {
		await runWithConnection(async (client, socket) => {
			// Do initial load
			const getRootDirReq = await client.getDirectory(client.tree)
			getRootDirReq.response?.catch(() => null) // Ensure uncaught response is ok
			expect(onSocketWrite).toHaveBeenCalledTimes(1)
			onSocketWrite.mockClear()

			// Mock a valid response
			socket.mockData({
				value: {
					1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Ruby', undefined, undefined, true)),
				},
			})
			await getRootDirReq.response

			// Request the empty node
			const req = await client.getDirectory(client.tree[1])

			// Returns empty node
			expect(onSocketWrite).toHaveBeenCalledTimes(1)
			socket.mockData({
				value: {
					1: new NumberedTreeNodeImpl(1, new EmberNodeImpl()),
				},
			})

			await new Promise(setImmediate)

			const res = await req.response
			expect(res).toBeTruthy()
		})
	})

	it('getElementByPath empty node in the tree', async () => {
		await runWithConnection(async (client, socket) => {
			// Do initial load
			const getRootDirReq = await client.getDirectory(client.tree)
			getRootDirReq.response?.catch(() => null) // Ensure uncaught response is ok
			expect(onSocketWrite).toHaveBeenCalledTimes(1)
			onSocketWrite.mockClear()

			// Mock a valid response
			socket.mockData({
				value: {
					1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Ruby', undefined, undefined, true)),
				},
			})
			await getRootDirReq.response

			// Run the tree
			const getByPathPromise = client.getElementByPath('Ruby.Sums.Empty')

			// First lookup
			expect(onSocketWrite).toHaveBeenCalledTimes(1)
			socket.mockData({
				value: {
					1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Ruby', undefined, undefined, true), {
						1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Sums', undefined, undefined, true)),
					}),
				},
			})

			await new Promise(setImmediate)

			// Second lookup
			expect(onSocketWrite).toHaveBeenCalledTimes(2)
			socket.mockData({
				value: {
					1: new QualifiedElementImpl<EmberElement>('1.1', new EmberNodeImpl('Sums', undefined, undefined, false), {
						1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Empty', undefined, undefined, true)),
					}) as Exclude<RootElement, NumberedTreeNode<EmberElement>>,
				},
			})

			await new Promise(setImmediate)

			const getByPathRes = await getByPathPromise
			expect(getByPathRes).toBeTruthy()

			const node = client.tree[1].children?.[1].children?.[1]
			if (!node) throw new Error('Empty res') // really just a typeguard

			// Request the empty node
			const req = await client.getDirectory(node)

			// lookup on the empty node
			expect(onSocketWrite).toHaveBeenCalledTimes(3)
			socket.mockData({
				value: {
					1: new QualifiedElementImpl<EmberElement>('1.1.1', new EmberNodeImpl()) as Exclude<
						RootElement,
						NumberedTreeNode<EmberElement>
					>,
				},
			})

			await new Promise(setImmediate)

			const res = await req.response
			expect(res).toBeTruthy()
		})
	})

	describe('StreamManager Integration', () => {
		it('registers stream parameter when subscribing', async () => {
			await runWithConnection(async (client, socket) => {
				const streamParam = createStreamParameter({
					identifier: 'test-stream',
					streamId: 1,
					value: 0.5,
					offset: 0,
				})

				const paramNode = new NumberedTreeNodeImpl(1, streamParam)

				// Subscribe to parameter
				const subscribeReq = await client.subscribe(paramNode)
				subscribeReq.response?.catch(() => null)

				expect(onSocketWrite).toHaveBeenCalledTimes(1)

				// Mock successful subscription
				socket.mockData(createQualifiedNodeResponse('1', streamParam, undefined))

				// Wait for registration to complete
				await new Promise(setImmediate)

				// Get StreamManager instance and check registration
				//@ts-expect-error - private method
				const streamManager = client._streamManager
				const streamInfo = streamManager.getStreamInfoByPath('1')

				expect(streamInfo).toBeDefined()
				expect(streamInfo?.parameter.streamIdentifier).toBe(1)
				expect(streamInfo?.parameter.value).toBe(0.5)
			})
		})

		it('deregisters stream parameter when unsubscribing', async () => {
			await runWithConnection(async (client, socket) => {
				const streamParam = createStreamParameter({
					identifier: 'test-stream',
					streamId: 1,
				})

				const paramNode = new NumberedTreeNodeImpl(1, streamParam)

				// First subscribe
				const subscribeReq = await client.subscribe(paramNode)
				subscribeReq.response?.catch(() => null)

				socket.mockData(createQualifiedNodeResponse('1', streamParam, undefined))

				await new Promise(setImmediate)

				// Then unsubscribe
				const unsubscribeReq = await client.unsubscribe(paramNode)
				unsubscribeReq.response?.catch(() => null)

				socket.mockData(createQualifiedNodeResponse('1', streamParam, undefined))

				// Mock receiving stream data
				const streamData = createStreamEntryResponse([
					{
						identifier: 1,
						value: { type: ParameterType.Octets, value: 42.5 },
					},
				])
				socket.mockData(streamData)

				await new Promise(setImmediate)

				// Check parameter was deregistered
				//@ts-expect-error - private method
				const streamManager = client._streamManager
				const streamInfo = streamManager.getStreamInfoByPath('1')

				expect(streamInfo).toBeUndefined()
			})
		})

		it('processes stream data with specific offsets', async () => {
			await runWithConnection(async (client, socket) => {
				// Create test parameters with specific offsets
				const streamParam1 = createStreamParameter({
					identifier: 'test-stream1',
					streamId: 1,
					offset: 64,
					format: StreamFormat.Float32LE,
				})

				const streamParam2 = createStreamParameter({
					identifier: 'test-stream2',
					streamId: 1,
					offset: 68,
					format: StreamFormat.Float32LE,
				})

				const path1 = '1.3.17.3'
				const path2 = '1.3.18.3'

				// Create qualified element wrappers for the parameters
				const param1Element = new QualifiedElementImpl(path1, streamParam1)
				const param2Element = new QualifiedElementImpl(path2, streamParam2)

				// Subscribe to parameters using qualified elements
				const subscribe1 = await client.subscribe(param1Element)
				const subscribe2 = await client.subscribe(param2Element)

				subscribe1.response?.catch(() => null)
				subscribe2.response?.catch(() => null)

				// Mock successful subscriptions with qualified paths
				socket.mockData({
					value: {
						1: param1Element,
					},
				})
				socket.mockData({
					value: {
						1: param2Element,
					},
				})

				await new Promise(setImmediate)

				// Create the buffer with repeating values except last 8 bytes
				const buffer = Buffer.from([
					0x00,
					0x00,
					0x48,
					0xc3, // -200.0 repeated multiple times
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x00,
					0x00,
					0x48,
					0xc3,
					0x74,
					0xb7,
					0x1e,
					0xc2, // -39.67915344238281 at offset 64
					0xb6,
					0xe1,
					0xbe,
					0xc1, // -23.860210418701172 at offset 68
				])

				// Get StreamManager instance and verify values
				//@ts-expect-error - private method
				const streamManager = client._streamManager

				const decoded: Collection<StreamEntry> = [
					{
						identifier: 1,
						value: {
							type: ParameterType.Octets,
							value: buffer,
						},
					},
				]

				streamManager.updateAllStreamValues(decoded)
				const stream1 = streamManager.getStreamInfoByPath(path1)
				console.log('stream1', stream1)
				const stream2 = streamManager.getStreamInfoByPath(path2)

				expect(stream1?.parameter.value).toBeCloseTo(-39.67915344238281)
				expect(stream2?.parameter.value).toBeCloseTo(-23.860210418701172)
			})
		})
	})
})

================
File: src/Ember/Client/__tests__/index.test.ts_
================
import { EmberClient } from '../'
import { EmberTreeNode, RootElement } from '../../../types/types'
import { ElementType, EmberElement } from '../../../model/EmberElement'
import { Qualified } from '../../../model/Qualified'
import { Parameter, ParameterType } from '../../../model/Parameter'

describe('client', () => {
	describe('Tree Updates', () => {
		describe('GetDirectory - qualified', () => {
			const client = new EmberClient('test')

			client._applyRootToTree([
				{
					value: {
						number: 1,
						type: ElementType.Node,
						isRoot: true,
						isOnline: true
					},
					children: [
						{
							value: {
								number: 1,
								type: ElementType.Node,
								isOnline: true,
								identifier: 'Faders'
							}
						},
						{
							value: {
								number: 2,
								type: ElementType.Node,
								isOnline: true,
								identifier: 'Sums'
							}
						}
					]
				} as EmberTreeNode
			])

			client._applyRootToTree([
				{
					value: {
						number: 1,
						type: ElementType.Node
					},
					children: [
						{
							value: {
								number: 1,
								type: ElementType.Node
							},
							children: [
								{
									value: {
										number: 1,
										type: ElementType.Node,
										isOnline: true,
										identifier: 'Channel 1'
									}
								},
								{
									value: {
										number: 2,
										type: ElementType.Node,
										isOnline: true,
										identifier: 'Channel 2'
									}
								}
							]
						}
					]
				} as EmberTreeNode
            ])

			client._applyRootToTree([
				{
                    path: '1.1.2'
					value: {
						value: {
                            number: 2,
                            type: ElementType.Node,
                            isOnline: true,
                            identifier: 'Channel 2'
                        },
                        children: [
                            {
                                value: {
                                    number: 1,
                                    type: ElementType.Parameter,
                                    isOnline: true,
                                    identifier: 'Fader level',
                                    paramterType: ParameterType.Real,
                                    value: -21.2,
                                    minimum: -191,
                                    maximum: 12
                                } as Parameter
                            },
                        ]
                    },
                    getRelativeOID: () => {}
				} as Qualified<Node>
			])
		})
	})
})

================
File: src/Ember/Client/index.ts
================
import {
	EmberValue,
	RootElement,
	QualifiedElement,
	TreeElement,
	NumberedTreeNode,
	EmberTypedValue,
	RootType,
	Collection,
	Root,
} from '../../types/types'
import { InvocationResult } from '../../model/InvocationResult'
import { Matrix } from '../../model/Matrix'
import { EmberElement, ElementType } from '../../model/EmberElement'
import {
	Command,
	GetDirectoryImpl,
	SubscribeImpl,
	UnsubscribeImpl,
	Unsubscribe,
	GetDirectory,
	CommandType,
	FieldFlags,
	Subscribe,
	Invoke,
} from '../../model/Command'
import { Parameter } from '../../model/Parameter'
import { Connection, ConnectionDisposition, ConnectionOperation } from '../../model/Connection'
import { EmberNode } from '../../model/EmberNode'
import { EventEmitter } from 'eventemitter3'
import { S101Client } from '../Socket'
import { getPath, assertQualifiedEmberNode, insertCommand, updateProps, isEmptyNode } from '../Lib/util'
import { berEncode } from '../../encodings/ber'
import { NumberedTreeNodeImpl } from '../../model/Tree'
import { EmberFunction } from '../../model/EmberFunction'
import { DecodeResult } from '../../encodings/ber/decoder/DecodeResult'
import { StreamEntry } from '../../model/StreamEntry'
import { StreamManager } from './StreamManager'

export type RequestPromise<T> = Promise<RequestPromiseArguments<T>>
export interface RequestPromiseArguments<T> {
	sentOk: boolean
	reqId?: string
	cancel?: () => void
	response?: Promise<T>
}

export enum ExpectResponse {
	None = 'none',
	Any = 'any',
	HasChildren = 'has-children',
}

export interface Request {
	reqId: string
	node: RootElement
	// Basic validation of the response change
	nodeResponse: ExpectResponse
	resolve: (res: any) => void
	reject: (err: Error) => void
	cb?: (EmberNode: TreeElement<EmberElement>) => void
	message: Buffer
	firstSent: number
	lastSent: number
}

export interface Subscription {
	path: string | undefined // undefined implies root level
	cb: (EmberNode: TreeElement<EmberElement>) => void
}

export interface Change {
	path: string | undefined
	node: RootElement
	emptyNode?: boolean
}

export enum ConnectionStatus {
	Error,
	Disconnected,
	Connecting,
	Connected,
}

export type EmberClientEvents = {
	error: [Error]
	warn: [Error]

	connected: []
	disconnected: []
	streamUpdate: [path: string, value: EmberValue]
}

export class EmberClient extends EventEmitter<EmberClientEvents> {
	host: string
	port: number
	tree: Collection<NumberedTreeNode<EmberElement>> = []

	private _streamManager: StreamManager
	private _requests = new Map<string, Request>()
	private _lastInvocation = 0
	private _client: S101Client
	private _subscriptions: Array<Subscription> = []

	private _timeout = 3000
	private _resendTimeout = 1000
	private _resends = false
	private _timer: NodeJS.Timeout

	constructor(host: string, port = 9000, timeout = 3000, enableResends = false, resendTimeout = 1000) {
		super()

		this.host = host
		this.port = port
		this._timeout = timeout
		this._resendTimeout = resendTimeout
		this._resends = enableResends
		this._streamManager = new StreamManager()

		// Forward stream events from StreamManager
		this._streamManager.on('streamUpdate', (path, value) => {
			this.emit('streamUpdate', path, value)
		})

		// resend timer runs at greatest common divisor of timeouts and resends
		const findGcd = (a: number, b: number) => {
			// assuming a and b are greater than 0
			while (b) {
				const t = b
				b = a % b
				a = t
			}
			return a
		}
		this._timer = setInterval(() => this._resendTimer(), findGcd(this._timeout, this._resendTimeout))

		this._client = new S101Client(this.host, this.port)
		this._client.on('emberTree', (tree: DecodeResult<Root>) => {
			// Regular ember tree
			this._handleIncoming(tree)
		})
		this._client.on('emberStreamTree', (tree: DecodeResult<Root>) => {
			// Ember Tree with Stream
			const entries = tree.value as Collection<StreamEntry>
			this._streamManager.updateAllStreamValues(entries)
		})

		this._client.on('error', (e) => this.emit('error', e))
		this._client.on('connected', () => this.emit('connected'))
		this._client.on('disconnected', () => {
			this._requests.forEach((req) => {
				req.reject(new Error('Socket was disconnected'))
				this._requests.delete(req.reqId)
			})
			this.emit('disconnected')
		})
	}

	/**
	 * Opens an s101 socket to the provider.
	 * @param host The host of the emberplus provider
	 * @param port Port of the provider
	 */
	async connect(host?: string, port?: number): Promise<void | Error> {
		if (host) this.host = host
		if (port) this.port = port

		if (!this.host) return Promise.reject('No host specified')

		this._client.address = this.host
		this._client.port = this.port

		return this._client.connect()
	}

	/**
	 * Closes the s101 socket to the provider
	 */
	async disconnect(): Promise<void> {
		return this._client.disconnect()
	}

	/**
	 * Discards any outgoing connections, removes all requests and clears any timing loops
	 *
	 * This is destructive, using this class after discarding will cause errors.
	 */
	discard(): void {
		this.disconnect().catch(() => null) // we're not worried about errors after this
		this._client.removeAllListeners()
		// @ts-expect-error: after using this method, properties are no longer expected to always exist
		delete this._client
		this._requests.forEach((req) => {
			req.reject(new Error('Socket was disconnected'))
			this._requests.delete(req.reqId)
		})
		clearInterval(this._timer)
	}

	get connected(): boolean {
		return this._client.status === ConnectionStatus.Connected
	}

	/** Ember+ commands: */
	async getDirectory(
		node: RootElement | Collection<RootElement>,
		dirFieldMask?: FieldFlags,
		cb?: (EmberNode: TreeElement<EmberElement>) => void
	): RequestPromise<Root | RootElement> {
		if (!node) {
			throw new Error('No node specified')
		}
		const command: GetDirectory = new GetDirectoryImpl(dirFieldMask)

		if (!('number' in node || 'path' in node)) {
			if (cb)
				this._subscriptions.push({
					path: undefined,
					cb,
				})

			return this._sendRequest<Root>(new NumberedTreeNodeImpl(0, command), ExpectResponse.Any)
		}

		if (cb)
			this._subscriptions.push({
				path: getPath(node),
				cb,
			})

		return this._sendCommand<RootElement>(node, command, ExpectResponse.HasChildren)
	}
	async subscribe(
		node: RootElement | Array<RootElement>,
		cb?: (EmberNode: TreeElement<EmberElement>) => void
	): RequestPromise<Root | void> {
		if (!node) {
			throw new Error('No node specified')
		}

		const command: Subscribe = new SubscribeImpl()

		if (Array.isArray(node)) {
			if (cb)
				this._subscriptions.push({
					path: undefined,
					cb,
				})

			return this._sendRequest<Root>(new NumberedTreeNodeImpl(0, command), ExpectResponse.Any)
		}

		// Check if this is a Parameter with streamIdentifier
		if (node.contents.type === ElementType.Parameter) {
			const parameter = node.contents
			if (parameter.streamIdentifier !== undefined) {
				this._streamManager.registerParameter(parameter, getPath(node))
			}
		}

		if (cb)
			this._subscriptions.push({
				path: getPath(node),
				cb,
			})

		return this._sendCommand<void>(node, command, ExpectResponse.None)
	}
	async unsubscribe(node: NumberedTreeNode<EmberElement> | Array<RootElement>): RequestPromise<Root | void> {
		if (!node) {
			throw new Error('No node specified')
		}

		const command: Unsubscribe = new UnsubscribeImpl()

		const path = Array.isArray(node) ? '' : getPath(node)

		// Clean up subscriptions
		for (const i in this._subscriptions) {
			if (this._subscriptions[i].path === path) {
				this._subscriptions.splice(Number(i), 1)
			}
		}

		// Deregister from StreamManager if this was a Parameter with streamIdentifier
		if (!Array.isArray(node) && node.contents.type === ElementType.Parameter) {
			const parameter = node.contents
			if (parameter.streamIdentifier !== undefined) {
				this._streamManager.unregisterParameter(path)
			}
		}

		if (Array.isArray(node)) {
			return this._sendRequest<Root>(new NumberedTreeNodeImpl(0, command), ExpectResponse.Any)
		}

		return this._sendCommand<void>(node, command, ExpectResponse.None)
	}
	async invoke(
		node: NumberedTreeNode<EmberFunction> | QualifiedElement<EmberFunction>,
		...args: Array<EmberTypedValue>
	): RequestPromise<InvocationResult> {
		if (!node) {
			throw new Error('No node specified')
		}

		// TODO - validate arguments
		const command: Invoke = {
			type: ElementType.Command,
			number: CommandType.Invoke,
			invocation: {
				id: ++this._lastInvocation,
				args,
			},
		}
		return this._sendCommand<InvocationResult>(node, command, ExpectResponse.Any)
	}

	/** Sending ember+ values */
	async setValue(
		node: QualifiedElement<Parameter> | NumberedTreeNode<Parameter>,
		value: EmberValue,
		awaitResponse = true
	): RequestPromise<TreeElement<Parameter>> {
		if (!node) {
			throw new Error('No node specified')
		}

		const qualifiedParam = assertQualifiedEmberNode(node) as QualifiedElement<Parameter>

		// TODO - validate value
		// TODO - should other properties be scrapped

		qualifiedParam.contents.value = value

		return this._sendRequest<TreeElement<Parameter>>(
			qualifiedParam,
			awaitResponse ? ExpectResponse.Any : ExpectResponse.None
		)
	}
	async matrixConnect(
		matrix: QualifiedElement<Matrix> | NumberedTreeNode<Matrix>,
		target: number,
		sources: Array<number>
	): RequestPromise<TreeElement<Matrix>> {
		return this._matrixMutation(matrix, target, sources, ConnectionOperation.Connect)
	}
	async matrixDisconnect(
		matrix: QualifiedElement<Matrix> | NumberedTreeNode<Matrix>,
		target: number,
		sources: Array<number>
	): RequestPromise<TreeElement<Matrix>> {
		return this._matrixMutation(matrix, target, sources, ConnectionOperation.Disconnect)
	}
	async matrixSetConnection(
		matrix: QualifiedElement<Matrix> | NumberedTreeNode<Matrix>,
		target: number,
		sources: Array<number>
	): RequestPromise<TreeElement<Matrix>> {
		return this._matrixMutation(matrix, target, sources, ConnectionOperation.Absolute)
	}

	/** Getting the tree: */
	async expand(node: NumberedTreeNode<EmberElement> | Collection<RootElement>): Promise<void> {
		if (!node) {
			throw new Error('No node specified')
		}

		if (!('number' in node)) {
			await (
				await this.getDirectory(node)
			).response
			for (const root of Object.values<NumberedTreeNode<EmberElement>>(this.tree)) await this.expand(root)
			return
		}

		const emberNodes = [node]
		const canBeExpanded = (node: NumberedTreeNode<EmberElement>) => {
			if (node.contents.type === ElementType.Node) {
				return (node as NumberedTreeNode<EmberNode>).contents.isOnline !== false
			} else {
				return node.contents.type !== ElementType.Parameter && node.contents.type !== ElementType.Function
			}
		}

		let curEmberNode
		while ((curEmberNode = emberNodes.shift())) {
			if (curEmberNode.children) {
				emberNodes.push(...Object.values<NumberedTreeNode<EmberElement>>(curEmberNode.children).filter(canBeExpanded))
			} else {
				const req = await this.getDirectory(curEmberNode)
				if (!req.response) continue
				const res = (await req.response) as RootElement
				if (res.children) {
					Object.values<NumberedTreeNode<EmberElement>>(res.children).forEach(
						(c) => canBeExpanded(c) && emberNodes.push(c)
					)
				}
			}
		}
	}
	async getElementByPath(
		path: string,
		cb?: (EmberNode: TreeElement<EmberElement>) => void,
		delimiter = '.'
	): Promise<TreeElement<EmberElement> | undefined> {
		const getNodeInCollection = (elements: Collection<NumberedTreeNode<EmberElement>>, identifier: string) =>
			Object.values<NumberedTreeNode<EmberElement>>(elements || {}).find(
				(r) =>
					r.number === Number(identifier) ||
					(r.contents as EmberNode).identifier === identifier ||
					(r.contents as EmberNode).description === identifier
			)
		const getNextChild = (node: TreeElement<EmberElement>, identifier: string) =>
			node.children && getNodeInCollection(node.children, identifier)

		const numberedPath: Array<number> = []
		const pathArr = path.split(delimiter)
		const firstIdentifier = pathArr.shift()
		if (!firstIdentifier) throw new Error('Expected at least one segment in the path')

		let tree: NumberedTreeNode<EmberElement> | undefined = getNodeInCollection(this.tree, firstIdentifier)
		if (tree?.number !== undefined) numberedPath.push(tree.number)

		while (pathArr.length) {
			const i = pathArr.shift()
			if (i === undefined) break // TODO - this will break the loop if the path was `1..0`
			if (!tree) break

			let next = getNextChild(tree, i)
			if (!next) {
				const req = await this.getDirectory(tree)
				tree = (await req.response) as NumberedTreeNode<EmberElement>
				next = getNextChild(tree, i)
			}
			tree = next

			if (!tree) throw new Error(`Could not find node ${i} on given path ${numberedPath.join()}`)
			if (tree?.number !== undefined) numberedPath.push(tree.number)
		}

		if (tree?.contents.type === ElementType.Parameter) {
			// do an additional getDirectory because Providers do not _have_ to send updates without that (should vs shall)
			const req = await this.getDirectory(tree)
			await req.response
		}

		if (cb && numberedPath) {
			this._subscriptions.push({
				path: numberedPath.join('.'),
				cb,
			})
		}

		return tree
	}

	// This function handles the fact that the path in the Ember+ tree is not always the same as the path in requested from the provider
	getInternalNodePath(node: TreeElement<EmberElement>): string | undefined {
		if ('path' in node && typeof node.path === 'string') {
			// QualifiedElement case
			return node.path
		} else if ('number' in node) {
			// NumberedTreeNode case
			const numbers: number[] = []
			let current: NumberedTreeNode<EmberElement> | undefined = node as NumberedTreeNode<EmberElement>

			while (current) {
				numbers.unshift(current.number)
				if (current.parent && 'number' in current.parent) {
					current = current.parent as NumberedTreeNode<EmberElement>
				} else {
					current = undefined
				}
			}

			return numbers.join('.')
		}

		return undefined
	}

	private async _matrixMutation(
		matrix: QualifiedElement<Matrix> | NumberedTreeNode<Matrix>,
		target: number,
		sources: Array<number>,
		operation: ConnectionOperation
	) {
		if (!matrix) {
			throw new Error('No matrix specified')
		}

		const qualifiedMatrix = assertQualifiedEmberNode(matrix) as QualifiedElement<Matrix>

		const connection: Connection = {
			operation,
			target,
			sources,
		}

		qualifiedMatrix.contents.connections = [connection]

		return this._sendRequest<TreeElement<Matrix>>(qualifiedMatrix, ExpectResponse.Any)
	}

	private async _sendCommand<T>(node: RootElement, command: Command, expectResponse: ExpectResponse) {
		// assert a qualified EmberNode
		const qualifiedEmberNode = assertQualifiedEmberNode(node)
		// insert command
		const commandEmberNode = insertCommand(qualifiedEmberNode, command)
		// send request
		return this._sendRequest<T>(commandEmberNode, expectResponse)
	}

	private async _sendRequest<T>(node: RootElement, expectResponse: ExpectResponse): RequestPromise<T> {
		const reqId = Math.random().toString(24).substr(-4)
		const requestPromise: RequestPromiseArguments<T> = {
			reqId,
			sentOk: false,
		}

		const message = berEncode([node], RootType.Elements)

		if (expectResponse !== ExpectResponse.None) {
			const p = new Promise<T>((resolve, reject) => {
				const request: Request = {
					reqId,
					node,
					nodeResponse: expectResponse,
					resolve,
					reject,
					message,
					firstSent: Date.now(),
					lastSent: Date.now(),
				}
				this._requests.set(reqId, request)

				requestPromise.cancel = () => {
					reject(new Error('Request cancelled'))
					this._requests.delete(reqId)
				}
			})
			requestPromise.response = p
		}

		const sentOk = this._client.sendBER(message) // TODO - if sending multiple values to same path, should we do synchronous requests?

		if (!sentOk && requestPromise.cancel) {
			this._requests.get(reqId)?.reject(new Error('Request was not sent correctly'))
			this._requests.delete(reqId)
		}

		return {
			...requestPromise,
			sentOk,
		}
	}

	private _handleIncoming(incoming: DecodeResult<Root>) {
		const node = incoming.value

		// update tree:
		const changes = this._applyRootToTree(node)

		// check for subscriptiions:
		for (const change of changes) {
			const subscription = this._subscriptions.find((s) => s.path === change.path)
			if (subscription && change.node) subscription.cb(change.node)
		}

		// check for any outstanding requests and resolve them
		// iterate over requests, check path, if Invocation check id
		// resolve requests
		for (const change of changes) {
			const reqs = Array.from(this._requests.values()).filter(
				(s) => (!('path' in s.node) && !change.path) || ('path' in s.node && s.node.path === change.path)
			)
			for (const req of reqs) {
				// Don't complete the response, if the call was expecting the children to be loaded
				if (req.nodeResponse === ExpectResponse.HasChildren && !change.node.children) {
					if (change.node.contents.type === ElementType.Parameter) {
						// can't have children, therefore don't continue
					} else if (change.emptyNode) {
						// update comes from an empty node, so we can't continue anyway
					} else {
						continue
					}
				}

				if (req.cb) req.cb(change.node)
				if (req.resolve) {
					req.resolve(change.node)
					this._requests.delete(req.reqId)
				}
			}
		}

		// at last, emit the errors for logging purposes
		incoming.errors?.forEach((e) => this.emit('warn', e))
	}

	private _applyRootToTree(node: Root): Array<Change> {
		const changes: Array<Change> = []

		if ('id' in node) {
			// node is an InvocationResult
			this._requests.forEach((req) => {
				if (req.node.contents.type === ElementType.Function) {
					if (req.node.children && req.node.children[0]) {
						if ('invocation' in (req.node.children[0].contents as Invoke)) {
							if (
								(req.node.children[0].contents as Invoke).invocation?.id &&
								(req.node.children[0].contents as Invoke).invocation?.id === node.id
							) {
								req.resolve(node)
								this._requests.delete(req.reqId)
							}
						}
					}
				}
			})
		} else {
			// EmberNode is not an InvocationResult

			// walk tree
			for (const rootElement of Object.values<RootElement>(node as Collection<RootElement>)) {
				if ('identifier' in rootElement) {
					// rootElement is a StreamEntry
					continue
				} else if ('path' in rootElement) {
					// element is qualified
					const path: Array<string> = rootElement.path.split('.')
					let tree = this.tree[Number(path.shift())]
					let inserted = false

					if (!tree) {
						if (path.length) {
							// Assuming this means that no get directory was done on the root of the tree.
							changes.push({ path: rootElement.path, node: rootElement })
							continue
						} else {
							const number = Number(rootElement.path)
							// Insert node into root
							this.tree[number] = new NumberedTreeNodeImpl(number, rootElement.contents, rootElement.children)
							changes.push({ path: undefined, node: this.tree[number] })
							continue
						}
					}

					for (const number of path) {
						if (!tree.children) tree.children = {}
						if (!tree.children[Number(number)]) {
							tree.children[Number(number)] = {
								...rootElement,
								number: Number(number),
								parent: tree,
							}
							changes.push({
								path: rootElement.path.split('.').slice(0, -1).join('.'),
								node: tree,
							})
							inserted = true
							break
						}
						tree = tree.children[Number(number)]
					}

					if (inserted) continue
					changes.push(...this._updateTree(rootElement, tree))
				} else {
					if (rootElement.children) {
						if (this.tree[rootElement.number]) {
							changes.push(...this._updateTree(rootElement, this.tree[rootElement.number]))
						} else {
							this.tree[rootElement.number] = rootElement
							changes.push({ path: undefined, node: rootElement })
						}
					} else if (isEmptyNode(rootElement)) {
						// empty node on the root of the tree must mean we have done a getDir on that specific node
						changes.push({ path: rootElement.number + '', node: rootElement, emptyNode: true })
					} else {
						// this must have been something on the root of the tree (like GetDirectory)
						this.tree[rootElement.number] = rootElement
						changes.push({ path: undefined, node: rootElement })
					}
				}
			}
		}

		return changes
	}

	private _updateTree(update: TreeElement<EmberElement>, tree: NumberedTreeNode<EmberElement>): Array<Change> {
		const changes: Array<Change> = []

		if (update.contents.type === tree.contents.type) {
			changes.push({ path: getPath(tree), node: tree, emptyNode: isEmptyNode(update) })
			// changes.push({ path: getPath(tree), node: tree })
			switch (tree.contents.type) {
				case ElementType.Node:
					this._updateEmberNode(update.contents as EmberNode, tree.contents)
					break
				case ElementType.Parameter:
					this._updateParameter(update.contents as Parameter, tree.contents)
					break
				case ElementType.Matrix:
					this._updateMatrix(update.contents as Matrix, tree.contents)
					break
			}
		}
		if (update.children && tree.children) {
			// Update children
			for (const child of Object.values<NumberedTreeNode<EmberElement>>(update.children)) {
				const i = child.number
				const oldChild = tree.children[i] // as NumberedTreeNode<EmberElement> | undefined // TODO
				changes.push(...this._updateTree(child, oldChild))
			}
		} else if (update.children) {
			changes.push({ path: getPath(tree), node: tree })
			tree.children = update.children
			for (const c of Object.values<NumberedTreeNode<EmberElement>>(update.children)) {
				c.parent = tree
			}
		}

		return changes
	}

	private _updateEmberNode(update: EmberNode, EmberNode: EmberNode) {
		updateProps<EmberNode>(EmberNode, update, ['isOnline'])
	}

	private _updateParameter(update: Parameter, parameter: Parameter) {
		updateProps<Parameter>(parameter, update, ['value', 'isOnline', 'access'])
	}

	private _updateMatrix(update: Matrix, matrix: Matrix) {
		updateProps<Matrix>(matrix, update, ['targets', 'targetCount', 'sources', 'sourceCount', 'connections'])

		// update connections
		if (update.connections) {
			if (matrix.connections) {
				// matrix already has connections
				for (const connection of Object.values<Connection>(update.connections as { [target: number]: Connection })) {
					if (
						!connection.disposition ||
						!(
							connection.disposition === ConnectionDisposition.Locked ||
							connection.disposition === ConnectionDisposition.Pending
						)
					) {
						// update is either generic, tally or modification
						let exists = false
						for (const i in matrix.connections) {
							if (matrix.connections[i].target === connection.target) {
								// found connection to update
								exists = true
								matrix.connections[i].sources = connection.sources
							}
						}

						if (!exists) {
							// connection to target does not exist yet
							matrix.connections[connection.target] = {
								target: connection.target,
								sources: connection.sources,
							}
						}
					}
				}
			} else {
				// connections have not been set yet
				matrix.connections = update.connections
			}
		}
	}

	private _resendTimer() {
		if (this.connected) {
			this._requests.forEach((req) => {
				const sinceSent = Date.now() - req.lastSent
				const sinceFirstSent = Date.now() - req.firstSent
				if (this._resends && sinceSent >= this._resendTimeout) {
					const sent = this._client.sendBER(req.message)
					if (sent) {
						req.lastSent = Date.now()
					} else {
						req.reject(new Error('Request was not sent correctly'))
					}
				}
				if (sinceFirstSent >= this._timeout) {
					req.reject(new Error('Request timed out'))
					this._requests.delete(req.reqId)
				}
			})
		}
	}
}

================
File: src/Ember/Client/StreamManager.ts
================
import { EventEmitter } from 'eventemitter3'
import { Parameter, ParameterType } from '../../model/Parameter'
import { EmberValue } from '../../types'
import { Collection } from '../../types/types'
import { StreamEntry } from '../../model'

export type StreamManagerEvents = {
	streamUpdate: [path: string, value: EmberValue]
}

interface StreamInfo {
	parameter: Parameter
	path: string
	streamIdentifier: number
	offset: number
}

export class StreamManager extends EventEmitter<StreamManagerEvents> {
	private registeredStreams: Map<string, StreamInfo> = new Map()

	constructor() {
		super()
	}

	public registerParameter(parameter: Parameter, path: string): void {
		if (!parameter.streamIdentifier) {
			return
		}

		const offset = parameter.streamDescriptor?.offset || 0

		const streamInfo: StreamInfo = {
			parameter,
			path,
			streamIdentifier: parameter.streamIdentifier,
			offset: offset,
		}

		// Store both mappings
		this.registeredStreams.set(path, streamInfo)

		console.log('Registered stream:', {
			path: path,
			identifier: parameter.identifier,
			offset: offset,
		})
	}

	public unregisterParameter(path: string): void {
		const streamInfo = this.registeredStreams.get(path)
		if (streamInfo && streamInfo.parameter.streamIdentifier) {
			this.registeredStreams.delete(path)
			console.log('Unregistered stream:', {
				path: path,
				identifier: streamInfo.parameter.identifier,
			})
		}
	}

	public getStreamInfoByPath(path: string): StreamInfo | undefined {
		return this.registeredStreams.get(path)
	}

	public hasStream(identifier: string): boolean {
		return this.registeredStreams.has(identifier)
	}

	public updateAllStreamValues(streamEntries: Collection<StreamEntry>): void {
		Object.values<StreamEntry>(streamEntries).forEach((streamEntry) => {
			this.registeredStreams.forEach((streamInfo, path) => {
				// Only process if IDs match
				if (streamInfo.streamIdentifier === streamEntry.identifier) {
					if (streamEntry.value) {
						const value = streamEntry.value

						if (value.type === ParameterType.Integer) {
							// Handle direct integer values
							this.updateStreamValue(path, value.value)
						} else if (value.type === ParameterType.Octets && Buffer.isBuffer(value.value)) {
							// Handle existing float32 buffer case
							const buffer = value.value
							if (buffer.length >= streamInfo.offset + 4) {
								// Float32 is 4 bytes
								const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.length)
								// decode as little-endian
								const decodedValue = view.getFloat32(streamInfo.offset, true)

								this.updateStreamValue(path, decodedValue)
							}
						}
					}
				}
			})
		})
	}

	public updateStreamValue(path: string, value: EmberValue): void {
		if (path) {
			const streamInfo = this.registeredStreams.get(path)
			if (streamInfo) {
				streamInfo.parameter.value = value
				this.emit('streamUpdate', path, value)
			}
		}
	}

	public getAllRegisteredPaths(): string[] {
		return Array.from(this.registeredStreams.keys())
	}

	// Debug helper
	public printStreamState(): void {
		console.log('\nCurrent Stream State:')
		console.log('Registered Streams:')
		this.registeredStreams.forEach((info, path) => {
			console.log(`  Path: ${path}`)
			console.log(`    Identifier: ${info.parameter.identifier}`)
			console.log(`    StreamId: ${info.parameter.streamIdentifier}`)
			console.log(`    Current Value: ${info.parameter.value}`)
		})
	}
}

================
File: src/Ember/Lib/index.ts
================
const EmberLib = {
	DecodeBuffer: null,
}

export { EmberLib }

================
File: src/Ember/Lib/util.ts
================
import { QualifiedElement, NumberedTreeNode, RootElement } from '../../types/types'
import { EmberElement, ElementType } from '../../model/EmberElement'
import { Command } from '../../model/Command'
import { QualifiedElementImpl, NumberedTreeNodeImpl, TreeElement } from '../../model/Tree'
import { EmberNode } from '../../model'

export function assertQualifiedEmberNode(node: RootElement): Exclude<RootElement, NumberedTreeNode<EmberElement>> {
	if ('path' in node) {
		return node
	} else {
		return toQualifiedEmberNode(node)
	}
}

export function getPath(node: RootElement): string {
	function isQualified(node: TreeElement<EmberElement>): node is QualifiedElement<EmberElement> {
		return 'path' in node
	}
	function isNumbered(node: TreeElement<EmberElement>): node is NumberedTreeNode<EmberElement> {
		return 'number' in node
	}
	if (isQualified(node)) {
		return node.path
	} else if (isNumbered(node)) {
		if (node.parent) {
			return getPath(node.parent) + '.' + node.number
		} else {
			return node.number + ''
		}
	}

	return ''
}

export function toQualifiedEmberNode(
	EmberNode: NumberedTreeNode<EmberElement>
): Exclude<RootElement, NumberedTreeNode<EmberElement>> {
	const path = getPath(EmberNode)

	if (EmberNode.contents.type === ElementType.Command) {
		throw new Error('Cannot convert a command to a qualified node')
	}

	return new QualifiedElementImpl<EmberElement>(
		path,
		EmberNode.contents,
		EmberNode.children // TODO - do we want the children?
	) as Exclude<RootElement, NumberedTreeNode<EmberElement>>
}

export function insertCommand(
	node: Exclude<RootElement, NumberedTreeNode<EmberElement>>,
	command: Command
): Exclude<RootElement, NumberedTreeNode<EmberElement>> {
	return new QualifiedElementImpl<EmberElement>(node.path, node.contents, [
		new NumberedTreeNodeImpl(0, command),
	]) as Exclude<RootElement, NumberedTreeNode<EmberElement>>
}

export function updateProps<T extends object>(oldProps: T, newProps: T, props?: Array<keyof T>): void {
	if (!props) props = Object.keys(newProps) as Array<keyof T>

	for (const key of props) {
		if (newProps[key] !== undefined && newProps[key] !== oldProps[key]) {
			oldProps[key] = newProps[key]
		}
	}
}

/**
 * Check if a value is an error, or wrap it in one
 */
export function normalizeError(e: unknown): Error {
	if (e instanceof Error) {
		return e
	}

	return new Error(typeof e === 'string' ? e : (e as any)?.toString())
}

export function isEmptyNode(node: TreeElement<EmberElement>): boolean {
	const isNode = (node: TreeElement<EmberElement>): node is TreeElement<EmberNode> => {
		return node.contents.type === ElementType.Node
	}

	if (!isNode(node)) {
		return false
	}

	if (node.children) {
		return false
	}

	// Check if any of these properties have a value, including empty strings as a node with an empty description is not empty)
	const notEmpty = [
		node.contents.description,
		node.contents.identifier,
		node.contents.isOnline,
		node.contents.isRoot,
		node.contents.schemaIdentifiers,
		node.contents.templateReference,
	].some((value) => value !== undefined && value !== null)

	return !notEmpty
}

================
File: src/Ember/Server/index.ts
================
import { EventEmitter } from 'eventemitter3'
import { S101Server } from '../Socket/S101Server'
import {
	EmberElement,
	NumberedTreeNodeImpl,
	ElementType,
	EmberFunction,
	InvocationResult,
	EmberNode,
	Parameter,
	MatrixImpl,
	Matrix,
	Connections,
	EmberNodeImpl,
} from '../../model'
import {
	Collection,
	RootElement,
	NumberedTreeNode,
	QualifiedElement,
	RootType,
	TreeElement,
	EmberValue,
} from '../../types/types'
import { DecodeResult } from '../../encodings/ber/decoder/DecodeResult'
import { toQualifiedEmberNode } from '../Lib/util'
import { berEncode } from '../../encodings/ber'
import { Command, CommandType, FieldFlags, GetDirectory, Invoke } from '../../model/Command'
import { Connection, ConnectionOperation, ConnectionImpl } from '../../model/Connection'
import { InvocationResultImpl } from '../../model/InvocationResult'
import S101Socket from '../Socket/S101Socket'

export type EmberServerEvents = {
	error: [Error]
	clientError: [client: S101Socket, error: Error]
}

export class EmberServer extends EventEmitter<EmberServerEvents> {
	address: string | undefined
	port: number
	tree: Collection<NumberedTreeNode<EmberElement>> = {}

	onInvocation?: (
		emberFunction: NumberedTreeNode<EmberFunction>,
		invocation: NumberedTreeNode<Invoke>
	) => Promise<InvocationResult>
	onSetValue?: (parameter: NumberedTreeNode<Parameter>, value: EmberValue) => Promise<boolean>
	onMatrixOperation?: (Matrix: NumberedTreeNode<Matrix>, connection: Connections) => Promise<void>

	private _server: S101Server
	private _clients: Set<S101Socket> = new Set()
	private _subscriptions: { [path: string]: Array<S101Socket> } = {}

	constructor(port: number, address?: string) {
		super()

		this.address = address
		this.port = port
		this._server = new S101Server(port, address)

		this._server.on('connection', (client: S101Socket) => {
			this._clients.add(client)

			client.on('emberTree', (tree) => this._handleIncoming(tree as DecodeResult<Collection<RootElement>>, client))

			client.on('error', (e) => {
				this.emit('clientError', client, e)
			})

			client.on('disconnected', () => {
				this._clearSubscription(client)
				this._clients.delete(client)
			})
		})
	}

	async init(tree: Collection<NumberedTreeNode<EmberElement>>): Promise<void> {
		const setParent = (parent: NumberedTreeNode<EmberElement>, child: NumberedTreeNode<EmberElement>) => {
			child.parent = parent
			if (child.children) {
				for (const c of Object.values<NumberedTreeNode<EmberElement>>(child.children)) {
					setParent(child, c)
				}
			}
		}
		for (const rootEl of Object.values<NumberedTreeNode<EmberElement>>(tree)) {
			if (rootEl.children) {
				for (const c of Object.values<NumberedTreeNode<EmberElement>>(rootEl.children)) {
					setParent(rootEl, c)
				}
			}
		}
		this.tree = tree
		return this._server.listen()
	}

	discard(): void {
		this._clients.forEach((c) => {
			c.removeAllListeners()
		})
		this._clients.clear()
		this._server.server?.close()
	}

	update<T extends EmberElement>(element: NumberedTreeNode<T>, update: Partial<T>): void {
		if (element.contents.type === ElementType.Matrix) {
			const matrix: NumberedTreeNode<Matrix> = element as NumberedTreeNode<Matrix>
			const matrixUpdate: Partial<Matrix> = update as Partial<Matrix>

			if (matrixUpdate.connections) {
				for (const connection of Object.values<Connection>(
					matrixUpdate.connections as { [target: number]: Connection }
				)) {
					this.updateMatrixConnection(matrix, connection)
				}
			}
		}
		for (const [key, value] of Object.entries<any>(update)) {
			element.contents[key as keyof T] = value
		}
		const el = toQualifiedEmberNode(element)
		const data = berEncode([el], RootType.Elements)
		let elPath = el.path
		if (el.contents.type !== ElementType.Node && !('targets' in update || 'sources' in update)) {
			elPath = elPath.slice(0, -2) // remove the last element number
		}

		for (const [path, clients] of Object.entries<S101Socket[]>(this._subscriptions)) {
			if (elPath === path) {
				clients.forEach((client) => {
					client.sendBER(data)
				})
			}
		}
	}

	updateMatrixConnection(element: NumberedTreeNode<Matrix>, update: Connection): void {
		if (!element.contents.connections) element.contents.connections = {}
		let connection = element.contents.connections[update.target]
		if (!connection) {
			element.contents.connections[update.target] = new ConnectionImpl(update.target, [])
			connection = element.contents.connections[update.target]
		}
		if (!connection.sources) connection.sources = []

		switch (update.operation) {
			case ConnectionOperation.Connect:
				for (const source of update.sources || []) {
					if (!connection.sources.find((v) => v === source)) {
						connection.sources.push(source)
					}
				}
				break
			case ConnectionOperation.Disconnect:
				for (const source of update.sources || []) {
					connection.sources = connection.sources.filter((oldSource) => oldSource !== source)
				}
				break
			case ConnectionOperation.Absolute:
			default:
				connection.sources = update.sources
				break
		}

		const qualified = toQualifiedEmberNode(element) as QualifiedElement<Matrix>
		qualified.contents = new MatrixImpl(qualified.contents.identifier, undefined, undefined, {
			[connection.target]: connection,
		})
		const data = berEncode([qualified], RootType.Elements)

		for (const [path, clients] of Object.entries<S101Socket[]>(this._subscriptions)) {
			if (qualified.path === path) {
				clients.forEach((client) => {
					client.sendBER(data)
				})
			}
		}
	}

	private _handleIncoming(incoming: DecodeResult<Collection<RootElement>>, client: S101Socket) {
		for (const rootEl of Object.values<RootElement>(incoming.value)) {
			if (rootEl.contents.type === ElementType.Command) {
				// command on root
				this._handleCommand('', rootEl as NumberedTreeNode<Command>, client).catch((e) => this.emit('error', e))
			} else if ('path' in rootEl) {
				this._handleNode(rootEl.path || '', rootEl, client)
			} else if ('number' in rootEl) {
				this._handleNode(rootEl.number + '' || '', rootEl, client)
			}
		}
	}

	private _handleNode(
		path: string,
		el: QualifiedElement<EmberElement> | NumberedTreeNode<EmberElement>,
		client: S101Socket
	) {
		const children = Object.values<NumberedTreeNode<EmberElement>>(el.children || {})

		if (children[0] && children[0].contents.type === ElementType.Command) {
			this._handleCommand(path, children[0] as NumberedTreeNode<Command>, client).catch((e) => this.emit('error', e))
			return
		} else if (el.contents.type === ElementType.Matrix && 'connections' in el.contents) {
			this._handleMatrix(path, el as QualifiedElement<Matrix> | NumberedTreeNode<Matrix>).catch((e) =>
				this.emit('error', e)
			)
		}

		if (!el.children) {
			if (el.contents.type === ElementType.Parameter) {
				this._handleSetValue(path, el as QualifiedElement<Parameter> | NumberedTreeNode<Parameter>, client).catch((e) =>
					this.emit('error', e)
				)
			}
		} else {
			for (const c of children) {
				this._handleNode(path + '.' + c.number, c, client)
			}
		}
	}

	private async _handleMatrix(path: string, el: QualifiedElement<Matrix> | NumberedTreeNode<Matrix>) {
		if (this.onMatrixOperation) {
			const tree = this.getElementByPath(path)
			if (!tree || tree.contents.type !== ElementType.Matrix || !el.contents.connections) return

			return this.onMatrixOperation(tree as NumberedTreeNode<Matrix>, el.contents.connections)
		}
	}

	private async _handleSetValue(
		path: string,
		el: QualifiedElement<Parameter> | NumberedTreeNode<Parameter>,
		client: S101Socket
	) {
		const tree = this.getElementByPath(path)
		if (!tree || tree.contents.type !== ElementType.Parameter || el.contents.value === undefined) return

		let success = false
		if (this.onSetValue) {
			success = await this.onSetValue(tree as NumberedTreeNode<Parameter>, el.contents.value)
		}

		if (!success) {
			const qualified = toQualifiedEmberNode(tree)
			const encoded = berEncode([qualified], RootType.Elements)

			client.sendBER(encoded)
		}
	}

	private async _handleCommand(path: string, el: NumberedTreeNode<Command>, client: S101Socket) {
		const tree = path ? this.getElementByPath(path) : this.tree
		if (!tree) return

		if (el.contents.number === CommandType.Subscribe) {
			this._subscribe(path, client)
		} else if (el.contents.number === CommandType.Unsubscribe) {
			this._unsubscribe(path, client)
		} else if (el.contents.number === CommandType.GetDirectory) {
			this._subscribe(path, client) // send updates to client
			this._handleGetDirectory(tree, (el.contents as GetDirectory).dirFieldMask || FieldFlags.Default, client)
		} else if (el.contents.number === CommandType.Invoke) {
			let result: InvocationResult
			if (this.onInvocation) {
				result = await this.onInvocation(tree as NumberedTreeNode<EmberFunction>, el as NumberedTreeNode<Invoke>)
			} else {
				result = new InvocationResultImpl((el as NumberedTreeNode<Invoke>).contents.invocation?.id || -1, false)
			}
			const encoded = berEncode(result, RootType.InvocationResult)
			client.sendBER(encoded)
		}
	}

	getElementByPath(path: string, delimiter = '.'): NumberedTreeNode<EmberElement> | undefined {
		const getNext = (elements: Collection<NumberedTreeNode<EmberElement>>, i?: string) =>
			Object.values<NumberedTreeNode<EmberElement>>(elements || {}).find(
				(r) =>
					r.number === Number(i) ||
					(r.contents as EmberNode).identifier === i ||
					(r.contents as EmberNode).description === i
			)
		const getNextChild = (node: TreeElement<EmberElement>, i: string) => node.children && getNext(node.children, i)

		const numberedPath: Array<number> = []
		const pathArr = path.split(delimiter)
		const i = pathArr.shift()
		let tree: NumberedTreeNode<EmberElement> | undefined = getNext(this.tree, i)
		if (tree?.number) numberedPath.push(tree?.number)

		while (pathArr.length) {
			const i = pathArr.shift()
			if (!i) break
			if (!tree) break
			const next = getNextChild(tree, i)
			if (!next) {
				// not found
				return
			}
			tree = next
			if (!tree) return
			if (tree?.number) numberedPath.push(tree?.number)
		}

		return tree
	}

	private _subscribe(path: string, client: S101Socket) {
		this._subscriptions[path] = [...(this._subscriptions[path] || []), client]
	}
	private _unsubscribe(path: string, client: S101Socket) {
		if (!this._subscriptions[path]) return

		this._subscriptions[path].forEach((c, i) => {
			if (c === client) {
				this._subscriptions[path].splice(i, 1)
			}
		})
	}
	private _clearSubscription(client: S101Socket) {
		for (const path of Object.keys(this._subscriptions)) {
			this._unsubscribe(path, client)
		}
	}

	private _handleGetDirectory(
		tree: Collection<NumberedTreeNode<EmberElement>> | NumberedTreeNode<EmberElement>,
		_dirFieldMasks: FieldFlags,
		client: S101Socket
	) {
		if (tree === this.tree) {
			// getDir on root
			const response: Collection<NumberedTreeNode<EmberElement>> = { ...this.tree }
			for (const [i, rootEl] of Object.entries<NumberedTreeNode<EmberElement>>(this.tree)) {
				response[i as unknown as number] = new NumberedTreeNodeImpl(rootEl.number, rootEl.contents)
			}
			const data = berEncode(response, RootType.Elements)
			client.sendBER(data)
		} else {
			const qualified = toQualifiedEmberNode(tree as NumberedTreeNode<EmberElement>)
			qualified.children = {} // destroy ref to this.tree
			if ('children' in tree && tree.children) {
				for (const [i, child] of Object.entries<NumberedTreeNode<EmberElement>>(tree.children)) {
					if (child.contents.type === ElementType.Matrix) {
						// matrix should not have connections, targets and sources:
						qualified.children[i as unknown as number] = new NumberedTreeNodeImpl(
							child.number,
							new MatrixImpl(
								child.contents.identifier,
								undefined,
								undefined,
								undefined,
								child.contents.description,
								child.contents.matrixType,
								child.contents.addressingMode,
								child.contents.targetCount,
								child.contents.sourceCount,
								child.contents.maximumTotalConnects,
								child.contents.maximumConnectsPerTarget,
								child.contents.parametersLocation,
								child.contents.gainParameterNumber,
								child.contents.labels,
								child.contents.schemaIdentifiers,
								child.contents.templateReference
							)
						)
					} else {
						qualified.children[i as unknown as number] = new NumberedTreeNodeImpl(child.number, child.contents)
					}
				}
			} else if (qualified.contents.type === ElementType.Node && !('children' in tree && tree.children)) {
				// node without children -> none of the properties should be set
				qualified.contents = new EmberNodeImpl()
				qualified.children = undefined
			}
			const data = berEncode([qualified as RootElement], RootType.Elements)
			client.sendBER(data)
		}
	}
}

================
File: src/Ember/Socket/index.ts
================
import S101Client from './S101Client'

export { S101Client }

================
File: src/Ember/Socket/S101Client.ts
================
import net from 'net'
import S101Socket from './S101Socket'
import { ConnectionStatus } from '../Client'
import { normalizeError } from '../Lib/util'

import Debug from 'debug'
const debug = Debug('emberplus-connection:S101Client')

const DEFAULT_PORT = 9000
const RECONNECT_ATTEMPTS = 60
const AUTO_RECONNECT_DELAY = 5000

export default class S101Client extends S101Socket {
	address: string
	port: number
	autoConnect = false

	private _autoReconnect = true
	private _autoReconnectDelay: number = AUTO_RECONNECT_DELAY
	private _connectionAttemptTimer: NodeJS.Timeout | undefined = undefined
	private _reconnectAttempt = 0
	private _reconnectAttempts: number = RECONNECT_ATTEMPTS
	private _shouldBeConnected: boolean
	private _lastConnectionAttempt = 0

	/**
	 *
	 * @param {string} address
	 * @param {number} port=9000
	 */
	constructor(address: string, port = DEFAULT_PORT, autoConnect?: boolean) {
		super()
		this.address = address
		this.port = port

		this.autoConnect = !!autoConnect
		this._shouldBeConnected = this.autoConnect

		if (this.autoConnect) this.connect().catch(() => null) // errors are already emitted
	}

	async connect(timeout = 5): Promise<Error | void> {
		return new Promise((resolve) => {
			if (this.status !== ConnectionStatus.Disconnected) {
				// TODO - perhaps we should reconnect when addresses/ports have changed
				resolve()
				return
			}
			if (!this._lastConnectionAttempt || Date.now() - this._lastConnectionAttempt >= this._autoReconnectDelay) {
				// !_lastReconnectionAttempt means first attempt, OR > _reconnectionDelay since last attempt
				// recreates client if new attempt
				if (this.socket && this.socket.connecting) {
					this.socket.destroy()
					this.socket.removeAllListeners()
					delete this.socket
					// @todo: fire event telling it gives up!
				}

				// (re)creates client, either on first run or new attempt
				if (!this.socket) {
					this.socket = new net.Socket()
					this.socket.on('close', (hadError) => this._onClose(hadError))
					this.socket.on('connect', () => this._onConnect())
					this.socket.on('data', (data) => {
						debug('Data from Ember connection received:', {
							address: this.socket?.remoteAddress,
							port: this.socket?.remotePort,
							dataLength: data.length,
							data: data.toString('hex'),
						})
						try {
							this.codec.dataIn(data)
						} catch (e) {
							this.emit('error', normalizeError(e))
						}
					})
					this.socket.on('error', (error) => this._onError(error))
				}

				this.emit('connecting')
				this.status = ConnectionStatus.Disconnected
				const connectTimeoutListener = () => {
					if (this.socket) {
						this.socket.destroy()
						this.socket.removeAllListeners()
						delete this.socket
					}
					const reason = new Error(
						`Could not connect to ${this.address}:${this.port} after a timeout of ${timeout} seconds`
					)
					resolve(reason)
					if (!this._connectionAttemptTimer) this.connect().catch(() => null)
				}

				const timer = setTimeout(() => connectTimeoutListener(), timeout * 1000)
				this.socket.connect(this.port, this.address)
				this.socket.once('connect', () => {
					clearInterval(timer)
					resolve()
				})
				this._shouldBeConnected = true
				this._lastConnectionAttempt = Date.now()
			}

			// sets timer to retry when needed
			if (!this._connectionAttemptTimer) {
				this._connectionAttemptTimer = setInterval(() => this._autoReconnectionAttempt(), this._autoReconnectDelay)
			}
		})
	}

	async disconnect(timeout?: number): Promise<void> {
		this._shouldBeConnected = false
		return super.disconnect(timeout)
	}

	protected handleClose(): void {
		if (this.keepaliveIntervalTimer) clearInterval(this.keepaliveIntervalTimer)
		this.socket?.destroy()
	}

	private _autoReconnectionAttempt(): void {
		if (this._autoReconnect) {
			if (this._reconnectAttempts > 0) {
				// no reconnection if no valid reconnectionAttemps is set
				if (this._reconnectAttempt >= this._reconnectAttempts) {
					// if current attempt is not less than max attempts
					// reset reconnection behaviour
					this._clearConnectionAttemptTimer()
					this.status = ConnectionStatus.Disconnected
					return
				}
				// new attempt if not already connected
				if (this.status !== ConnectionStatus.Connected) {
					this._reconnectAttempt++
					this.connect().catch(() => null)
				}
			}
		}
	}

	private _clearConnectionAttemptTimer() {
		// @todo create event telling reconnection ended with result: true/false
		// only if reconnection interval is true
		this._reconnectAttempt = 0
		if (this._connectionAttemptTimer) clearInterval(this._connectionAttemptTimer)
		delete this._connectionAttemptTimer
	}

	private _onConnect() {
		this._clearConnectionAttemptTimer()
		this.startKeepAlive()
		// this._sentKeepalive = Date.now()
		// this._receivedKeepalive = this._sentKeepalive + 1 // for some reason keepalive doesn't return directly after conn.
		this.status = ConnectionStatus.Connected
		this.emit('connected')
	}

	private _onError(error: Error) {
		if (error.message.match(/ECONNREFUSED/)) {
			return // we handle this internally through reconnections
		}
		this.emit('error', error)
	}

	private _onClose(_hadError: boolean) {
		if (this.status !== ConnectionStatus.Disconnected) this.emit('disconnected')
		this.status = ConnectionStatus.Disconnected

		if (this._shouldBeConnected === true) {
			this.emit('connecting')
			this.connect().catch(() => null)
		}
	}
}

================
File: src/Ember/Socket/S101Server.ts
================
import { EventEmitter } from 'eventemitter3'
import { Socket, createServer, Server } from 'net'
import S101Socket from './S101Socket'

export type S101ServerEvents = {
	error: [Error]
	listening: []
	connection: [client: S101Socket]
}
export class S101Server extends EventEmitter<S101ServerEvents> {
	port: number
	address: string | undefined
	server: Server | null
	status: string // TODO - enum

	constructor(port: number, address?: string) {
		super()
		this.port = port
		this.address = address
		this.server = null
		this.status = 'disconnected'
	}

	addClient(socket: Socket): void {
		// Wrap the tcp socket into an S101Socket.
		const client = new S101Socket(socket)
		this.emit('connection', client)
	}

	async listen(): Promise<void> {
		return new Promise((resolve, reject) => {
			if (this.status !== 'disconnected') {
				return reject(new Error('Already listening'))
			}
			this.server = createServer((socket) => {
				this.addClient(socket)
			})
				.on('error', (e) => {
					this.emit('error', e)
					if (this.status === 'disconnected') {
						return reject(e)
					}
				})
				.on('listening', () => {
					this.emit('listening')
					this.status = 'listening'
					resolve(undefined)
				})
			this.server.listen(this.port, this.address)
		})
	}

	discard(): void {
		this.server?.close()
	}
}

================
File: src/Ember/Socket/S101Socket.ts
================
import { EventEmitter } from 'eventemitter3'
import { Socket } from 'net'

import { S101Codec } from '../../S101'
import { berDecode } from '../..'
import { ConnectionStatus } from '../Client'
import { normalizeError } from '../Lib/util'
import { Root } from '../../types'
import { DecodeResult } from '../../encodings/ber/decoder/DecodeResult'

export type Request = any

export type S101SocketEvents = {
	error: [Error]
	emberTree: [root: DecodeResult<Root>]
	emberStreamTree: [root: DecodeResult<Root>]
	connecting: []
	connected: []
	disconnected: []
}

export default class S101Socket extends EventEmitter<S101SocketEvents> {
	protected socket: Socket | undefined
	private readonly keepaliveInterval = 10
	private readonly keepaliveMaxResponseTime = 500
	protected keepaliveIntervalTimer: NodeJS.Timeout | undefined
	private keepaliveResponseWindowTimer: NodeJS.Timer | null
	status: ConnectionStatus
	protected readonly codec = new S101Codec()

	constructor(socket?: Socket) {
		super()
		this.socket = socket
		this.keepaliveIntervalTimer = undefined
		this.keepaliveResponseWindowTimer = null
		this.status = this.isConnected() ? ConnectionStatus.Connected : ConnectionStatus.Disconnected

		this.codec.on('keepaliveReq', () => {
			this.sendKeepaliveResponse()
		})

		this.codec.on('keepaliveResp', () => {
			clearInterval(<NodeJS.Timeout>this.keepaliveResponseWindowTimer)
		})

		this.codec.on('emberPacket', (packet) => {
			try {
				const root = berDecode(packet)
				if (root != null) {
					this.emit('emberTree', root)
				}
			} catch (e) {
				this.emit('error', normalizeError(e))
			}
		})
		this.codec.on('emberStreamPacket', (packet) => {
			try {
				const root = berDecode(packet)
				if (root != null) {
					this.emit('emberTree', root)
				}
			} catch (e) {
				this.emit('error', normalizeError(e))
			}
		})

		this._initSocket()
	}

	private _initSocket(): void {
		if (this.socket != null) {
			this.socket.on('data', (data) => {
				try {
					this.codec.dataIn(data)
				} catch (e) {
					this.emit('error', normalizeError(e))
				}
			})

			this.socket.on('close', () => {
				this.emit('disconnected')
				this.status = ConnectionStatus.Connected
				this.socket?.removeAllListeners()
				this.socket = undefined
			})

			this.socket.on('error', (e) => {
				this.emit('error', e)
			})
		}
	}

	/**
	 * @param {number} timeout=2
	 */
	async disconnect(timeout = 2): Promise<void> {
		if (!this.isConnected() || this.socket === undefined) {
			return Promise.resolve()
		}
		return new Promise((resolve) => {
			if (this.keepaliveIntervalTimer != null) {
				clearInterval(this.keepaliveIntervalTimer)
				this.keepaliveIntervalTimer = undefined
			}
			if (this.socket) {
				let done = false
				const cb = () => {
					if (done) {
						return
					}
					done = true
					if (timer !== undefined) {
						clearTimeout(timer)
						timer = undefined
					}
					resolve()
				}
				let timer: NodeJS.Timeout | undefined
				if (timeout != null && !isNaN(timeout) && timeout > 0) {
					timer = setTimeout(cb, 100 * timeout)
				}
				this.socket.end(cb)
			}
			this.status = ConnectionStatus.Disconnected
		})
	}

	/**
	 *
	 */
	protected handleClose(): void {
		this.socket = undefined
		if (this.keepaliveIntervalTimer) clearInterval(this.keepaliveIntervalTimer)
		this.status = ConnectionStatus.Disconnected
		this.emit('disconnected')
	}

	private isConnected(): boolean {
		return this.socket !== undefined && !!this.socket
	}

	sendBER(data: Buffer): boolean {
		if (this.isConnected() && this.socket) {
			try {
				const frames = this.codec.encodeBER(data)
				for (let i = 0; i < frames.length; i++) {
					this.socket.write(frames[i])
				}
				return true
			} catch (e) {
				this.handleClose()
				return false
			}
		} else {
			return false
		}
	}

	/**
	 *
	 */
	private sendKeepaliveRequest(): void {
		if (this.isConnected() && this.socket) {
			try {
				this.socket.write(this.codec.keepAliveRequest())
				this.keepaliveResponseWindowTimer = setTimeout(() => {
					this.handleClose()
				}, this.keepaliveMaxResponseTime)
			} catch (e) {
				this.handleClose()
			}
		}
	}

	/**
	 *
	 */
	private sendKeepaliveResponse(): void {
		if (this.isConnected() && this.socket) {
			try {
				this.socket.write(this.codec.keepAliveResponse())
			} catch (e) {
				this.handleClose()
			}
		}
	}

	// sendBERNode(node: Root) {
	// 	if (!node) return
	// 	const ber = berEncode(node)
	// 	this.sendBER(ber)
	// }

	protected startKeepAlive(): void {
		this.keepaliveIntervalTimer = setInterval(() => {
			try {
				this.sendKeepaliveRequest()
			} catch (e) {
				this.emit('error', normalizeError(e))
			}
		}, 1000 * this.keepaliveInterval)
	}
}

================
File: src/encodings/ber/__tests__/Command.spec.ts
================
/* eslint-disable jest/expect-expect */
import * as Ber from '../../../Ber'
import { Command, CommandType, Subscribe, Unsubscribe, GetDirectory, FieldFlags, Invoke } from '../../../model/Command'
import { encodeCommand } from '../encoder/Command'
import { decodeCommand } from '../decoder/Command'
import { ElementType } from '../../../model/EmberElement'
import { guarded } from '../decoder/DecodeResult'

describe('encodings/ber/Command', () => {
	function testCommand(command: Command): void {
		const writer = new Ber.Writer()
		encodeCommand(command, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeCommand(reader))

		expect(decoded).toEqual(command)
	}

	test('Subscribe', () => {
		const command: Subscribe = {
			type: ElementType.Command,
			number: CommandType.Subscribe,
		}
		testCommand(command)
	})

	test('Unsubscribe', () => {
		const command: Unsubscribe = {
			type: ElementType.Command,
			number: CommandType.Unsubscribe,
		}
		testCommand(command)
	})

	test('GetDirectory', () => {
		const command: GetDirectory = {
			type: ElementType.Command,
			number: CommandType.GetDirectory,
			dirFieldMask: FieldFlags.All,
		}
		testCommand(command)
	})

	test('Invoke', () => {
		const command: Invoke = {
			type: ElementType.Command,
			number: CommandType.Invoke,
			invocation: { args: [] },
		}
		testCommand(command)
	})
})

================
File: src/encodings/ber/__tests__/Connection.spec.ts
================
import * as Ber from '../../../Ber'
import { Connection, ConnectionOperation, ConnectionDisposition } from '../../../model/Connection'
import { encodeConnection } from '../encoder/Connection'
import { decodeConnection } from '../decoder/Connection'
import { literal } from '../../../types/types'
import { guarded } from '../decoder/DecodeResult'

describe('encodings/ber/Connection', () => {
	const connection = literal<Connection>({
		target: 42,
		sources: [89, 98],
		operation: ConnectionOperation.Connect,
		disposition: ConnectionDisposition.Tally,
	})

	test('write and read a connection', () => {
		const writer = new Ber.Writer()
		encodeConnection(connection, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeConnection(reader))

		expect(decoded).toEqual(connection)
	})

	test('write and read a connection - minimal', () => {
		const minCon = { target: 42 } as Connection
		const writer = new Ber.Writer()
		encodeConnection(minCon, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeConnection(reader))

		expect(decoded).toEqual(minCon)
	})
})

================
File: src/encodings/ber/__tests__/DecodeResult.spec.ts
================
import { literal } from '../../../types/types'
import {
	DecodeResult,
	whatever,
	guarded,
	makeResult,
	defaultDecode,
	unknownContext,
	safeSet,
	check,
	appendErrors,
	unexpected,
	DecodeOptions,
	unknownApplication,
} from '../decoder/DecodeResult'

describe('encodings/ver/DecodeResult - default settings', () => {
	const goodResult = literal<DecodeResult<number>>({
		value: 42,
	})
	const resultEmptyErrors = literal<DecodeResult<number>>({
		value: 42,
		errors: [],
	})
	const resultWithError = literal<DecodeResult<number>>({
		value: 42,
		errors: [new Error('decode wibbly wobble: tag was junk')],
	})

	test('whatever', () => {
		expect(whatever(goodResult)).toBe(42)
		expect(whatever(resultEmptyErrors)).toBe(42)
		expect(whatever(resultWithError)).toBe(42)
	})

	test('guarded', () => {
		expect(guarded(goodResult)).toBe(42)
		expect(guarded(resultEmptyErrors)).toBe(42)
		expect(() => guarded(resultWithError)).toThrow(/wibbly wobble/)
	})

	test('makeResult', () => {
		expect(makeResult(42)).toEqual(resultEmptyErrors)
		expect(makeResult(42, resultWithError.errors)).toEqual(resultWithError)
	})

	test('unknownContext - decode result, number tag', () => {
		const updateMe = Object.assign({}, goodResult)
		unknownContext(updateMe, 'decode wibbly wobble', 42, defaultDecode)
		expect(updateMe.errors).toHaveLength(1)
		expect(updateMe.errors?.toString()).toMatch(/Unexpected BER context tag '42'/)
		expect(updateMe.value).toBe(42)
	})

	test('unknownContext - decode result, null tag', () => {
		const updateMe = Object.assign({}, goodResult)
		unknownContext(updateMe, 'decode wibbly wobble', null, defaultDecode)
		expect(updateMe.errors).toHaveLength(1)
		expect(updateMe.errors?.toString()).toMatch(/Unexpected BER context tag 'null'/)
		expect(updateMe.value).toBe(42)
	})

	test('unknownContext - error array, number tag', () => {
		const updateMe = new Array<Error>()
		unknownContext(updateMe, 'decode wibbly wobble', 42, defaultDecode)
		expect(updateMe).toHaveLength(1)
		expect(updateMe.toString()).toMatch(/Unexpected BER context tag '42'/)
	})

	test('unknownContext - error array, null tag', () => {
		const updateMe = new Array<Error>()
		unknownContext(updateMe, 'decode wibbly wobble', null, defaultDecode)
		expect(updateMe).toHaveLength(1)
		expect(updateMe.toString()).toMatch(/Unexpected BER context tag 'null'/)
	})

	test('unknownApplication - decode result, number tag', () => {
		const updateMe = Object.assign({}, goodResult)
		unknownApplication(updateMe, 'decode wibbly wobble', 42, defaultDecode)
		expect(updateMe.errors).toHaveLength(1)
		expect(updateMe.errors?.toString()).toMatch(/Unexpected BER application tag '42'/)
		expect(updateMe.value).toBe(42)
	})

	test('unknownApplication - decode result, null tag', () => {
		const updateMe = Object.assign({}, goodResult)
		unknownApplication(updateMe, 'decode wibbly wobble', null, defaultDecode)
		expect(updateMe.errors).toHaveLength(1)
		expect(updateMe.errors?.toString()).toMatch(/Unexpected BER application tag 'null'/)
		expect(updateMe.value).toBe(42)
	})

	test('unknownApplication - error array, number tag', () => {
		const updateMe = new Array<Error>()
		unknownApplication(updateMe, 'decode wibbly wobble', 42, defaultDecode)
		expect(updateMe).toHaveLength(1)
		expect(updateMe.toString()).toMatch(/Unexpected BER application tag '42'/)
	})

	test('unknownApplication - error array, null tag', () => {
		const updateMe = new Array<Error>()
		unknownApplication(updateMe, 'decode wibbly wobble', null, defaultDecode)
		expect(updateMe).toHaveLength(1)
		expect(updateMe.toString()).toMatch(/Unexpected BER application tag 'null'/)
	})

	test('safeSet - no error', () => {
		const result = Object.assign({}, goodResult)
		const update = makeResult([41])
		expect(
			safeSet(result, update, (x, y) => {
				y.push(x)
				return y
			})
		).toEqual({
			value: [41, 42],
			errors: [],
		})
	})

	test('safeSet - empty error', () => {
		const result = Object.assign({}, resultEmptyErrors)
		const update = makeResult([41])
		expect(
			safeSet(result, update, (x, y) => {
				y.push(x)
				return y
			})
		).toEqual({
			value: [41, 42],
			errors: [],
		})
	})

	test('safeSet - wtih source error', () => {
		const result = Object.assign({}, resultWithError)
		const update = makeResult([41])
		expect(
			safeSet(result, update, (x, y) => {
				y.push(x)
				return y
			})
		).toEqual({
			value: [41, 42],
			errors: resultWithError.errors,
		})
	})

	test('safeSet - wtih target error', () => {
		const result = Object.assign({}, goodResult)
		const update = makeResult([41], [new Error(`Second error`)])
		expect(
			safeSet(result, update, (x, y) => {
				y.push(x)
				return y
			})
		).toEqual({
			value: [41, 42],
			errors: [new Error(`Second error`)],
		})
	})

	test('safeSet - wtih source & target error', () => {
		const result = Object.assign({}, resultWithError)
		const update = makeResult([41], [new Error(`Second error`)])
		expect(
			safeSet(result, update, (x, y) => {
				y.push(x)
				return y
			})
		).toEqual({
			value: [41, 42],
			errors: [new Error(`Second error`), resultWithError.errors![0]], // eslint-disable-line @typescript-eslint/no-non-null-assertion
		})
		expect(resultWithError.errors).toHaveLength(1)
	})

	test('check - decode result, good value', () => {
		let id: number | null = 84
		const result = Object.assign({}, goodResult)
		id = check(id, 'decode wibbly wobble', 'id', -1, result, defaultDecode)
		expect(id).toBe(84)
		expect(result.errors).toBeUndefined()
	})

	test('check - decode result, null value', () => {
		let id: number | null = null
		const result = Object.assign({}, goodResult)
		id = check(id, 'decode wibbly wobble', 'id', -1, result, defaultDecode)
		expect(id).toBe(-1)
		expect(result.errors).toHaveLength(1)
		expect(result.errors?.toString()).toMatch(/For required property 'id', value is missing/)
	})

	test('check - error array, good value', () => {
		let id: number | undefined = 84
		const result = new Array<Error>()
		id = check(id, 'decode wibbly wobble', 'id', -1, result, defaultDecode)
		expect(id).toBe(84)
		expect(result).toHaveLength(0)
	})

	test('check - error array, null value', () => {
		let id: number | undefined = undefined
		const result = new Array<Error>()
		id = check(id, 'decode wibbly wobble', 'id', -1, result, defaultDecode)
		expect(id).toBe(-1)
		expect(result).toHaveLength(1)
		expect(result.toString()).toMatch(/For required property 'id', value is missing/)
	})

	test('appendErrors - extract, no change', () => {
		const source = Object.assign({}, goodResult)
		const base = Object.assign({}, resultWithError)
		expect(appendErrors(source, base)).toBe(42)
		expect(source).toEqual(goodResult)
		expect(base).toEqual(resultWithError)
	})

	test('appendErrors - extract, new error on empty', () => {
		const source = Object.assign({}, resultWithError)
		const base = Object.assign({}, goodResult)
		expect(appendErrors(source, base)).toBe(42)
		expect(source).toEqual(resultWithError)
		expect(base).toEqual(resultWithError)
	})

	test('appendErrors - extract, new error on existing', () => {
		const source = Object.assign({}, resultWithError)
		const base = Object.assign({}, resultWithError)
		expect(appendErrors(source, base)).toBe(42)
		expect(source).toEqual(resultWithError)
		expect(base.errors).toHaveLength(2)
		expect(base.errors![0]).toEqual(base.errors![1]) // eslint-disable-line @typescript-eslint/no-non-null-assertion
	})

	test('unexpected - decode result', () => {
		const updateMe = Object.assign({}, goodResult)
		expect(unexpected(updateMe, 'decode wibbly wobble', 'a message to you', 99, defaultDecode)).toEqual(
			makeResult(99, [new Error('decode wibbly wobble: a message to you')])
		)
	})

	test('unexpected - error array', () => {
		const updateMe = new Array<Error>()
		expect(unexpected(updateMe, 'decode wibbly wobble', 'a message to you', 99, defaultDecode)).toEqual(
			makeResult(99, [new Error('decode wibbly wobble: a message to you')])
		)
	})

	test('all equal in the end', () => {
		expect(goodResult).toEqual(literal<DecodeResult<number>>({ value: 42 }))
		expect(resultEmptyErrors).toEqual(
			literal<DecodeResult<number>>({
				value: 42,
				errors: [],
			})
		)
		expect(resultWithError).toEqual(
			literal<DecodeResult<number>>({
				value: 42,
				errors: [new Error('decode wibbly wobble: tag was junk')],
			})
		)
	})
})

describe('encodings/ver/DecodeResult - expect to throw', () => {
	const goodResult = literal<DecodeResult<number>>({
		value: 42,
	})

	const triggerThrow = literal<DecodeOptions>({
		skipApplicationTags: false,
		skipContextTags: false,
		substituteForRequired: false,
		skipUnexpected: false,
	})

	test('unknownContext - decode result, number tag', () => {
		const updateMe = Object.assign({}, goodResult)
		expect(() => unknownContext(updateMe, 'decode wibbly wobble', 42, triggerThrow)).toThrow()
		expect(updateMe.errors).toBeUndefined()
	})

	test('unknownContext - decode result, null tag', () => {
		const updateMe = Object.assign({}, goodResult)
		expect(() => unknownContext(updateMe, 'decode wibbly wobble', null, triggerThrow)).toThrow()
		expect(updateMe.errors).toBeUndefined()
	})

	test('unknownContext - error array, number tag', () => {
		const updateMe = new Array<Error>()
		expect(() => unknownContext(updateMe, 'decode wibbly wobble', 42, triggerThrow)).toThrow()
		expect(updateMe).toHaveLength(0)
	})

	test('unknownContext - error array, null tag', () => {
		const updateMe = new Array<Error>()
		expect(() => unknownContext(updateMe, 'decode wibbly wobble', null, triggerThrow)).toThrow()
		expect(updateMe).toHaveLength(0)
	})

	test('unknownApplication - decode result, number tag', () => {
		const updateMe = Object.assign({}, goodResult)
		expect(() => unknownApplication(updateMe, 'decode wibbly wobble', 42, triggerThrow)).toThrow()
		expect(updateMe.errors).toBeUndefined()
	})

	test('unknownApplication - decode result, null tag', () => {
		const updateMe = Object.assign({}, goodResult)
		expect(() => unknownApplication(updateMe, 'decode wibbly wobble', null, triggerThrow)).toThrow()
		expect(updateMe.errors).toBeUndefined()
	})

	test('unknownApplication - error array, number tag', () => {
		const updateMe = new Array<Error>()
		expect(() => unknownApplication(updateMe, 'decode wibbly wobble', 42, triggerThrow)).toThrow()
		expect(updateMe).toHaveLength(0)
	})

	test('unknownApplication - error array, null tag', () => {
		const updateMe = new Array<Error>()
		expect(() => unknownApplication(updateMe, 'decode wibbly wobble', null, triggerThrow)).toThrow()
		expect(updateMe).toHaveLength(0)
	})

	test('check - decode result, good value', () => {
		let id: number | null = 84
		const result = Object.assign({}, goodResult)
		id = check(id, 'decode wibbly wobble', 'id', -1, result, triggerThrow)
		expect(id).toBe(84)
		expect(result.errors).toBeUndefined()
	})

	test('check - decode result, null value', () => {
		let id: number | null = null
		const result = Object.assign({}, goodResult)
		expect(() => {
			id = check(id, 'decode wibbly wobble', 'id', -1, result, triggerThrow)
		}).toThrow()
		expect(id).toBe(null)
		expect(result.errors).toBeUndefined()
	})

	test('check - error array, good value', () => {
		let id: number | undefined = 84
		const result = new Array<Error>()
		id = check(id, 'decode wibbly wobble', 'id', -1, result, triggerThrow)
		expect(id).toBe(84)
		expect(result).toHaveLength(0)
	})

	test('check - error array, null value', () => {
		let id: number | undefined = undefined
		const result = new Array<Error>()
		expect(() => {
			id = check(id, 'decode wibbly wobble', 'id', -1, result, triggerThrow)
		}).toThrow()
		expect(id).toBe(undefined)
		expect(result).toHaveLength(0)
	})

	test('unexpected - decode result', () => {
		const updateMe = Object.assign({}, goodResult)
		expect(() => unexpected(updateMe, 'decode wibbly wobble', 'a message to you', 99, triggerThrow)).toThrow()
	})

	test('unexpected - error array', () => {
		const updateMe = new Array<Error>()
		expect(() => unexpected(updateMe, 'decode wibbly wobble', 'a message to you', 99, triggerThrow)).toThrow()
	})
})

================
File: src/encodings/ber/__tests__/EmberFunction.spec.ts
================
/* eslint-disable jest/expect-expect */
import * as Ber from '../../../Ber'
import { EmberFunction, EmberFunctionImpl } from '../../../model/EmberFunction'
import { encodeFunction } from '../encoder/EmberFunction'
import { decodeFunctionContent } from '../decoder/EmberFunction'
import { FunctionArgumentImpl } from '../../../model/FunctionArgument'
import { ParameterType } from '../../../model/Parameter'
import { guarded } from '../decoder/DecodeResult'

describe('encodings/ber/EmberFunction', () => {
	describe('roundtrips', () => {
		function testFunction(fn: EmberFunction): void {
			const writer = new Ber.Writer()
			encodeFunction(fn, writer)
			console.log(writer.buffer)
			const reader = new Ber.Reader(writer.buffer)
			const decoded = guarded(decodeFunctionContent(reader))

			expect(decoded).toEqual(fn)
		}

		test('identifier', () => {
			const fn = new EmberFunctionImpl('identifier')
			testFunction(fn)
		})

		test('description', () => {
			const fn = new EmberFunctionImpl()
			fn.description = 'Description of many words'
			testFunction(fn)
		})

		test('args', () => {
			const fn = new EmberFunctionImpl('identifier')
			fn.args = [new FunctionArgumentImpl(ParameterType.Integer, 'Arg')]
			testFunction(fn)
		})

		test('result', () => {
			const fn = new EmberFunctionImpl('identifier')
			fn.result = [new FunctionArgumentImpl(ParameterType.Integer, 'Result')]
			testFunction(fn)
		})

		test('templateReference', () => {
			const fn = new EmberFunctionImpl('identifier')
			fn.templateReference = '1.2.3'
			testFunction(fn)
		})
	})
})

================
File: src/encodings/ber/__tests__/EmberNode.spec.ts
================
import * as Ber from '../../../Ber'
import { EmberNode } from '../../../model/EmberNode'
import { encodeNode } from '../encoder/EmberNode'
import { decodeNode } from '../decoder/EmberNode'
import { ElementType } from '../../../model/EmberElement'
import { literal } from '../../../types/types'
import { guarded } from '../decoder/DecodeResult'
import { berDecode } from '../'
import { decodeGenericElement } from '../decoder/Tree'

const indefiniteLength = Buffer.from([
	0x60,
	0x80, // Root - length 60
	0x6b,
	0x80, // RootElements -- length 56
	0xa0,
	0x80, // First element - 52
	0x6a,
	0x80, // Qualified Node - length 48
	0xa0,
	0x03,
	0x0d,
	0x01,
	0x01,
	0xa2,
	0x80, // Children length 39
	0x64,
	0x80, // ElementCollection length 35
	0xa0,
	0x80, // Element length 31
	0x63,
	0x80, // Node length 27
	0xa0,
	0x03,
	0x02,
	0x01,
	0x01,
	0xa1,
	0x80, // Node Content length 20
	0x31,
	0x80, // set length 16 - Ber library measures 18
	0xa0,
	0x09,
	0x0c,
	0x07,
	0x53,
	0x6f,
	0x75,
	0x72,
	0x63,
	0x65,
	0x73,
	0xa3,
	0x03,
	0x01,
	0x01,
	0xff,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
])

const nodeOnly = Buffer.from([
	0x63,
	0x80, // Node length 27
	0xa0,
	0x03,
	0x02,
	0x01,
	0x01,
	0xa1,
	0x80, // Node Content length 20
	0x31,
	0x80, // set length 16 - Ber library measures 18
	0xa0,
	0x09,
	0x0c,
	0x07,
	0x53,
	0x6f,
	0x75,
	0x72,
	0x63,
	0x65,
	0x73,
	0xa3,
	0x03,
	0x01,
	0x01,
	0xff,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
])

describe('encodings/ber/EmberNode', () => {
	const en = literal<EmberNode>({
		type: ElementType.Node,
		identifier: 'Nodey',
		description: 'Call me nodey',
		isRoot: false,
		isOnline: true,
		schemaIdentifiers: `I'm a schema identifier\nand I'm OK`,
		templateReference: '3.2.1.2',
	})

	test('write and read a node', () => {
		const writer = new Ber.Writer()
		encodeNode(en, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeNode(reader))

		expect(decoded).toEqual(en)
	})

	test('decode indefinite length', () => {
		const decoded = berDecode(indefiniteLength)

		console.log(decoded.value)
		expect(decoded.errors).toHaveLength(0)
	})

	test('decode indefinite node only', () => {
		const reader = new Ber.Reader(nodeOnly)
		const decoded = decodeGenericElement(reader)
		console.log(decoded.value)
		expect(decoded.errors).toHaveLength(0)
	})
})

================
File: src/encodings/ber/__tests__/FunctionArgument.spec.ts
================
import * as Ber from '../../../Ber'
import { FunctionArgument } from '../../../model/FunctionArgument'
import { encodeFunctionArgument } from '../encoder/FunctionArgument'
import { decodeFunctionArgument } from '../decoder/FunctionArgument'
import { ParameterType } from '../../../model/Parameter'
import { literal } from '../../../types/types'
import { guarded } from '../decoder/DecodeResult'

describe('encoders/ber/FunctionArgument', () => {
	const fa = literal<FunctionArgument>({
		type: ParameterType.String,
		name: 'fred',
	})

	test('write and read function argument', () => {
		const writer = new Ber.Writer()
		encodeFunctionArgument(fa, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeFunctionArgument(reader))

		expect(decoded).toEqual(fa)
	})

	test('write and read function argument - boolean', () => {
		const noName = literal<FunctionArgument>({
			type: ParameterType.Boolean,
		})
		const writer = new Ber.Writer()
		encodeFunctionArgument(noName, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeFunctionArgument(reader))

		expect(decoded).toEqual(noName)
	})
})

================
File: src/encodings/ber/__tests__/index.spec.ts
================
/* eslint-disable jest/expect-expect */
import { InvocationResultImpl } from '../../../model/InvocationResult'
import { ParameterType } from '../../../model/Parameter'
import { Root, RootType, RootElement, Collection } from '../../../types/types'
import { berEncode, berDecode } from '..'
import { QualifiedElementImpl, NumberedTreeNodeImpl } from '../../../model/Tree'
import { EmberNodeImpl } from '../../../model/EmberNode'
import { guarded } from '../decoder/DecodeResult'
import * as Ber from '../../../Ber'
import { ElementType } from '../../../model/EmberElement'
import { RootBERID } from '../constants'

describe('encoders/Ber/index', () => {
	function roundTrip(res: Root, type: RootType): void {
		const encoded = berEncode(res, type)
		const decoded = guarded(berDecode(encoded))

		expect(decoded).toEqual(res)
	}
	test('InvocationResult', () => {
		const res = new InvocationResultImpl(64, true, [{ value: 6, type: ParameterType.Integer }])

		roundTrip(res, RootType.InvocationResult)
	})
	test('Qualified node', () => {
		const res = { 0: new QualifiedElementImpl('2.3.1', new EmberNodeImpl('Test node')) }
		roundTrip(res, RootType.Elements)
	})
	test('Numbered node', () => {
		const res = { 0: new NumberedTreeNodeImpl(0, new EmberNodeImpl('Test node')) }
		roundTrip(res, RootType.Elements)
	})
	test('Numbered tree', () => {
		const res = {
			0: new NumberedTreeNodeImpl(0, new EmberNodeImpl('Test node'), {
				0: new NumberedTreeNodeImpl(0, new EmberNodeImpl('Test node 1')),
			}),
		}
		if (!res[0].children) {
			throw new Error(`Tree must have children`)
		}
		res[0].children[0].parent = res[0]
		roundTrip(res, RootType.Elements)
	})
	test('Qualified tree', () => {
		const res = {
			0: new QualifiedElementImpl('2.3.1', new EmberNodeImpl('Test node'), {
				0: new NumberedTreeNodeImpl(0, new EmberNodeImpl('Node A'), {}),
			}),
		}
		if (!res[0].children) {
			throw new Error(`Tree must have children`)
		}
		res[0].children[0].parent = res[0]
		roundTrip(res, RootType.Elements)
	})
	test('Unknown root', () => {
		const testBuffer = Buffer.from([Ber.APPLICATION(30)])
		const decoded = berDecode(testBuffer)

		expect(decoded.value).toHaveLength(1)
		expect((decoded.value as Collection<RootElement>)[0].contents.type).toBe(ElementType.Node)
		expect(decoded.errors).toHaveLength(1)
		expect(decoded.errors?.toString()).toMatch(/Unexpected BER application tag '126'/)
	})
	test('Unknown root elements', () => {
		const testBuffer = Buffer.from([RootBERID, 1, Ber.APPLICATION(31)])
		const decoded = berDecode(testBuffer)

		expect(decoded.value).toHaveLength(1)
		expect((decoded.value as Collection<RootElement>)[0].contents.type).toBe(ElementType.Node)
		expect(decoded.errors).toHaveLength(1)
		expect(decoded.errors?.toString()).toMatch(/Unexpected BER application tag '127'/)
	})
})

================
File: src/encodings/ber/__tests__/Invocation.spec.ts
================
import * as Ber from '../../../Ber'
import { Invocation } from '../../../model/Invocation'
import { encodeInvocation } from '../encoder/Invocation'
import { decodeInvocation } from '../decoder/Invocation'
import { ParameterType } from '../../../model/Parameter'
import { literal } from '../../../types/types'
import { guarded } from '../decoder/DecodeResult'

describe('encodings/ber/Invocation', () => {
	const iv = literal<Invocation>({
		id: 45654,
		args: [
			{ type: ParameterType.Integer, value: -1 },
			{ type: ParameterType.Boolean, value: false },
			{ type: ParameterType.String, value: 'twotyfour' },
		],
	})

	const noArgs = literal<Invocation>({
		id: 234,
		args: [],
	})

	const noId = literal<Invocation>({
		args: [{ type: ParameterType.Integer, value: 47 }],
	})

	test('write and read an invocation - 3 args', () => {
		const writer = new Ber.Writer()
		encodeInvocation(iv, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeInvocation(reader))

		expect(decoded).toEqual(iv)
	})

	test('write and read an invocation - no arguments', () => {
		const writer = new Ber.Writer()
		encodeInvocation(noArgs, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeInvocation(reader))

		expect(decoded).toEqual(noArgs)
	})

	test('write and read an invocation - no identifier', () => {
		const writer = new Ber.Writer()
		encodeInvocation(noId, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeInvocation(reader))

		expect(decoded).toEqual(noId)
	})
})

================
File: src/encodings/ber/__tests__/InvocationResult.spec.ts
================
import * as Ber from '../../../Ber'
import { InvocationResult } from '../../../model/InvocationResult'
import { encodeInvocationResult } from '../encoder/InvocationResult'
import { decodeInvocationResult } from '../decoder/InvocationResult'
import { ParameterType } from '../../../model/Parameter'
import { literal } from '../../../types/types'
import { guarded } from '../decoder/DecodeResult'

describe('encodings/ber/InvocationResult', () => {
	const ir = literal<InvocationResult>({
		id: 42,
		success: true,
		result: [
			{ type: ParameterType.String, value: 'fortytwo' },
			{ type: ParameterType.Real, value: 42.1 },
		],
	})

	const voidRes = literal<InvocationResult>({
		id: 987654,
		success: true,
	})

	test('write and read invocation result', () => {
		const writer = new Ber.Writer()
		encodeInvocationResult(ir, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeInvocationResult(reader))

		expect(decoded).toEqual(ir)
	})

	test('write and read invocation result - void return', () => {
		const writer = new Ber.Writer()
		encodeInvocationResult(voidRes, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeInvocationResult(reader))

		expect(decoded).toEqual(voidRes)
	})

	// Note: Using an empty array result is encoded the same as no array
	test('write and read invocation result - empty result', () => {
		const writer = new Ber.Writer()
		encodeInvocationResult({ id: voidRes.id, success: true, result: [] }, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeInvocationResult(reader))

		expect(decoded).toEqual(voidRes)
	})
})

================
File: src/encodings/ber/__tests__/Label.spec.ts
================
import * as Ber from '../../../Ber'
import { Label } from '../../../model/Label'
import { encodeLabel } from '../encoder/Label'
import { decodeLabel } from '../decoder/Label'
import { literal } from '../../../types/types'
import { guarded } from '../decoder/DecodeResult'

describe('encodings/ber/Label', () => {
	const lbl = literal<Label>({
		basePath: '1.1.2.1.3',
		description: 'Oh what a lovely button',
	})

	test('write and read a label', () => {
		const writer = new Ber.Writer()
		encodeLabel(lbl, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeLabel(reader))

		expect(decoded).toEqual(lbl)
	})

	test('write and read a label without description', () => {
		const writer = new Ber.Writer()
		const badLabel = { basePath: '5.4.3.2.1', description: '' } as Label
		encodeLabel(badLabel, writer)
		const badBuffer = writer.buffer.slice(0, writer.buffer.length - 4)
		badBuffer[1] = badBuffer[1] - 4
		const reader = new Ber.Reader(badBuffer)
		const decoded = decodeLabel(reader)

		expect(decoded.value).toEqual(badLabel)
		expect(decoded.errors).toHaveLength(1)
	})

	test('write and read a label with unknown context', () => {
		const writer = new Ber.Writer()
		encodeLabel(lbl, writer)
		writer.buffer[11] = Ber.CONTEXT(13)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = decodeLabel(reader)

		expect(decoded.value).toEqual(literal<Label>({ basePath: lbl.basePath, description: '' }))
		expect(decoded.errors).toHaveLength(2)
	})
})

================
File: src/encodings/ber/__tests__/Matrix.spec.ts
================
/* eslint-disable jest/expect-expect */
import * as Ber from '../../../Ber'
import { NumberedTreeNode, QualifiedElement, QualifiedElementImpl, NumberedTreeNodeImpl } from '../../../model/Tree'
import { Matrix, MatrixImpl, MatrixType, MatrixAddressingMode } from '../../../model/Matrix'
import { encodeNumberedElement } from '../encoder/Tree'
import { encodeQualifedElement } from '../encoder/Qualified'
import { decodeMatrix } from '../decoder/Matrix'
import { ConnectionOperation, ConnectionDisposition } from '../../../model/Connection'
import { guarded } from '../decoder/DecodeResult'

describe('encodings/ber/Matrix', () => {
	function roundtripMatrix(matrix: Matrix, qualified = false): void {
		const node = qualified ? new QualifiedElementImpl('1.2.3', matrix) : new NumberedTreeNodeImpl(0, matrix)
		const writer = new Ber.Writer()
		if (!qualified) encodeNumberedElement(node as NumberedTreeNode<Matrix>, writer)
		else encodeQualifedElement(node as QualifiedElement<Matrix>, writer)
		console.log(writer.buffer)
		expect(writer.buffer.length).toBeGreaterThan(0)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeMatrix(reader, qualified))

		expect(decoded).toEqual(node)
	}

	function runRoundtripTests(qualified: boolean): void {
		test('identifier', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			roundtripMatrix(matrix, qualified)
		})
		test('targets', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.targets = [0, 1, 2, 3, 4]
			roundtripMatrix(matrix, qualified)
		})
		test('sources', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.sources = [0, 1, 2, 3, 4]
			roundtripMatrix(matrix, qualified)
		})
		test('connections', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.connections = {
				1: {
					target: 1,
				},
			}
			roundtripMatrix(matrix, qualified)
		})
		describe('connections', () => {
			test('sources', () => {
				const matrix: Matrix = new MatrixImpl('identifier')
				matrix.connections = {
					1: {
						target: 1,
						sources: [2, 3],
					},
				}
				roundtripMatrix(matrix, qualified)
			})
			test('operation', () => {
				const matrix: Matrix = new MatrixImpl('identifier')
				matrix.connections = {
					1: {
						target: 1,
						operation: ConnectionOperation.Absolute,
					},
				}
				roundtripMatrix(matrix, qualified)
				matrix.connections = {
					1: {
						target: 1,
						operation: ConnectionOperation.Connect,
					},
				}
				roundtripMatrix(matrix, qualified)
				matrix.connections = {
					1: {
						target: 1,
						operation: ConnectionOperation.Disconnect,
					},
				}
				roundtripMatrix(matrix, qualified)
			})
			test('disposition', () => {
				const matrix: Matrix = new MatrixImpl('identifier')
				matrix.connections = {
					1: {
						target: 1,
						disposition: ConnectionDisposition.Locked,
					},
				}
				roundtripMatrix(matrix, qualified)
				matrix.connections[1].disposition = ConnectionDisposition.Modified
				roundtripMatrix(matrix, qualified)
				matrix.connections[1].disposition = ConnectionDisposition.Pending
				roundtripMatrix(matrix, qualified)
				matrix.connections[1].disposition = ConnectionDisposition.Tally
				roundtripMatrix(matrix, qualified)
			})
		})
		test('description', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.description = 'Display Name'
			roundtripMatrix(matrix, qualified)
		})
		test('matrixType', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.matrixType = MatrixType.NToN
			roundtripMatrix(matrix, qualified)
			matrix.matrixType = MatrixType.OneToN
			roundtripMatrix(matrix, qualified)
			matrix.matrixType = MatrixType.OneToOne
			roundtripMatrix(matrix, qualified)
		})
		test('addressingMode', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.addressingMode = MatrixAddressingMode.Linear
			roundtripMatrix(matrix, qualified)
			matrix.addressingMode = MatrixAddressingMode.NonLinear
			roundtripMatrix(matrix, qualified)
		})
		test('targetCount', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.targetCount = 5
			roundtripMatrix(matrix, qualified)
		})
		test('sourceCount', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.sourceCount = 5
			roundtripMatrix(matrix, qualified)
		})
		test('maximumTotalConnects', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.maximumTotalConnects = 25
			roundtripMatrix(matrix, qualified)
		})
		test('maximumConnectsPerTarget', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.maximumConnectsPerTarget = 5
			roundtripMatrix(matrix, qualified)
		})
		test('parametersLocation', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.parametersLocation = '1.2.3'
			roundtripMatrix(matrix, qualified)
		})
		test('gainParameterNumber', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.gainParameterNumber = 3
			roundtripMatrix(matrix, qualified)
		})
		test('labels', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.labels = [{ basePath: '1.2.3', description: 'Descr' }]
			roundtripMatrix(matrix, qualified)
		})
		test('schemaIdentifiers', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.schemaIdentifiers = '1.2.3'
			roundtripMatrix(matrix, qualified)
		})
		test('templateReference', () => {
			const matrix: Matrix = new MatrixImpl('identifier')
			matrix.templateReference = '1.2.3'
			roundtripMatrix(matrix, qualified)
		})
	}

	describe('roundtrip numbered Matrix', () => {
		runRoundtripTests(false)
	})
	describe('roundtrip qualified Matrix', () => {
		runRoundtripTests(true)
	})
})

================
File: src/encodings/ber/__tests__/Parameter.spec.ts
================
/* eslint-disable jest/expect-expect */
import * as Ber from '../../../Ber'
import { Parameter, ParameterType, ParameterAccess } from '../../../model/Parameter'
import { encodeParameter } from '../encoder/Parameter'
import { decodeParameter } from '../decoder/Parameter'
import { ElementType } from '../../../model/EmberElement'
import { StreamFormat, StreamDescriptionImpl } from '../../../model/StreamDescription'
import { literal } from '../../../types/types'
import { guarded } from '../decoder/DecodeResult'

describe('encodings/ber/Parameter', () => {
	const prm = literal<Parameter>({
		type: ElementType.Parameter,
		parameterType: ParameterType.String,
	})

	function roundtripParameter(prm: Parameter): void {
		const writer = new Ber.Writer()
		encodeParameter(prm, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeParameter(reader))

		expect(decoded).toEqual(prm)
	}

	test('write and read a parameter', () => {
		roundtripParameter(prm)
	})

	test('write and read a parameter - identifer', () => {
		const param: Parameter = {
			...prm,
			identifier: 'Angela',
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - description', () => {
		const param: Parameter = {
			...prm,
			description: 'This parameter is\nsupposed to be a good boy',
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - value', () => {
		const param: Parameter = {
			...prm,
			value: 'Oscar',
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - maximum', () => {
		const param: Parameter = {
			...prm,
			parameterType: ParameterType.Integer,
			maximum: 150,
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - minimum', () => {
		const param: Parameter = {
			...prm,
			parameterType: ParameterType.Integer,
			minimum: -22,
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - access', () => {
		const param: Parameter = {
			...prm,
			access: ParameterAccess.ReadWrite,
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - format', () => {
		const param: Parameter = {
			...prm,
			format: '2i%50%F20',
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - enumeration', () => {
		const param: Parameter = {
			...prm,
			parameterType: ParameterType.Enum,
			enumeration: '1\n2\n3\n4\n5\n',
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - factor', () => {
		const param: Parameter = {
			...prm,
			factor: 512,
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - isOnline', () => {
		const param: Parameter = {
			...prm,
			isOnline: false,
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - formula', () => {
		const param: Parameter = {
			...prm,
			formula: '1\n1',
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - defaultValue', () => {
		const param: Parameter = {
			...prm,
			defaultValue: 'Michael',
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - streamIdentifier', () => {
		const param: Parameter = {
			...prm,
			streamIdentifier: 33,
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - enumMap', () => {
		const param: Parameter = {
			...prm,
			parameterType: ParameterType.Enum,
			enumMap: new Map([
				['Jim', 0],
				['Pam', 1],
			]),
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - streamDescriptor', () => {
		const param: Parameter = {
			...prm,
			streamDescriptor: { format: StreamFormat.UInt8, offset: 22 },
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - schemaIdentifiers', () => {
		const param: Parameter = {
			...prm,
			schemaIdentifiers: '3.2.1.1',
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - templateReference', () => {
		const param: Parameter = {
			...prm,
			templateReference: '3.2.1.1',
		}

		roundtripParameter(param)
	})

	test('write and read a parameter - all', () => {
		const param: Parameter = {
			...prm,
			parameterType: ParameterType.Enum,
			identifier: 'Angela',
			description: 'This parameter is\nsupposed to be a good boy',
			value: 24,
			maximum: 150,
			minimum: -22,
			access: ParameterAccess.ReadWrite,
			format: '2i%50%F20',
			enumeration: '1\n2\n3\n4\n5\n',
			factor: 512,
			isOnline: false,
			formula: '1\n1',
			defaultValue: 0,
			streamIdentifier: 33,
			enumMap: new Map([
				['Jim', 0],
				['Pam', 1],
			]),
			streamDescriptor: new StreamDescriptionImpl(StreamFormat.UInt8, 22),
			schemaIdentifiers: '3.2.1.1',
			templateReference: '3.2.1.1',
		}

		roundtripParameter(param)
	})
})

================
File: src/encodings/ber/__tests__/StreamDescription.spec.ts
================
import * as Ber from '../../../Ber'
import { StreamDescription, StreamFormat } from '../../../model/StreamDescription'
import { encodeStreamDescription } from '../encoder/StreamDescription'
import { decodeStreamDescription } from '../decoder/StreamDescription'
import { literal } from '../../../types/types'
import { guarded } from '../decoder/DecodeResult'

describe('encodings/ber/StreamDescription', () => {
	const sd = literal<StreamDescription>({
		format: StreamFormat.Int32BE,
		offset: 42,
	})

	test('write and read stream description', () => {
		const writer = new Ber.Writer()
		encodeStreamDescription(sd, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeStreamDescription(reader))

		expect(decoded).toEqual(sd)
	})
})

================
File: src/encodings/ber/__tests__/StreamEntry.spec.ts
================
import * as Ber from '../../../Ber'
import { StreamEntry } from '../../../model/StreamEntry'
import { encodeStreamEntry } from '../encoder/StreamEntry'
import { decodeStreamEntry } from '../decoder/StreamEntry'
import { ParameterType } from '../../../model/Parameter'
import { literal } from '../../../types/types'
import { guarded } from '../decoder/DecodeResult'

describe('encodings/ber/StreamEntry', () => {
	test('write and read stream entry - integer', () => {
		const se = literal<StreamEntry>({
			identifier: 42,
			value: { type: ParameterType.Integer, value: 42 },
		})

		const writer = new Ber.Writer()
		encodeStreamEntry(se, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeStreamEntry(reader))

		expect(decoded).toEqual(se)
	})

	test('write and read stream entry - real', () => {
		const se = literal<StreamEntry>({
			identifier: 43,
			value: { type: ParameterType.Real, value: 42.3 },
		})

		const writer = new Ber.Writer()
		encodeStreamEntry(se, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeStreamEntry(reader))

		expect(decoded).toEqual(se)
	})

	test('write and read stream entry - string', () => {
		const se = literal<StreamEntry>({
			identifier: 42,
			value: { type: ParameterType.String, value: 'roundtrip stream entry' },
		})

		const writer = new Ber.Writer()
		encodeStreamEntry(se, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeStreamEntry(reader))

		expect(decoded).toEqual(se)
	})

	test('write and read stream entry - false', () => {
		const se = literal<StreamEntry>({
			identifier: 42,
			value: { type: ParameterType.Boolean, value: false },
		})

		const writer = new Ber.Writer()
		encodeStreamEntry(se, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeStreamEntry(reader))

		expect(decoded).toEqual(se)
	})

	test('write and read stream entry - true', () => {
		const se = literal<StreamEntry>({
			identifier: 42,
			value: { type: ParameterType.Boolean, value: true },
		})

		const writer = new Ber.Writer()
		encodeStreamEntry(se, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeStreamEntry(reader))

		expect(decoded).toEqual(se)
	})

	test('write and read stream entry - octets', () => {
		const se = literal<StreamEntry>({
			identifier: 42,
			value: { type: ParameterType.Octets, value: Buffer.from('roundtrip a buffer') },
		})

		const writer = new Ber.Writer()
		encodeStreamEntry(se, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeStreamEntry(reader))

		expect(decoded).toEqual(se)
	})

	test('write and read stream entry - empty buffer', () => {
		const se = literal<StreamEntry>({
			identifier: 42,
			value: { type: ParameterType.Octets, value: Buffer.alloc(0) },
		})

		const writer = new Ber.Writer()
		encodeStreamEntry(se, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeStreamEntry(reader))

		expect(decoded).toEqual(se)
	})

	test('write and read stream entry - null', () => {
		const se = literal<StreamEntry>({
			identifier: 42,
			value: { type: ParameterType.Null, value: null },
		})

		const writer = new Ber.Writer()
		encodeStreamEntry(se, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeStreamEntry(reader))

		expect(decoded).toEqual(se)
	})
})

================
File: src/encodings/ber/__tests__/StringIntegerCollection.spec.ts
================
import * as Ber from '../../../Ber'
import { StringIntegerCollection } from '../../../types/types'
import { encodeStringIntegerCollection } from '../encoder/StringIntegerCollection'
import { decodeStringIntegerCollection } from '../decoder/StringIntegerCollection'
import { guarded } from '../decoder/DecodeResult'

describe('encodings/ber/StringIntegerCollection', () => {
	const sic: StringIntegerCollection = new Map<string, number>([
		['first', 1],
		['second', 2],
		['third', 3],
	])

	test('write and read string integer collection - 3 values', () => {
		const writer = new Ber.Writer()
		encodeStringIntegerCollection(sic, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeStringIntegerCollection(reader))

		expect(decoded).toEqual(sic)
	})

	test('write and read string integer collection - empty', () => {
		const emptySic = new Map<string, number>()

		const writer = new Ber.Writer()
		encodeStringIntegerCollection(emptySic, writer)
		console.log(writer.buffer)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeStringIntegerCollection(reader))

		expect(decoded).toEqual(emptySic)
	})
})

================
File: src/encodings/ber/__tests__/Template.spec.ts
================
/* eslint-disable jest/expect-expect */
import * as Ber from '../../../Ber'
import { Template, TemplateImpl } from '../../../model/Template'
import { decodeTemplate } from '../decoder/Template'
import {
	NumberedTreeNodeImpl,
	TreeElement,
	NumberedTreeNode,
	QualifiedElement,
	QualifiedElementImpl,
} from '../../../model/Tree'
import { EmberNodeImpl } from '../../../model/EmberNode'
import { encodeNumberedElement } from '../encoder/Tree'
import { encodeQualifedElement } from '../encoder/Qualified'
import { guarded } from '../decoder/DecodeResult'

describe('encodings/ber/Template', () => {
	function roundtripTemplate(tmpl: TreeElement<Template>, qualified = false): void {
		const writer = new Ber.Writer()
		if (!qualified) encodeNumberedElement(tmpl as NumberedTreeNode<Template>, writer)
		else encodeQualifedElement(tmpl as QualifiedElement<Template>, writer)
		console.log(writer.buffer)
		expect(writer.buffer.length).toBeGreaterThan(0)
		const reader = new Ber.Reader(writer.buffer)
		const decoded = guarded(decodeTemplate(reader, qualified))

		expect(decoded).toEqual(tmpl)
	}

	function runRoundtripTests(qualified: boolean): void {
		test('description', () => {
			const template: Template = new TemplateImpl(undefined, 'Description')
			const node: TreeElement<Template> = qualified
				? new QualifiedElementImpl('1.2.3', template)
				: new NumberedTreeNodeImpl(0, template)
			roundtripTemplate(node, qualified)
		})

		test('element', () => {
			const template: Template = new TemplateImpl(new NumberedTreeNodeImpl(0, new EmberNodeImpl('TestNode')))
			const node: TreeElement<Template> = qualified
				? new QualifiedElementImpl('1.2.3', template)
				: new NumberedTreeNodeImpl(0, template)
			roundtripTemplate(node, qualified)
		})
	}

	describe('roundtrip numbered template', () => {
		runRoundtripTests(false)
	})
	describe('roundtrip qualified template', () => {
		runRoundtripTests(true)
	})
})

================
File: src/encodings/ber/decoder/Command.ts
================
import * as Ber from '../../../Ber'
import {
	Command,
	CommandType,
	FieldFlags,
	SubscribeImpl,
	UnsubscribeImpl,
	GetDirectoryImpl,
	InvokeImpl,
} from '../../../model/Command'
import { Invocation } from '../../../model/Invocation'
import { decodeInvocation } from './Invocation'
import { CommandBERID } from '../constants'
import {
	DecodeOptions,
	defaultDecode,
	DecodeResult,
	unknownContext,
	check,
	makeResult,
	appendErrors,
	unexpected,
	skipNext,
} from './DecodeResult'

export { decodeCommand }

function readDirFieldMask(reader: Ber.Reader): FieldFlags | undefined {
	const intToMask: { [flag: number]: FieldFlags } = {
		[-2]: FieldFlags.Sparse,
		[-1]: FieldFlags.All,
		[0]: FieldFlags.Default,
		[1]: FieldFlags.Identifier,
		[2]: FieldFlags.Description,
		[3]: FieldFlags.Tree,
		[4]: FieldFlags.Value,
		[5]: FieldFlags.Connections,
	}

	return intToMask[reader.readInt()]
}

function decodeCommand(reader: Ber.Reader, options: DecodeOptions = defaultDecode): DecodeResult<Command> {
	reader.readSequence(CommandBERID)
	let type: CommandType | null = null
	let dirFieldMask: FieldFlags | undefined = undefined
	let invocation: Invocation | undefined = undefined
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				type = reader.readInt()
				break
			case Ber.CONTEXT(1):
				dirFieldMask = readDirFieldMask(reader)
				if (!dirFieldMask) {
					errors.push(new Error(`decode command: encounted unknown dir field mask`))
				}
				break
			case Ber.CONTEXT(2):
				invocation = appendErrors(decodeInvocation(reader, options), errors)
				break
			case 0:
				break // Indefinite lengths
			default:
				unknownContext(errors, 'decode command', tag, options)
				skipNext(reader)
				break
		}
	}
	type = check(type, 'decode command', 'type', CommandType.Subscribe, errors, options)
	switch (type) {
		case CommandType.Subscribe:
			return makeResult(new SubscribeImpl(), errors)
		case CommandType.Unsubscribe:
			return makeResult(new UnsubscribeImpl(), errors)
		case CommandType.GetDirectory:
			return makeResult(new GetDirectoryImpl(dirFieldMask), errors)
		case CommandType.Invoke:
			return makeResult(new InvokeImpl(invocation), errors)
		default:
			return unexpected(
				errors,
				'decode command',
				`command type '${type}' is not recognized`,
				new SubscribeImpl(),
				options
			)
	}
}

================
File: src/encodings/ber/decoder/Connection.ts
================
import * as Ber from '../../../Ber'
import { Connection, ConnectionOperation, ConnectionDisposition, ConnectionImpl } from '../../../model/Connection'
import { ConnectionBERID } from '../constants'
import {
	DecodeOptions,
	defaultDecode,
	DecodeResult,
	unknownContext,
	check,
	makeResult,
	unexpected,
	appendErrors,
	skipNext,
} from './DecodeResult'

export { decodeConnection }

function decodeConnection(reader: Ber.Reader, options: DecodeOptions = defaultDecode): DecodeResult<Connection> {
	reader.readSequence(ConnectionBERID)
	let target: number | null = null
	let sources: Array<number> | undefined = undefined
	let operation: ConnectionOperation | undefined = undefined
	let disposition: ConnectionDisposition | undefined = undefined
	let encodedSources: string
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				target = reader.readInt()
				break
			case Ber.CONTEXT(1):
				encodedSources = reader.readRelativeOID(Ber.BERDataTypes.RELATIVE_OID)
				if (encodedSources.length === 0) {
					sources = []
				} else {
					sources = encodedSources.split('.').map((i) => Number(i))
				}
				break
			case Ber.CONTEXT(2):
				operation = appendErrors(readConnectionOperation(reader.readInt(), options), errors)
				break
			case Ber.CONTEXT(3):
				disposition = appendErrors(readConnectionDisposition(reader.readInt(), options), errors)
				break
			case 0:
				break // Indefinite lengths
			default:
				unknownContext(errors, 'decode connection', tag, options)
				skipNext(reader)
				break
		}
	}
	target = check(target, 'deocde connection', 'target', -1, errors, options)
	return makeResult(new ConnectionImpl(target, sources, operation, disposition), errors)
}

function readConnectionOperation(
	value: number,
	options: DecodeOptions = defaultDecode
): DecodeResult<ConnectionOperation> {
	switch (value) {
		case 0:
			return makeResult(ConnectionOperation.Absolute)
		case 1:
			return makeResult(ConnectionOperation.Connect)
		case 2:
			return makeResult(ConnectionOperation.Disconnect)
		default:
			return unexpected(
				[],
				'read connection options',
				`unexpected connection operation '${value}'`,
				ConnectionOperation.Absolute,
				options
			)
	}
}

function readConnectionDisposition(
	value: number,
	options: DecodeOptions = defaultDecode
): DecodeResult<ConnectionDisposition> {
	switch (value) {
		case 0:
			return makeResult(ConnectionDisposition.Tally)
		case 1:
			return makeResult(ConnectionDisposition.Modified)
		case 2:
			return makeResult(ConnectionDisposition.Pending)
		case 3:
			return makeResult(ConnectionDisposition.Locked)
		default:
			return unexpected(
				[],
				'read connection options',
				`unexpected connection operation '${value}'`,
				ConnectionDisposition.Tally,
				options
			)
	}
}

================
File: src/encodings/ber/decoder/DecodeResult.ts
================
import { literal } from '../../../types/types'
import * as Ber from '../../../Ber'

export {
	DecodeOptions,
	defaultDecode,
	DecodeResult,
	whatever,
	check,
	DecodeError,
	makeResult,
	unknownContext,
	unknownApplication,
	safeSet,
	guarded,
	appendErrors,
	unexpected,
	skipNext,
}

/**
 * Control what cuases an exception during decoding.
 */
interface DecodeOptions {
	/** Skip unknown application tags, used to identify objects. */
	skipApplicationTags: boolean
	/** Skip unknown context tags, used to identify the properties of objects. */
	skipContextTags: boolean
	/** Substitute a default value when a required value is missing. */
	substituteForRequired: boolean
	/** Skip past unexpected enumeration values. */
	skipUnexpected: boolean
}

/**
 * Default decoding values. Prevents throwing exceptions while decoding.
 */
const defaultDecode = literal<DecodeOptions>({
	skipApplicationTags: true,
	skipContextTags: true,
	substituteForRequired: true,
	skipUnexpected: true,
})

/**
 * Decoders are forgiving and return both a candidate value and a list of
 * errors found in the source data.
 */
interface DecodeResult<T> {
	/** Candicate decoded value. */
	value: T
	/** List of errors, if any, found during decoding. */
	errors?: Array<Error>
}

/**
 * Return the decoded result whatever errors are reported.
 * @param decres Result of decoding.
 * @returns Candidate result of decoding, ignoring any errors.
 * @
 */
function whatever<T>(decres: DecodeResult<T>): T {
	return decres.value
}

/**
 * Compound error containing details of all problems encountered when
 * decoding an EmberPlus BER stream.
 */
class DecodeError extends Error {
	/** Details of each error enountered during encoding. */
	public readonly sub: Array<Error>
	/**
	 * Create an error with details of decoding issues.
	 * @param errors List of decoding sub-errors.
	 */
	constructor(errors: Array<Error>) {
		super(`Decoding failed. Errors are:\n${errors.join('\n')}`)
		this.sub = errors
	}
}

/**
 * Return the decoded result if no errors, otherwise throw a summary error.
 * @param decres Result of decoding.
 * @returns Candidate result of decoding, only if no errors.
 * @throws Summary when errors exists.
 */
function guarded<T>(decres: DecodeResult<T>): T {
	if (decres.errors && decres.errors.length > 0) {
		throw new DecodeError(decres.errors)
	}
	return decres.value
}

/**
 * Make a decoded result from an initial value with an empty list if errors.
 * @param t Value to embed in the initial result.
 */
function makeResult<T>(t: T, errors?: Array<Error>): DecodeResult<T> {
	return literal<DecodeResult<T>>({
		value: t,
		errors: Array.isArray(errors) ? errors : [],
	})
}

/**
 * Process a decoding problem when a context parameter tag is not recognized.
 * @param decres Decoding result to add the error to (if appropriate).
 * @param context Description of where the tag is.
 * @param tag Unrecognized tag.
 * @param options Control the processing of the error.
 */
function unknownContext<T>(
	decres: DecodeResult<T> | Array<Error>,
	context: string,
	tag: number | null,
	options: DecodeOptions = defaultDecode
): void {
	const err = new Error(`${context}: Unexpected BER context tag '${tag}'`)
	let errors = Array.isArray(decres) ? decres : decres.errors
	if (options.skipContextTags) {
		if (!errors) {
			errors = []
		}
		errors.push(err)
		if (!Array.isArray(decres)) {
			decres.errors = errors
		}
	} else {
		throw err
	}
}

/**
 * Process a decoding problem when an application tag is not recognized.
 * @param decres Decoding result to add the error to (if appropriate).
 * @param context Description of where the tag is.
 * @param tag Unrecognized tag.
 * @param options Control the processing of the error.
 */
function unknownApplication<T>(
	decres: DecodeResult<T> | Array<Error>,
	context: string,
	tag: number | null,
	options: DecodeOptions = defaultDecode
): void {
	const err = new Error(`${context}: Unexpected BER application tag '${tag}'`)
	let errors = Array.isArray(decres) ? decres : decres.errors
	if (options.skipApplicationTags) {
		if (!errors) {
			errors = []
		}
		errors.push(err)
		if (!Array.isArray(decres)) {
			decres.errors = errors
		}
	} else {
		throw err
	}
}

/**
 * Safely update a value from another decoding stage, merging errors.
 * @param result Result of a decoding stage.
 * @param update Value to be updated.
 * @param fn Function to use to update a value with the result.
 */
function safeSet<S, T>(result: DecodeResult<S>, update: DecodeResult<T>, fn: (s: S, t: T) => T): DecodeResult<T> {
	if (result.errors && result.errors.length > 0) {
		update.errors = update.errors ? update.errors.concat(result.errors) : result.errors
	}
	update.value = fn(result.value, update.value)
	return update
}

/**
 * Check a value and if it is _null_ or _undefined_ then follow the options
 * to either substitute a replacement truthy value, reporting an issue in the
 * errors list, or throw an error when `subsituteForRequired` is `false`.
 * @param value Value that may be somehow not defined.
 * @param context Description of where the value is.
 * @param propertyName Name of the property.
 * @param substitute Substitute value in the event that the value is missing.
 * @param decres A decoding result with an error list to be extended or a
 * stand alone error list.
 * @param options Control the processing of the check.
 * @returns Value or, if somehow not defined, the substitute.
 */
function check<T>(
	value: T | null | undefined,
	context: string,
	propertyName: string,
	substitute: T,
	decres: DecodeResult<T> | Array<Error>,
	options: DecodeOptions = defaultDecode
): T {
	if (value === null || value === undefined) {
		const errMsg = `${context}: For required property '${propertyName}', value is missing.`
		if (options.substituteForRequired) {
			let errors = Array.isArray(decres) ? decres : decres.errors
			if (!errors) {
				errors = []
			}
			errors.push(new Error(errMsg + ` Substituting '${substitute}'`))
			if (!Array.isArray(decres)) {
				decres.errors = errors
			}
			return substitute
		} else {
			throw new Error(errMsg)
		}
	}
	return value
}

/**
 * Extend an error list using any errors in the given source, returning the
 * source value.
 * @param source Decoding result to split apart.
 * @param decres Decoding result to extend the error list of or a stand alone
 * error list.
 * @returns The value embedded in the source.
 */
function appendErrors<T, U>(source: DecodeResult<T>, decres: DecodeResult<U> | Array<Error>): T {
	if (source.errors && source.errors.length > 0) {
		if (Array.isArray(decres)) {
			decres.push(...source.errors)
		} else {
			decres.errors = decres.errors ? decres.errors.concat(source.errors) : source.errors
		}
	}
	return source.value
}

/**
 * Handle an unexpected enumeration value, returning a substitute value or
 * throwing an errors depending on option `skipUnexpected`.
 * @param decres Decoding result to add the error to (if appropriate).
 * @param context Description of where the tag is.
 * @param message Description of the unexpected value.
 * @param substitute Value to substitute (if appropriate).
 * @param options Control the processing of the check.
 * @returns Decode result with the substitute value and an error.
 */
function unexpected<T>(
	decres: DecodeResult<T> | Array<Error>,
	context: string,
	message = '',
	substitute: T,
	options: DecodeOptions = defaultDecode
): DecodeResult<T> {
	let errors = Array.isArray(decres) ? decres : decres.errors
	const err = new Error(`${context}${message ? ': ' + message : ''}`)
	if (options.skipUnexpected) {
		if (!errors) {
			errors = []
		}
		errors.push(err)
		if (Array.isArray(decres)) {
			return makeResult(substitute, errors)
		} else {
			decres.errors = errors
			decres.value = substitute
			return decres
		}
	} else {
		throw err
	}
}

/**
 * Skip over a single value in the stream when it is not recognized.
 * @param reader Reader to skip over the next tag for.
 */
function skipNext(reader: Ber.Reader): void {
	const skipTag = reader.peek()
	if (skipTag) {
		reader.readString(skipTag, true)
	}
}

================
File: src/encodings/ber/decoder/EmberFunction.ts
================
import * as Ber from '../../../Ber'
// import { EmberFunction, EmberFunctionImpl } from '../../../model/EmberFunction'
import { EmberFunction, EmberFunctionImpl } from '../../../model/EmberFunction'
import { decodeFunctionArgument } from './FunctionArgument'
import {
	DecodeOptions,
	defaultDecode,
	DecodeResult,
	unknownContext,
	makeResult,
	appendErrors,
	skipNext,
} from './DecodeResult'
import { FunctionArgument } from '../../../model/FunctionArgument'
import { RelativeOID } from '../../../types/types'

export { decodeFunctionContent }

function decodeFunctionContent(
	reader: Ber.Reader,
	options: DecodeOptions = defaultDecode
): DecodeResult<EmberFunction> {
	reader.readSequence(Ber.BERDataTypes.SET)
	let identifier: string | undefined = undefined
	let description: string | undefined = undefined
	let args: Array<FunctionArgument> | undefined = undefined
	let result: Array<FunctionArgument> | undefined = undefined
	let templateReference: RelativeOID | undefined = undefined
	let seqOffset: number
	let resOffset: number
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				identifier = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(1):
				description = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(2):
				args = []
				reader.readSequence(Ber.BERDataTypes.SEQUENCE)
				seqOffset = reader.offset + reader.length
				while (reader.offset < seqOffset) {
					const argTag = reader.readSequence()
					if (argTag === 0) continue // indefinite length
					if (argTag !== Ber.CONTEXT(0)) {
						unknownContext(errors, 'decode function content: arguments', argTag, options)
						skipNext(reader)
						continue
					}
					const argEl = appendErrors(decodeFunctionArgument(reader, options), errors)
					args.push(argEl)
				}
				break
			case Ber.CONTEXT(3):
				result = []
				reader.readSequence(Ber.BERDataTypes.SEQUENCE)
				resOffset = reader.offset + reader.length
				while (reader.offset < resOffset) {
					const resTag = reader.readSequence()
					if (resTag === 0) continue // indefinite length
					if (resTag !== Ber.CONTEXT(0)) {
						unknownContext(errors, 'decode function content: result', resTag, options)
						skipNext(reader)
						continue
					}
					const resEl = appendErrors(decodeFunctionArgument(reader, options), errors)
					result.push(resEl)
				}
				break
			case Ber.CONTEXT(4):
				templateReference = reader.readRelativeOID(Ber.BERDataTypes.RELATIVE_OID)
				break
			case 0:
				break // Idefinite length
			default:
				unknownContext(errors, 'decode function content', tag, options)
				skipNext(reader)
				break
		}
	}

	return makeResult(new EmberFunctionImpl(identifier, description, args, result, templateReference), errors)
}

================
File: src/encodings/ber/decoder/EmberNode.ts
================
import * as Ber from '../../../Ber'
import { EmberNode, EmberNodeImpl } from '../../../model/EmberNode'
import { DecodeOptions, defaultDecode, DecodeResult, unknownContext, makeResult, skipNext } from './DecodeResult'
import { RelativeOID } from '../../../types/types'

export { decodeNode }

function decodeNode(reader: Ber.Reader, options: DecodeOptions = defaultDecode): DecodeResult<EmberNode> {
	reader.readSequence(Ber.BERDataTypes.SET)
	let identifier: string | undefined = undefined
	let description: string | undefined = undefined
	let isRoot: boolean | undefined = undefined
	let isOnline: boolean | undefined = undefined
	let schemaIdentifiers: string | undefined = undefined
	let templateReference: RelativeOID | undefined = undefined
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				identifier = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(1):
				description = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(2):
				isRoot = reader.readBoolean()
				break
			case Ber.CONTEXT(3):
				isOnline = reader.readBoolean()
				break
			case Ber.CONTEXT(4):
				schemaIdentifiers = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(5):
				templateReference = reader.readRelativeOID(Ber.BERDataTypes.RELATIVE_OID)
				break
			case 0:
				break // indefinite length
			default:
				unknownContext(errors, 'deocde node', tag, options)
				skipNext(reader)
				break
		}
	}
	return makeResult(
		new EmberNodeImpl(identifier, description, isRoot, isOnline, schemaIdentifiers, templateReference),
		errors
	)
}

================
File: src/encodings/ber/decoder/FunctionArgument.ts
================
import * as Ber from '../../../Ber'
import { FunctionArgument, FunctionArgumentImpl } from '../../../model/FunctionArgument'
import { ParameterType } from '../../../model/Parameter'
import { FunctionArgumentBERID } from '../constants'
import { readParameterType } from './Parameter'
import {
	DecodeOptions,
	defaultDecode,
	DecodeResult,
	makeResult,
	unknownContext,
	check,
	appendErrors,
	skipNext,
} from './DecodeResult'

export { decodeFunctionArgument }

function decodeFunctionArgument(
	reader: Ber.Reader,
	options: DecodeOptions = defaultDecode
): DecodeResult<FunctionArgument> {
	reader.readSequence(FunctionArgumentBERID)
	let type: ParameterType | null = null
	let name: string | undefined = undefined
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				type = appendErrors(readParameterType(reader.readInt(), options), errors)
				break
			case Ber.CONTEXT(1):
				name = reader.readString(Ber.BERDataTypes.STRING)
				break
			case 0:
				break // indefinite length
			default:
				unknownContext(errors, 'decode function context', tag, options)
				skipNext(reader)
				break
		}
	}
	type = check(type, 'decode function argument', 'type', ParameterType.Null, errors, options)
	return makeResult(new FunctionArgumentImpl(type, name), errors)
}

================
File: src/encodings/ber/decoder/Invocation.ts
================
import * as Ber from '../../../Ber'
import { Invocation, InvocationImpl } from '../../../model/Invocation'
import { EmberTypedValue } from '../../../types/types'
import { InvocationBERID } from '../constants'
import { DecodeOptions, defaultDecode, DecodeResult, unknownContext, makeResult, skipNext } from './DecodeResult'

export { decodeInvocation }

function decodeInvocation(reader: Ber.Reader, options: DecodeOptions = defaultDecode): DecodeResult<Invocation> {
	reader.readSequence(InvocationBERID)
	let id: number | undefined = undefined
	const args: Array<EmberTypedValue> = []
	let seqOffset: number
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				id = reader.readInt()
				break
			case Ber.CONTEXT(1):
				reader.readSequence(Ber.BERDataTypes.SEQUENCE)
				seqOffset = reader.offset + reader.length
				while (reader.offset < seqOffset) {
					const tag = reader.readSequence()
					if (tag === Ber.CONTEXT(0)) {
						args.push(reader.readValue())
					} else {
						unknownContext(errors, 'decode invocation arguments', tag, options)
						skipNext(reader)
					}
				}
				break
			case 0:
				break // indefinite length
			default:
				unknownContext(errors, 'decode invocation', tag, options)
				skipNext(reader)
				break
		}
	}
	return makeResult(new InvocationImpl(id, args), errors)
}

================
File: src/encodings/ber/decoder/InvocationResult.ts
================
import * as Ber from '../../../Ber'
import { InvocationResult, InvocationResultImpl } from '../../../model/InvocationResult'
import { EmberTypedValue } from '../../../types/types'
import { InvocationResultBERID } from '../constants'
import { DecodeOptions, defaultDecode, DecodeResult, makeResult, unknownContext, check, skipNext } from './DecodeResult'

export function decodeInvocationResult(
	reader: Ber.Reader,
	options: DecodeOptions = defaultDecode
): DecodeResult<InvocationResult> {
	reader.readSequence(InvocationResultBERID)
	let id: number | null = null
	let success: boolean | undefined = undefined
	let result: Array<EmberTypedValue> | undefined = undefined
	let seqOffset: number
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				id = reader.readInt()
				break
			case Ber.CONTEXT(1):
				success = reader.readBoolean()
				break
			case Ber.CONTEXT(2):
				result = []
				reader.readSequence(Ber.BERDataTypes.SEQUENCE)
				seqOffset = reader.offset + reader.length
				while (reader.offset < seqOffset) {
					const resTag = reader.readSequence()
					if (resTag === 0) continue
					if (resTag === null || resTag !== Ber.CONTEXT(0)) {
						unknownContext(errors, 'decode invocation result: result', resTag, options)
						skipNext(reader)
						continue
					}
					result.push(reader.readValue())
				}
				break
			case 0:
				break // indefinite length
			default:
				unknownContext(errors, 'decode invocation result', tag, options)
				skipNext(reader)
				break
		}
	}
	id = check(id, 'decode invocation result', 'id', -1, errors, options)
	return makeResult(new InvocationResultImpl(id, success, result), errors)
}

================
File: src/encodings/ber/decoder/Label.ts
================
import * as Ber from '../../../Ber'
import { Label, LabelImpl } from '../../../model/Label'
import { LabelBERID } from '../constants'
import { DecodeOptions, defaultDecode, DecodeResult, unknownContext, check, makeResult, skipNext } from './DecodeResult'

export { decodeLabel }

function decodeLabel(reader: Ber.Reader, options: DecodeOptions = defaultDecode): DecodeResult<Label> {
	reader.readSequence(LabelBERID)
	let basePath: string | null = null
	let description: string | null = null
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				basePath = reader.readRelativeOID(Ber.BERDataTypes.RELATIVE_OID)
				break
			case Ber.CONTEXT(1):
				description = reader.readString(Ber.BERDataTypes.STRING)
				break
			case 0:
				break // indefinite length
			default:
				unknownContext(errors, 'decode label', tag, options)
				skipNext(reader)
				break
		}
	}
	basePath = check(basePath, 'decode label', 'basePath', '', errors, options)
	description = check(description, 'decode label', 'description', '', errors, options)

	return makeResult(new LabelImpl(basePath, description), errors)
}

================
File: src/encodings/ber/decoder/Matrix.ts
================
import * as Ber from '../../../Ber'
import { Matrix, MatrixImpl, Connections, MatrixType, MatrixAddressingMode } from '../../../model/Matrix'
import { EmberTreeNode, RelativeOID, Collection } from '../../../types/types'
import { EmberElement } from '../../../model/EmberElement'
import { decodeChildren } from './Tree'
import { decodeConnection } from './Connection'
import { decodeLabel } from './Label'
import { MatrixBERID, QualifiedMatrixBERID, TargetBERID, SourceBERID } from '../constants'
import {
	QualifiedElementImpl,
	NumberedTreeNodeImpl,
	TreeElement,
	QualifiedElement,
	NumberedTreeNode,
} from '../../../model/Tree'
import {
	DecodeOptions,
	defaultDecode,
	DecodeResult,
	appendErrors,
	makeResult,
	unexpected,
	unknownContext,
	check,
	skipNext,
} from './DecodeResult'
import { Label } from '../../../model/Label'

export { decodeMatrix }

function decodeMatrix(
	reader: Ber.Reader,
	isQualified = false,
	options: DecodeOptions = defaultDecode
): DecodeResult<TreeElement<Matrix>> {
	reader.readSequence(isQualified ? QualifiedMatrixBERID : MatrixBERID)
	let number: number | null = null
	let path: RelativeOID | null = null
	let targets: Array<number> | undefined = undefined
	let sources: Array<number> | undefined = undefined
	let connections: Connections | undefined = undefined
	let contents: Matrix | null = null
	let kids: Collection<EmberTreeNode<EmberElement>> | undefined = undefined
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				if (isQualified) {
					path = reader.readRelativeOID()
				} else {
					number = reader.readInt()
				}
				break
			case Ber.CONTEXT(1):
				contents = appendErrors(decodeMatrixContents(reader, options), errors)
				break
			case Ber.CONTEXT(2):
				kids = appendErrors(decodeChildren(reader, options), errors)
				break
			case Ber.CONTEXT(3):
				targets = appendErrors(decodeTargets(reader, options), errors)
				break
			case Ber.CONTEXT(4):
				sources = appendErrors(decodeSources(reader, options), errors)
				break
			case Ber.CONTEXT(5):
				connections = appendErrors(decodeConnections(reader, options), errors)
				break
			case 0:
				break // indefinite length
			default:
				unknownContext(errors, 'decode matrix', tag, options)
				skipNext(reader)
				break
		}
	}
	contents = check(contents, 'decode matrix', 'contents', new MatrixImpl(''), errors, options)
	contents.targets = targets
	contents.sources = sources
	contents.connections = connections

	let el: QualifiedElement<Matrix> | NumberedTreeNode<Matrix>
	if (isQualified) {
		path = check(path, 'decode matrix', 'path', '', errors, options)
		el = new QualifiedElementImpl(path, contents, kids)
	} else {
		number = check(number, 'decode matrix', 'number', -1, errors, options)
		el = new NumberedTreeNodeImpl(number, contents, kids)
	}

	if (kids) {
		for (const kiddo of Object.values<EmberTreeNode<EmberElement>>(kids)) {
			kiddo.parent = el
		}
	}

	return makeResult(el, errors)
}

function decodeMatrixContents(reader: Ber.Reader, options: DecodeOptions = defaultDecode): DecodeResult<Matrix> {
	reader.readSequence(Ber.BERDataTypes.SET)
	let plTag: number | null
	let identifier: string | undefined = undefined
	let description: string | undefined = undefined
	let matrixType: MatrixType | undefined = undefined
	let addressingMode: MatrixAddressingMode | undefined = undefined
	let targetCount: number | undefined = undefined
	let sourceCount: number | undefined = undefined
	let maximumTotalConnects: number | undefined = undefined
	let maximumConnectsPerTarget: number | undefined = undefined
	let parametersLocation: string | number | undefined = undefined
	let gainParameterNumber: number | undefined = undefined
	let labels: Array<Label> | undefined = undefined
	let schemaIdentifiers: string | undefined = undefined
	let templateReference: string | undefined = undefined
	let seqOffset: number
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				identifier = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(1):
				description = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(2):
				matrixType = appendErrors(readMatrixType(reader.readInt(), options), errors)
				break
			case Ber.CONTEXT(3):
				addressingMode = appendErrors(readAddressingMode(reader.readInt(), options), errors)
				break
			case Ber.CONTEXT(4):
				targetCount = reader.readInt()
				break
			case Ber.CONTEXT(5):
				sourceCount = reader.readInt()
				break
			case Ber.CONTEXT(6):
				maximumTotalConnects = reader.readInt()
				break
			case Ber.CONTEXT(7):
				maximumConnectsPerTarget = reader.readInt()
				break
			case Ber.CONTEXT(8):
				plTag = reader.peek()
				if (plTag === Ber.BERDataTypes.RELATIVE_OID) {
					parametersLocation = reader.readRelativeOID(Ber.BERDataTypes.RELATIVE_OID)
				} else {
					parametersLocation = reader.readInt()
				}
				break
			case Ber.CONTEXT(9):
				gainParameterNumber = reader.readInt()
				break
			case Ber.CONTEXT(10):
				labels = []
				reader.readSequence(Ber.BERDataTypes.SEQUENCE)
				seqOffset = reader.offset + reader.length
				while (reader.offset < seqOffset) {
					reader.readSequence(Ber.CONTEXT(0))
					const lvVal = appendErrors(decodeLabel(reader, options), errors)
					labels.push(lvVal)
				}
				break
			case Ber.CONTEXT(11):
				schemaIdentifiers = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(12):
				templateReference = reader.readRelativeOID(Ber.BERDataTypes.RELATIVE_OID)
				break
			case 0:
				break // indefinite length
			default:
				unknownContext(errors, 'decode mattric contents', tag, options)
				skipNext(reader)
				break
		}
	}
	identifier = check(identifier, 'decode matrix contents', 'identifier', '', errors, options)
	return makeResult(
		new MatrixImpl(
			identifier,
			undefined, // targets
			undefined, // sources
			undefined, // connections
			description,
			matrixType,
			addressingMode,
			targetCount,
			sourceCount,
			maximumTotalConnects,
			maximumConnectsPerTarget,
			parametersLocation,
			gainParameterNumber,
			labels,
			schemaIdentifiers,
			templateReference
		),
		errors
	)
}

function decodeTargets(
	reader: Ber.Reader,
	_options: DecodeOptions = defaultDecode // eslint-disable-line @typescript-eslint/no-unused-vars
): DecodeResult<Array<number>> {
	const targets: Array<number> = []
	reader.readSequence(Ber.BERDataTypes.SEQUENCE)
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		reader.readSequence(Ber.CONTEXT(0))
		reader.readSequence(TargetBERID)
		reader.readSequence(Ber.CONTEXT(0))
		targets.push(reader.readInt())
	}
	return makeResult(targets)
}

function decodeSources(
	reader: Ber.Reader,
	_options: DecodeOptions = defaultDecode // eslint-disable-line @typescript-eslint/no-unused-vars
): DecodeResult<Array<number>> {
	const sources: Array<number> = []
	reader.readSequence(Ber.BERDataTypes.SEQUENCE)
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		reader.readSequence(Ber.CONTEXT(0))
		reader.readSequence(SourceBERID)
		reader.readSequence(Ber.CONTEXT(0))
		sources.push(reader.readInt())
	}
	return makeResult(sources)
}

function decodeConnections(reader: Ber.Reader, options: DecodeOptions = defaultDecode): DecodeResult<Connections> {
	const connections = makeResult<Connections>({})
	reader.readSequence(Ber.BERDataTypes.SEQUENCE)
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		if (tag === Ber.CONTEXT(0)) {
			const connection = appendErrors(decodeConnection(reader, options), connections)
			connections.value[connection.target] = connection
		} else {
			// unknownContext(errors, 'decode invocation arguments', tag, options)
			skipNext(reader)
		}
	}
	return connections
}

function readMatrixType(value: number, options: DecodeOptions = defaultDecode): DecodeResult<MatrixType> {
	switch (value) {
		case 0:
			return makeResult(MatrixType.OneToN)
		case 1:
			return makeResult(MatrixType.OneToOne)
		case 2:
			return makeResult(MatrixType.NToN)
		default:
			return unexpected([], 'read matrix type', `unexpected matrix type '${value}'`, MatrixType.NToN, options)
	}
}

function readAddressingMode(value: number, options: DecodeOptions = defaultDecode): DecodeResult<MatrixAddressingMode> {
	switch (value) {
		case 0:
			return makeResult(MatrixAddressingMode.Linear)
		case 1:
			return makeResult(MatrixAddressingMode.NonLinear)
		default:
			return unexpected(
				[],
				'read addressing mode',
				`unexpected addressing mode '${value}'`,
				MatrixAddressingMode.Linear,
				options
			)
	}
}

================
File: src/encodings/ber/decoder/Parameter.ts
================
import * as Ber from '../../../Ber'
import { Parameter, ParameterType, ParameterImpl, ParameterAccess } from '../../../model/Parameter'
import { decodeStreamDescription } from './StreamDescription'
import { decodeStringIntegerCollection } from './StringIntegerCollection'
import {
	DecodeOptions,
	defaultDecode,
	DecodeResult,
	check,
	makeResult,
	unexpected,
	appendErrors,
	unknownContext,
	skipNext,
} from './DecodeResult'
import { EmberValue, StringIntegerCollection, RelativeOID } from '../../../types/types'
import { StreamDescription } from '../../../model/StreamDescription'

export { decodeParameter, readParameterType }

function decodeParameter(reader: Ber.Reader, options: DecodeOptions = defaultDecode): DecodeResult<Parameter> {
	reader.readSequence(Ber.BERDataTypes.SET)

	let identifier: string | undefined = undefined
	let description: string | undefined = undefined
	let value: EmberValue | undefined = undefined
	let valueType: ParameterType | undefined = undefined
	let minimum: number | null | undefined = undefined
	let maximum: number | null | undefined = undefined
	let access: ParameterAccess | undefined = undefined
	let format: string | undefined = undefined
	let enumeration: string | undefined = undefined
	let factor: number | undefined = undefined
	let isOnline: boolean | undefined = undefined
	let formula: string | undefined = undefined
	let step: number | undefined = undefined
	let defaultValue: EmberValue | undefined = undefined
	let parameterType: ParameterType | undefined = undefined
	let streamIdentifier: number | undefined = undefined
	let enumMap: StringIntegerCollection | undefined = undefined
	let streamDescriptor: StreamDescription | undefined = undefined
	let schemaIdentifiers: string | undefined = undefined
	let templateReference: RelativeOID | undefined = undefined

	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				identifier = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(1):
				description = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(2): {
				const decodedValue = reader.readValue()
				value = decodedValue.value
				valueType = decodedValue.type
				break
			}
			case Ber.CONTEXT(3):
				minimum = reader.readValue().value as number | null
				break
			case Ber.CONTEXT(4):
				maximum = reader.readValue().value as number | null
				break
			case Ber.CONTEXT(5):
				access = appendErrors(readParameterAccess(reader.readInt(), options), errors)
				break
			case Ber.CONTEXT(6):
				format = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(7):
				enumeration = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(8):
				factor = reader.readInt()
				break
			case Ber.CONTEXT(9):
				isOnline = reader.readBoolean()
				break
			case Ber.CONTEXT(10):
				formula = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(11):
				step = reader.readInt()
				break
			case Ber.CONTEXT(12):
				defaultValue = reader.readValue().value // Write value uses type
				break
			case Ber.CONTEXT(13):
				parameterType = appendErrors(readParameterType(reader.readInt(), options), errors)
				break
			case Ber.CONTEXT(14):
				streamIdentifier = reader.readInt()
				break
			case Ber.CONTEXT(15):
				enumMap = appendErrors(decodeStringIntegerCollection(reader, options), errors)
				break
			case Ber.CONTEXT(16):
				streamDescriptor = appendErrors(decodeStreamDescription(reader, options), errors)
				break
			case Ber.CONTEXT(17):
				schemaIdentifiers = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(18):
				templateReference = reader.readString(Ber.BERDataTypes.STRING)
				break
			case 0:
				break // indefinite length
			default:
				unknownContext(errors, 'decode parameter', tag, options)
				skipNext(reader)
				break
		}
	}
	parameterType =
		parameterType === ParameterType.Trigger
			? ParameterType.Trigger
			: !!enumMap || !!enumeration
			? ParameterType.Enum
			: valueType
			? valueType
			: parameterType
	parameterType = check(parameterType, 'decode parameter', 'parameterType', ParameterType.Null, errors, options)

	return makeResult(
		new ParameterImpl(
			parameterType,
			identifier,
			description,
			value,
			maximum,
			minimum,
			access,
			format,
			enumeration,
			factor,
			isOnline,
			formula,
			step,
			defaultValue,
			streamIdentifier,
			enumMap,
			streamDescriptor,
			schemaIdentifiers,
			templateReference
		),
		errors
	)
}

function readParameterAccess(value: number, options: DecodeOptions): DecodeResult<ParameterAccess> {
	switch (value) {
		case 0:
			return makeResult(ParameterAccess.None)
		case 1:
			return makeResult(ParameterAccess.Read)
		case 2:
			return makeResult(ParameterAccess.Write)
		case 3:
			return makeResult(ParameterAccess.ReadWrite)
		default:
			return unexpected(
				[],
				'read parameter access',
				`unexpected parameter access '${value}'`,
				ParameterAccess.ReadWrite,
				options
			)
	}
}

function readParameterType(value: number, options: DecodeOptions): DecodeResult<ParameterType> {
	switch (value) {
		case 0:
			return makeResult(ParameterType.Null)
		case 1:
			return makeResult(ParameterType.Integer)
		case 2:
			return makeResult(ParameterType.Real)
		case 3:
			return makeResult(ParameterType.String)
		case 4:
			return makeResult(ParameterType.Boolean)
		case 5:
			return makeResult(ParameterType.Trigger)
		case 6:
			return makeResult(ParameterType.Enum)
		case 7:
			return makeResult(ParameterType.Octets)
		default:
			return unexpected([], 'read parameter type', `unexpected parameter type '${value}'`, ParameterType.Null, options)
	}
}

================
File: src/encodings/ber/decoder/StreamDescription.ts
================
import * as Ber from '../../../Ber'
import { StreamDescription, StreamDescriptionImpl, StreamFormat } from '../../../model/StreamDescription'
import { StreamDescriptionBERID } from '../constants'
import {
	DecodeOptions,
	defaultDecode,
	DecodeResult,
	unknownContext,
	check,
	appendErrors,
	makeResult,
	unexpected,
	skipNext,
} from './DecodeResult'

export function decodeStreamDescription(
	reader: Ber.Reader,
	options: DecodeOptions = defaultDecode
): DecodeResult<StreamDescription> {
	reader.readSequence(StreamDescriptionBERID)
	let format: StreamFormat | null = null
	let offset: number | null = null
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				format = appendErrors(readStreamFormat(reader.readInt(), options), errors)
				break
			case Ber.CONTEXT(1):
				offset = reader.readInt()
				break
			case 0:
				break // indefinite length
			default:
				unknownContext(errors, 'decode stream description', tag, options)
				skipNext(reader)
				break
		}
	}
	format = check(format, 'decode stream description', 'format', StreamFormat.UInt8, errors, options)
	offset = check(offset, 'decode stream description', 'offset', 0, errors, options)
	return makeResult(new StreamDescriptionImpl(format, offset), errors)
}

function readStreamFormat(value: number, options: DecodeOptions = defaultDecode): DecodeResult<StreamFormat> {
	switch (value) {
		case 0:
			return makeResult(StreamFormat.UInt8)
		case 2:
			return makeResult(StreamFormat.UInt16BE)
		case 3:
			return makeResult(StreamFormat.UInt16LE)
		case 4:
			return makeResult(StreamFormat.UInt32BE)
		case 5:
			return makeResult(StreamFormat.UInt32LE)
		case 6:
			return makeResult(StreamFormat.UInt64BE)
		case 7:
			return makeResult(StreamFormat.UInt64LE)
		case 8:
			return makeResult(StreamFormat.Int8)
		case 10:
			return makeResult(StreamFormat.Int16BE)
		case 11:
			return makeResult(StreamFormat.Int16LE)
		case 12:
			return makeResult(StreamFormat.Int32BE)
		case 13:
			return makeResult(StreamFormat.Int32LE)
		case 14:
			return makeResult(StreamFormat.Int64BE)
		case 15:
			return makeResult(StreamFormat.Int64LE)
		case 20:
			return makeResult(StreamFormat.Float32BE)
		case 21:
			return makeResult(StreamFormat.Float32LE)
		case 22:
			return makeResult(StreamFormat.Float64BE)
		case 23:
			return makeResult(StreamFormat.Float64LE)
		default:
			return unexpected([], 'read stream format', `unexpected stream format '${value}'`, StreamFormat.UInt8, options)
	}
}

================
File: src/encodings/ber/decoder/StreamEntry.ts
================
import * as Ber from '../../../Ber'
import { StreamEntry, StreamEntryImpl } from '../../../model/StreamEntry'
import { EmberTypedValue, literal } from '../../../types/types'
import { StreamEntryBERID, StreamEntriesBERID } from '../constants'
import {
	DecodeResult,
	makeResult,
	unknownContext,
	DecodeOptions,
	defaultDecode,
	safeSet,
	check,
	skipNext,
} from './DecodeResult'
import { ParameterType } from '../../../model/Parameter'

export { decodeStreamEntry, decodeStreamEntries }

function decodeStreamEntries(
	reader: Ber.Reader,
	options: DecodeOptions = defaultDecode
): DecodeResult<Array<StreamEntry>> {
	reader.readSequence(StreamEntriesBERID)
	const streamEntries = makeResult<Array<StreamEntry>>([])
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		if (tag === 0) continue
		if (tag !== Ber.CONTEXT(0)) {
			unknownContext(streamEntries, 'decode stream entries', tag, options)
			skipNext(reader)
			continue
		}
		const rootEl = decodeStreamEntry(reader)
		safeSet(rootEl, streamEntries, (x, y) => {
			y.push(x)
			return y
		})
	}
	return streamEntries
}

function decodeStreamEntry(reader: Ber.Reader, options: DecodeOptions = defaultDecode): DecodeResult<StreamEntry> {
	reader.readSequence(StreamEntryBERID)
	let identifier: number | null = null
	let value: EmberTypedValue | null = null
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				identifier = reader.readInt()
				break
			case Ber.CONTEXT(1):
				value = reader.readValue()
				// return the full stream for later processing
				break
			case 0:
				break // indefinite length
			default:
				unknownContext(errors, 'decode stream entry', tag, options)
				skipNext(reader)
				break
		}
	}
	identifier = check(identifier, 'decode stream entry', 'identifier', 0, errors, options)
	value = check(
		value,
		'decode stream entry',
		'value',
		literal<EmberTypedValue>({ value: null, type: ParameterType.Null }),
		errors,
		options
	)
	return makeResult(new StreamEntryImpl(identifier, value), errors)
}

================
File: src/encodings/ber/decoder/StringIntegerCollection.ts
================
import * as Ber from '../../../Ber'
import { StringIntegerCollection } from '../../../types/types'
import { StringIntegerCollectionBERID, StringIntegerPairBERID } from '../constants'
import {
	DecodeOptions,
	defaultDecode,
	DecodeResult,
	makeResult,
	unknownContext,
	appendErrors,
	check,
	skipNext,
} from './DecodeResult'

export { decodeStringIntegerCollection }

function decodeStringIntegerCollection(
	reader: Ber.Reader,
	options: DecodeOptions = defaultDecode
): DecodeResult<StringIntegerCollection> {
	reader.readSequence(StringIntegerCollectionBERID)
	const collection: StringIntegerCollection = new Map<string, number>()
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		if (tag === 0) continue
		if (tag !== Ber.CONTEXT(0)) {
			unknownContext(errors, 'decode string integer collection', tag, options)
			skipNext(reader)
			continue
		}
		const pair = appendErrors(decodeStringIntegerPair(reader, options), errors)
		collection.set(pair.key, pair.value)
	}
	return makeResult(collection, errors)
}

function decodeStringIntegerPair(
	reader: Ber.Reader,
	options: DecodeOptions = defaultDecode
): DecodeResult<{ key: string; value: number }> {
	let key: string | null = null
	let value: number | null = null
	const errors: Array<Error> = []
	reader.readSequence(StringIntegerPairBERID)
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				key = reader.readString(Ber.BERDataTypes.STRING)
				break
			case Ber.CONTEXT(1):
				value = reader.readInt()
				break
			case 0:
				break // indefinite length
			default:
				unknownContext(errors, 'deocde string integer pair', tag, options)
				skipNext(reader)
				break
		}
	}
	key = check(key, 'decode string integer pair', 'key', `key${(Math.random() * 1000000) | 0}`, errors, options)
	value = check(value, 'decode string integer pair', 'value', -1, errors, options)
	return makeResult({ key, value }, errors)
}

================
File: src/encodings/ber/decoder/Template.ts
================
import * as Ber from '../../../Ber'
import { Template, TemplateImpl } from '../../../model/Template'
import { Parameter } from '../../../model/Parameter'
import { Matrix } from '../../../model/Matrix'
import { EmberFunction } from '../../../model/EmberFunction'
import { EmberNode } from '../../../model/EmberNode'
import { EmberTreeNode, TreeElement } from '../../../types/types'
import { TemplateBERID, QualifiedTemplateBERID } from '../constants'
import { decodeGenericElement } from './Tree'
import { NumberedTreeNodeImpl, QualifiedElementImpl } from '../../../model/Tree'
import {
	DecodeOptions,
	defaultDecode,
	DecodeResult,
	unknownContext,
	appendErrors,
	check,
	makeResult,
	skipNext,
} from './DecodeResult'

export function decodeTemplate(
	reader: Ber.Reader,
	isQualified = false,
	options: DecodeOptions = defaultDecode
): DecodeResult<TreeElement<Template>> {
	reader.readSequence(isQualified ? QualifiedTemplateBERID : TemplateBERID)
	let number: number | null = null
	let path: string | null = null
	let element: EmberTreeNode<Parameter | EmberNode | Matrix | EmberFunction> | undefined = undefined
	let description: string | undefined = undefined
	const errors: Array<Error> = []
	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				if (isQualified) {
					path = reader.readRelativeOID()
				} else {
					number = reader.readInt()
				}
				break
			case Ber.CONTEXT(1):
				element = appendErrors(
					decodeGenericElement(reader, options) as DecodeResult<
						EmberTreeNode<Parameter | EmberNode | Matrix | EmberFunction>
					>,
					errors
				)
				break
			case Ber.CONTEXT(2):
				description = reader.readString(Ber.BERDataTypes.STRING)
				break
			case 0:
				break // indefinite length
			default:
				unknownContext(errors, 'decode template', tag, options)
				skipNext(reader)
				break
		}
	}
	if (isQualified) {
		path = check(path, 'decode template', 'path', '', errors, options)
		return makeResult(new QualifiedElementImpl(path, new TemplateImpl(element, description)), errors)
	} else {
		number = check(number, 'decode tempalte', 'number', -1, errors, options)
		return makeResult(new NumberedTreeNodeImpl(number, new TemplateImpl(element, description)), errors)
	}
}

================
File: src/encodings/ber/decoder/Tree.ts
================
import * as Ber from '../../../Ber'
import { EmberElement, ElementType } from '../../../model/EmberElement'
import { NumberedTreeNode, TreeElement, QualifiedElementImpl, NumberedTreeNodeImpl } from '../../../model/Tree'
import { decodeFunctionContent } from './EmberFunction'
import { decodeNode } from './EmberNode'
import { decodeParameter } from './Parameter'
import { decodeTemplate } from './Template'
import {
	QualifiedTemplateBERID,
	QualifiedParameterBERID,
	QualifiedNodeBERID,
	QualifiedMatrixBERID,
	QualifiedFunctionBERID,
	CommandBERID,
	FunctionBERID,
	NodeBERID,
	MatrixBERID,
	ParameterBERID,
	TemplateBERID,
	RootElementsBERID,
	ElementCollectionBERID,
} from '../constants'
import { decodeMatrix } from './Matrix'
import { decodeCommand } from './Command'
import { RootElement, Collection } from '../../../types/types'
import {
	DecodeResult,
	DecodeOptions,
	defaultDecode,
	makeResult,
	unknownContext,
	safeSet,
	appendErrors,
	unknownApplication,
	check,
	unexpected,
	skipNext,
} from './DecodeResult'
import { Command } from '../../../model/Command'
import { EmberNodeImpl } from '../../../model/EmberNode'
import { ParameterImpl, ParameterType, EmberFunctionImpl } from '../../../model'

export function decodeChildren(
	reader: Ber.Reader,
	options: DecodeOptions = defaultDecode
): DecodeResult<Collection<NumberedTreeNode<EmberElement>>> {
	reader.readSequence(ElementCollectionBERID)
	const kids = makeResult<Collection<NumberedTreeNode<EmberElement>>>({} as Collection<NumberedTreeNode<EmberElement>>)

	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		if (tag === 0) continue
		const kidEl = decodeGenericElement(reader, options) as DecodeResult<NumberedTreeNode<EmberElement>>
		safeSet(kidEl, kids, (x, y) => {
			y[x.number] = x
			return y
		})
	}

	return kids
}

export function decodeGenericElement(
	reader: Ber.Reader,
	options: DecodeOptions = defaultDecode
): DecodeResult<TreeElement<EmberElement>> {
	const tag = reader.peek()
	const errors = new Array<Error>()

	if (tag === null) {
		unknownApplication(errors, 'decode generic element', tag, options)
		skipNext(reader)
		return makeResult(new NumberedTreeNodeImpl(-1, new EmberNodeImpl()), errors)
	}
	const isQualified = isTagQualified(tag)
	const type = appendErrors(tagToElType(tag, options), errors)

	if (tag === MatrixBERID || tag === QualifiedMatrixBERID) {
		return decodeMatrix(reader, isQualified)
	}
	if (tag === TemplateBERID || tag === QualifiedTemplateBERID) {
		return decodeTemplate(reader, isQualified)
	} else if (tag === CommandBERID) {
		const commandResult: DecodeResult<Command> = decodeCommand(reader, options)
		return makeResult(new NumberedTreeNodeImpl(commandResult.value.number, commandResult.value), commandResult.errors)
	}

	reader.readSequence(tag)
	let path: string | null = null
	let number: number | null = null
	let contents: EmberElement | undefined = undefined
	let children: Collection<NumberedTreeNode<EmberElement>> | undefined

	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		switch (tag) {
			case Ber.CONTEXT(0):
				if (isQualified) {
					path = reader.readRelativeOID()
				} else {
					number = reader.readInt()
				}
				break
			case Ber.CONTEXT(1):
				// parse contents
				switch (type) {
					case ElementType.Command:
						unknownApplication(errors, 'decode generic element: command is not generic', tag, options)
						// contents = new EmberNodeImpl()
						skipNext(reader)
						break
					case ElementType.Function:
						contents = appendErrors(decodeFunctionContent(reader, options), errors)
						break
					case ElementType.Matrix:
						unknownApplication(errors, 'decode generic element: matrix is not generic', tag, options)
						// contents = new EmberNodeImpl()
						skipNext(reader)
						break
					case ElementType.Node:
						contents = appendErrors(decodeNode(reader, options), errors)
						break
					case ElementType.Parameter:
						contents = appendErrors(decodeParameter(reader, options), errors)
						break
					case ElementType.Template:
						unknownApplication(errors, 'decode generic element: template is not generic', tag, options)
						// contents = new EmberNodeImpl()
						skipNext(reader)
						break
					default:
						unknownApplication(errors, 'decode generic element', tag, options)
						// contents = new EmberNodeImpl()
						skipNext(reader)
						break
				}
				break
			case Ber.CONTEXT(2):
				children = appendErrors(decodeChildren(reader, options), errors)
				break
			case 0:
				break // indefinite length
			default:
				unknownContext(errors, 'decode generic element', tag, options)
				skipNext(reader)
				break
		}
	}

	if (!contents) {
		switch (type) {
			case ElementType.Node:
				contents = new EmberNodeImpl()
				break
			case ElementType.Parameter:
				contents = new ParameterImpl(ParameterType.Null)
				break
			case ElementType.Function:
				contents = new EmberFunctionImpl()
				break
			default:
				errors.push(new Error(`decodeGenericElement: No contents and unexpected type ${type}`))
				contents = new EmberNodeImpl()
				break
		}
	}

	let el: TreeElement<EmberElement>
	if (isQualified) {
		path = check(path, 'decode generic element', 'path', '', errors, options)
		el = new QualifiedElementImpl(path, contents, children)
	} else {
		number = check(number, 'decode generic element', 'number', -1, errors, options)
		el = new NumberedTreeNodeImpl(number, contents, children)
	}

	if (children) {
		for (const kid of Object.values<NumberedTreeNode<EmberElement>>(children)) {
			kid.parent = el as RootElement
		}
	}

	return makeResult<TreeElement<EmberElement>>(el, errors)
}

export function decodeRootElements(
	reader: Ber.Reader,
	options: DecodeOptions = defaultDecode
): DecodeResult<Collection<RootElement>> {
	reader.readSequence(RootElementsBERID)
	const rootEls = makeResult<Collection<RootElement>>({})

	const endOffset = reader.offset + reader.length
	while (reader.offset < endOffset) {
		const tag = reader.readSequence()
		if (tag === 0) continue
		if (tag !== Ber.CONTEXT(0)) {
			unknownContext(rootEls, 'decode root elements', tag, options)
			skipNext(reader)
			continue
		}
		const rootEl = decodeGenericElement(reader, options) as DecodeResult<NumberedTreeNode<EmberElement>>
		safeSet(rootEl, rootEls, (x, y) => {
			if (x.number) {
				y[x.number] = x
			} else {
				y[Object.values<RootElement>(y).length] = x
			}
			return y
		})
	}
	return rootEls
}

function isTagQualified(tag: number): boolean {
	const qualifiedTags = new Set([
		QualifiedTemplateBERID,
		QualifiedParameterBERID,
		QualifiedNodeBERID,
		QualifiedMatrixBERID,
		QualifiedFunctionBERID,
	])

	return qualifiedTags.has(tag)
}

function tagToElType(tag: number, options: DecodeOptions = defaultDecode): DecodeResult<ElementType> {
	const tags = {
		[CommandBERID]: ElementType.Command,
		[FunctionBERID]: ElementType.Function,
		[NodeBERID]: ElementType.Node,
		[MatrixBERID]: ElementType.Matrix,
		[ParameterBERID]: ElementType.Parameter,
		[TemplateBERID]: ElementType.Template,
		[QualifiedTemplateBERID]: ElementType.Template,
		[QualifiedParameterBERID]: ElementType.Parameter,
		[QualifiedNodeBERID]: ElementType.Node,
		[QualifiedMatrixBERID]: ElementType.Matrix,
		[QualifiedFunctionBERID]: ElementType.Function,
	}

	if (!tags[tag]) {
		return unexpected([], 'tag to element type', `Unexpected element type tag '${tag}'`, ElementType.Node, options)
	}

	return makeResult(tags[tag])
}

================
File: src/encodings/ber/encoder/Command.ts
================
import * as Ber from '../../../Ber'
import { Command, CommandType, GetDirectory, FieldFlags, Invoke } from '../../../model/Command'
import { encodeInvocation } from './Invocation'
import { CommandBERID } from '../constants'

export function encodeCommand(el: Command, writer: Ber.Writer): void {
	writer.startSequence(CommandBERID)

	writer.startSequence(Ber.CONTEXT(0))
	writer.writeInt(el.number)
	writer.endSequence() // BER.CONTEXT(0)

	if (isGetDirectory(el) && el.dirFieldMask) {
		writer.startSequence(Ber.CONTEXT(1))
		writeDirFieldMask(el.dirFieldMask, writer)
		writer.endSequence()
	}

	if (isInvoke(el) && el.invocation) {
		writer.startSequence(Ber.CONTEXT(2))
		encodeInvocation(el.invocation, writer)
		writer.endSequence()
	}

	writer.endSequence() // CommandBERID
}

function isInvoke(command: Command): command is Invoke {
	return command.number === CommandType.Invoke
}

function isGetDirectory(command: Command): command is GetDirectory {
	return command.number === CommandType.GetDirectory
}

function writeDirFieldMask(fieldMask: FieldFlags, writer: Ber.Writer): void {
	const maskToInt: { [flag: string]: number } = {
		[FieldFlags.Sparse]: -2,
		[FieldFlags.All]: -1,
		[FieldFlags.Default]: 0,
		[FieldFlags.Identifier]: 1,
		[FieldFlags.Description]: 2,
		[FieldFlags.Tree]: 3,
		[FieldFlags.Value]: 4,
		[FieldFlags.Connections]: 5,
	}

	writer.writeInt(maskToInt[fieldMask])
}

================
File: src/encodings/ber/encoder/Connection.ts
================
import { Connection, ConnectionOperation, ConnectionDisposition } from '../../../model/Connection'
import * as Ber from '../../../Ber'
import { ConnectionBERID } from '../constants'

export function encodeConnection(connection: Connection, writer: Ber.Writer): void {
	writer.startSequence(ConnectionBERID)

	writer.startSequence(Ber.CONTEXT(0))
	writer.writeInt(connection.target)
	writer.endSequence()

	if (connection.sources != null) {
		writer.startSequence(Ber.CONTEXT(1))
		writer.writeRelativeOID(connection.sources.join('.'), Ber.BERDataTypes.RELATIVE_OID)
		writer.endSequence()
	}
	if (connection.operation != null) {
		writer.startSequence(Ber.CONTEXT(2))
		writeConnectionOperation(connection.operation, writer)
		writer.endSequence()
	}
	if (connection.disposition != null) {
		writer.startSequence(Ber.CONTEXT(3))
		writeConnectionDisposition(connection.disposition, writer)
		writer.endSequence()
	}
	writer.endSequence()
}

function writeConnectionOperation(operation: ConnectionOperation, writer: Ber.Writer): void {
	const operationToInt: { [flag: string]: number } = {
		[ConnectionOperation.Absolute]: 0,
		[ConnectionOperation.Connect]: 1,
		[ConnectionOperation.Disconnect]: 2,
	}

	writer.writeInt(operationToInt[operation])
}

function writeConnectionDisposition(operation: ConnectionDisposition, writer: Ber.Writer): void {
	const operationToInt: { [flag: string]: number } = {
		[ConnectionDisposition.Tally]: 0,
		[ConnectionDisposition.Modified]: 1,
		[ConnectionDisposition.Pending]: 2,
		[ConnectionDisposition.Locked]: 3,
	}

	writer.writeInt(operationToInt[operation])
}

================
File: src/encodings/ber/encoder/EmberElement.ts
================
import { EmberElement, ElementType } from '../../../model/EmberElement'
import { Writer } from '../../../Ber'
import { encodeCommand } from './Command'
import { encodeParameter } from './Parameter'
import { encodeNode } from './EmberNode'
import { encodeMatrix } from './Matrix'
import { encodeFunction } from './EmberFunction'
import { encodeTemplate } from './Template'

export function encodeEmberElement(el: EmberElement, writer: Writer): void {
	switch (el.type) {
		case ElementType.Command:
			encodeCommand(el, writer)
			break
		case ElementType.Parameter:
			encodeParameter(el, writer)
			break
		case ElementType.Node:
			encodeNode(el, writer)
			break
		case ElementType.Matrix:
			encodeMatrix(el, writer)
			break
		case ElementType.Function:
			encodeFunction(el, writer)
			break
		case ElementType.Template:
			encodeTemplate(el, writer)
			break
	}
}

================
File: src/encodings/ber/encoder/EmberFunction.ts
================
import * as Ber from '../../../Ber'
import { EmberFunction } from '../../../model/EmberFunction'
import { encodeFunctionArgument } from './FunctionArgument'

export function encodeFunction(el: EmberFunction, writer: Ber.Writer): void {
	// The function itself is a node, and then the contents are another node I think. This just encodes the contents:
	writer.startSequence(Ber.BERDataTypes.SET)

	if (el.identifier != null) {
		writer.startSequence(Ber.CONTEXT(0))
		writer.writeString(el.identifier, Ber.BERDataTypes.STRING)
		writer.endSequence() // Ber.CONTEXT(0)
	}

	if (el.description != null) {
		writer.startSequence(Ber.CONTEXT(1))
		writer.writeString(el.description, Ber.BERDataTypes.STRING)
		writer.endSequence() // Ber.CONTEXT(1)
	}

	if (el.args != null) {
		writer.startSequence(Ber.CONTEXT(2))
		writer.startSequence(Ber.BERDataTypes.SEQUENCE)
		for (let i = 0; i < el.args.length; i++) {
			writer.startSequence(Ber.CONTEXT(0))
			encodeFunctionArgument(el.args[i], writer)
			writer.endSequence()
		}
		writer.endSequence()
		writer.endSequence() // Ber.CONTEXT(2)
	}

	if (el.result != null && el.result.length > 0) {
		writer.startSequence(Ber.CONTEXT(3))
		writer.startSequence(Ber.BERDataTypes.SEQUENCE)
		for (let i = 0; i < el.result.length; i++) {
			writer.startSequence(Ber.CONTEXT(0))
			encodeFunctionArgument(el.result[i], writer)
			writer.endSequence()
		}
		writer.endSequence()
		writer.endSequence() // Ber.CONTEXT(3)
	}

	if (el.templateReference != null) {
		writer.startSequence(Ber.CONTEXT(4))
		writer.writeRelativeOID(el.templateReference, Ber.BERDataTypes.RELATIVE_OID)
		writer.endSequence() // Ber.CONTEXT(4)
	}

	writer.endSequence() // Ber.EMBER_SET
}

================
File: src/encodings/ber/encoder/EmberNode.ts
================
import * as Ber from '../../../Ber'
import { EmberNode } from '../../../model/EmberNode'

export function encodeNode(node: EmberNode, writer: Ber.Writer): void {
	writer.startSequence(Ber.BERDataTypes.SET)

	if (node.identifier != null) {
		writer.startSequence(Ber.CONTEXT(0))
		writer.writeString(node.identifier, Ber.BERDataTypes.STRING)
		writer.endSequence() // Ber.CONTEXT(0)
	}

	if (node.description != null) {
		writer.startSequence(Ber.CONTEXT(1))
		writer.writeString(node.description, Ber.BERDataTypes.STRING)
		writer.endSequence() // Ber.CONTEXT(1)
	}

	if (node.isRoot != null) {
		writer.startSequence(Ber.CONTEXT(2))
		writer.writeBoolean(node.isRoot)
		writer.endSequence() // Ber.CONTEXT(2)
	}

	if (node.isOnline != null) {
		writer.startSequence(Ber.CONTEXT(3))
		writer.writeBoolean(node.isOnline)
		writer.endSequence() // Ber.CONTEXT(3)
	}

	if (node.schemaIdentifiers != null) {
		writer.startSequence(Ber.CONTEXT(4))
		writer.writeString(node.schemaIdentifiers, Ber.BERDataTypes.STRING)
		writer.endSequence() // Ber.CONTEXT(4)
	}

	if (node.templateReference != null) {
		writer.startSequence(Ber.CONTEXT(5))
		writer.writeRelativeOID(node.templateReference, Ber.BERDataTypes.RELATIVE_OID)
		writer.endSequence() // Ber.CONTEXT(3)
	}

	writer.endSequence() // Ber.BERDataTypes.SET
}

================
File: src/encodings/ber/encoder/FunctionArgument.ts
================
import { FunctionArgument } from '../../../model/FunctionArgument'
import * as Ber from '../../../Ber'
import { InvalidEmberNode } from '../../../Errors'
import { ParameterType } from '../../../model/Parameter'
import { FunctionArgumentBERID } from '../constants'

export function encodeFunctionArgument(arg: FunctionArgument, writer: Ber.Writer): void {
	writer.startSequence(FunctionArgumentBERID)
	if (arg.type == null) {
		throw new InvalidEmberNode('', 'FunctionArgument requires a type')
	}
	writer.startSequence(Ber.CONTEXT(0))
	writeParameterType(arg.type, writer)
	writer.endSequence()
	if (arg.name != null) {
		writer.startSequence(Ber.CONTEXT(1))
		writer.writeString(arg.name, Ber.BERDataTypes.STRING)
		writer.endSequence()
	}
	writer.endSequence()
}

function writeParameterType(type: ParameterType, writer: Ber.Writer): void {
	const typeToInt: { [flag: string]: number } = {
		[ParameterType.Null]: 0,
		[ParameterType.Integer]: 1,
		[ParameterType.Real]: 2,
		[ParameterType.String]: 3,
		[ParameterType.Boolean]: 4,
		[ParameterType.Trigger]: 5,
		[ParameterType.Enum]: 6,
		[ParameterType.Octets]: 7,
	}

	writer.writeInt(typeToInt[type])
}

================
File: src/encodings/ber/encoder/Invocation.ts
================
import { Invocation } from '../../../model/Invocation'
import * as Ber from '../../../Ber'
import { InvocationBERID } from '../constants'

export function encodeInvocation(invocation: Invocation, writer: Ber.Writer): void {
	writer.startSequence(InvocationBERID)
	if (invocation.id != null) {
		writer.startSequence(Ber.CONTEXT(0))
		writer.writeInt(invocation.id)
		writer.endSequence()
	}
	writer.startSequence(Ber.CONTEXT(1))
	writer.startSequence(Ber.BERDataTypes.SEQUENCE)
	for (let i = 0; i < invocation.args.length; i++) {
		writer.startSequence(Ber.CONTEXT(0))
		writer.writeValue(invocation.args[i])
		writer.endSequence()
	}
	writer.endSequence()
	writer.endSequence()

	writer.endSequence() // InvocationBERID
}

================
File: src/encodings/ber/encoder/InvocationResult.ts
================
import * as Ber from '../../../Ber'
import { InvocationResult } from '../../../model/InvocationResult'
import { InvocationResultBERID } from '../constants'

export function encodeInvocationResult(result: InvocationResult, writer: Ber.Writer): void {
	writer.startSequence(InvocationResultBERID)
	if (result.id != null) {
		writer.startSequence(Ber.CONTEXT(0))
		writer.writeInt(result.id)
		writer.endSequence()
	}
	if (result.success != null) {
		writer.startSequence(Ber.CONTEXT(1))
		writer.writeBoolean(result.success)
		writer.endSequence()
	}
	if (result.result != null && result.result.length) {
		writer.startSequence(Ber.CONTEXT(2))
		writer.startSequence(Ber.BERDataTypes.SEQUENCE)
		for (let i = 0; i < result.result.length; i++) {
			writer.startSequence(Ber.CONTEXT(0))
			writer.writeValue(result.result[i])
			writer.endSequence()
		}
		writer.endSequence()
		writer.endSequence()
	}
	writer.endSequence() // InvocationResultBERID
}

================
File: src/encodings/ber/encoder/Label.ts
================
import * as Ber from '../../../Ber'
import { Label } from '../../../model/Label'
import { InvalidEmberNode } from '../../../Errors'
import { LabelBERID } from '../constants'

export function encodeLabel(label: Label, writer: Ber.Writer): void {
	writer.startSequence(LabelBERID)
	if (label.basePath == null) {
		throw new InvalidEmberNode('', 'Missing label base path')
	}
	writer.startSequence(Ber.CONTEXT(0))
	writer.writeRelativeOID(label.basePath, Ber.BERDataTypes.RELATIVE_OID)
	writer.endSequence()
	if (label.description == null) {
		throw new InvalidEmberNode('', 'Missing label description')
	}
	writer.startSequence(Ber.CONTEXT(1))
	writer.writeString(label.description, Ber.BERDataTypes.STRING)
	writer.endSequence()
	writer.endSequence()
}

================
File: src/encodings/ber/encoder/Matrix.ts
================
import * as Ber from '../../../Ber'
import { Matrix, MatrixType, MatrixAddressingMode } from '../../../model/Matrix'
import { ElementType } from '../../../model/EmberElement'
import { encodeLabel } from './Label'
import { RelativeOID } from '../../../types/types'
import { TargetBERID, SourceBERID } from '../constants'

export function encodeMatrix(matrix: Matrix, writer: Ber.Writer): void {
	writer.startSequence(Ber.BERDataTypes.SET)

	writer.writeIfDefined(matrix.identifier, writer.writeString, 0, Ber.BERDataTypes.STRING)
	writer.writeIfDefined(matrix.description, writer.writeString, 1, Ber.BERDataTypes.STRING)
	writer.writeIfDefined(
		matrix.matrixType && matrixTypeToInt(matrix.matrixType),
		writer.writeInt,
		2,
		Ber.BERDataTypes.INTEGER
	)
	writer.writeIfDefined(
		matrix.addressingMode && matrixModeToInt(matrix.addressingMode),
		writer.writeInt,
		3,
		Ber.BERDataTypes.INTEGER
	)
	writer.writeIfDefined(matrix.targetCount, writer.writeInt, 4, Ber.BERDataTypes.INTEGER)
	writer.writeIfDefined(matrix.sourceCount, writer.writeInt, 5, Ber.BERDataTypes.INTEGER)
	writer.writeIfDefined(matrix.maximumTotalConnects, writer.writeInt, 6, Ber.BERDataTypes.INTEGER)
	writer.writeIfDefined(matrix.maximumConnectsPerTarget, writer.writeInt, 7, Ber.BERDataTypes.INTEGER)

	if (matrix.parametersLocation != null) {
		writer.startSequence(Ber.CONTEXT(8))
		const param = Number(matrix.parametersLocation)
		if (isNaN(param)) {
			writer.writeRelativeOID(matrix.parametersLocation as RelativeOID, Ber.BERDataTypes.RELATIVE_OID)
		} else {
			writer.writeInt(param)
		}
		writer.endSequence()
	}

	writer.writeIfDefined(matrix.gainParameterNumber, writer.writeInt, 9, Ber.BERDataTypes.INTEGER)

	if (matrix.labels != null) {
		writer.startSequence(Ber.CONTEXT(10))
		writer.startSequence(Ber.BERDataTypes.SEQUENCE)
		for (let i = 0; i < matrix.labels.length; i++) {
			writer.startSequence(Ber.CONTEXT(0))
			encodeLabel(matrix.labels[i], writer)
			writer.endSequence()
		}
		writer.endSequence()
		writer.endSequence()
	}

	writer.writeIfDefined(matrix.schemaIdentifiers, writer.writeString, 11, Ber.BERDataTypes.STRING)

	if (matrix.templateReference != null) {
		writer.startSequence(Ber.CONTEXT(12))
		writer.writeRelativeOID(matrix.templateReference, Ber.BERDataTypes.RELATIVE_OID)
		writer.endSequence()
	}

	writer.endSequence()
}

export function encodeTarget(target: number, writer: Ber.Writer): void {
	writer.startSequence(TargetBERID)
	writer.startSequence(Ber.CONTEXT(0))
	writer.writeInt(target, Ber.BERDataTypes.INTEGER)
	writer.endSequence()
	writer.endSequence()
}

export function encodeSource(source: number, writer: Ber.Writer): void {
	writer.startSequence(SourceBERID)
	writer.startSequence(Ber.CONTEXT(0))
	writer.writeInt(source, Ber.BERDataTypes.INTEGER)
	writer.endSequence()
	writer.endSequence()
}

export function elementTypeToInt(type: ElementType): number {
	const typeToInt = {
		[ElementType.Parameter]: 0,
		[ElementType.Node]: 1,
		[ElementType.Command]: 2,
		[ElementType.Matrix]: 3,
		[ElementType.Function]: 4,
		[ElementType.Template]: 5,
	}

	return typeToInt[type]
}

export function matrixTypeToInt(type: MatrixType): number {
	const typeToInt = {
		[MatrixType.OneToN]: 0,
		[MatrixType.OneToOne]: 1,
		[MatrixType.NToN]: 2,
	}

	return typeToInt[type]
}

export function matrixModeToInt(mode: MatrixAddressingMode): number {
	const modeToInt = {
		[MatrixAddressingMode.Linear]: 0,
		[MatrixAddressingMode.NonLinear]: 1,
	}

	return modeToInt[mode]
}

================
File: src/encodings/ber/encoder/Parameter.ts
================
import * as Ber from '../../../Ber'
import { Parameter, ParameterType, ParameterAccess } from '../../../model/Parameter'
import { EmberValue } from '../../../types/types'
import { encodeStringIntegerCollection } from './StringIntegerCollection'
import { encodeStreamDescription } from './StreamDescription'
// import { elementTypeToInt } from './Matrix'

export function encodeParameter(parameter: Parameter, writer: Ber.Writer): void {
	writer.startSequence(Ber.BERDataTypes.SET)

	const writeValue = (value: EmberValue): void => {
		switch (parameter.parameterType) {
			case ParameterType.Null:
				writer.writeNull()
				break
			case ParameterType.Integer:
				writer.writeInt(Number(value), Ber.BERDataTypes.INTEGER)
				break
			case ParameterType.Real:
				writer.writeReal(Number(value), Ber.BERDataTypes.REAL)
				break
			case ParameterType.String:
				writer.writeString(value + '', Ber.BERDataTypes.STRING)
				break
			case ParameterType.Boolean:
				writer.writeBoolean(value as boolean, Ber.BERDataTypes.BOOLEAN)
				break
			// case ParameterType.Trigger:
			// 	break
			case ParameterType.Enum:
				// value is encoded as Int64, it refers to the line number of the enumeration
				writer.writeInt(value as number, Ber.BERDataTypes.INTEGER)
				break
			case ParameterType.Octets:
				writer.writeBuffer(value as Buffer, Ber.BERDataTypes.OCTETSTRING)
				break
			default:
				writer.writeValue(value)
		}
	}

	writer.writeIfDefined(parameter.identifier, writer.writeString, 0, Ber.BERDataTypes.STRING)
	writer.writeIfDefined(parameter.description, writer.writeString, 1, Ber.BERDataTypes.STRING)
	if (parameter.value !== undefined) {
		writer.startSequence(Ber.CONTEXT(2))
		writeValue(parameter.value)
		writer.endSequence()
	}
	if (parameter.minimum !== undefined) {
		writer.startSequence(Ber.CONTEXT(3))
		writeValue(parameter.minimum)
		writer.endSequence()
	}
	if (parameter.maximum !== undefined) {
		writer.startSequence(Ber.CONTEXT(4))
		writeValue(parameter.maximum)
		writer.endSequence()
	}
	writer.writeIfDefined(
		parameter.access && parameterAccessToInt(parameter.access),
		writer.writeInt,
		5,
		Ber.BERDataTypes.INTEGER
	)
	writer.writeIfDefined(parameter.format, writer.writeString, 6, Ber.BERDataTypes.STRING)
	writer.writeIfDefined(parameter.enumeration, writer.writeString, 7, Ber.BERDataTypes.STRING)
	writer.writeIfDefined(parameter.factor, writer.writeInt, 8, Ber.BERDataTypes.INTEGER)
	writer.writeIfDefined(parameter.isOnline, writer.writeBoolean, 9, Ber.BERDataTypes.BOOLEAN)
	writer.writeIfDefined(parameter.formula, writer.writeString, 10, Ber.BERDataTypes.STRING)
	writer.writeIfDefined(parameter.step, writer.writeInt, 11, Ber.BERDataTypes.INTEGER)

	if (parameter.defaultValue !== undefined) {
		writer.startSequence(Ber.CONTEXT(12))
		writeValue(parameter.defaultValue)
		writer.endSequence()
	}

	if (parameter.parameterType) {
		writer.startSequence(Ber.CONTEXT(13))
		writer.writeInt(parameterTypeToInt(parameter.parameterType))
		writer.endSequence()
	}

	writer.writeIfDefined(parameter.streamIdentifier, writer.writeInt, 14, Ber.BERDataTypes.INTEGER)

	if (parameter.enumMap != null) {
		writer.startSequence(Ber.CONTEXT(15))
		encodeStringIntegerCollection(parameter.enumMap, writer)
		writer.endSequence()
	}

	if (parameter.streamDescriptor != null) {
		writer.startSequence(Ber.CONTEXT(16))
		encodeStreamDescription(parameter.streamDescriptor, writer)
		writer.endSequence()
	}

	writer.writeIfDefined(parameter.schemaIdentifiers, writer.writeString, 17, Ber.BERDataTypes.STRING)

	writer.writeIfDefined(parameter.templateReference, writer.writeString, 18, Ber.BERDataTypes.STRING)

	writer.endSequence()
}

function parameterAccessToInt(parameter: ParameterAccess): number {
	const paramToInt = {
		[ParameterAccess.None]: 0,
		[ParameterAccess.Read]: 1,
		[ParameterAccess.Write]: 2,
		[ParameterAccess.ReadWrite]: 3,
	}

	return paramToInt[parameter]
}

function parameterTypeToInt(pt: ParameterType): number {
	const paramTypeToInt = {
		[ParameterType.Null]: 0,
		[ParameterType.Integer]: 1,
		[ParameterType.Real]: 2,
		[ParameterType.String]: 3,
		[ParameterType.Boolean]: 4,
		[ParameterType.Trigger]: 5,
		[ParameterType.Enum]: 6,
		[ParameterType.Octets]: 7,
	}

	return paramTypeToInt[pt]
}

================
File: src/encodings/ber/encoder/Qualified.ts
================
import * as Ber from '../../../Ber'
import { EmberElement, ElementType } from '../../../model/EmberElement'
import { encodeTree } from './Tree'
import { QualifiedElement } from '../../../types/types'
import {
	QualifiedFunctionBERID,
	QualifiedMatrixBERID,
	QualifiedNodeBERID,
	QualifiedParameterBERID,
	QualifiedTemplateBERID,
} from '../constants'

// note, this no longer encodes a full element, only the start
export function encodeQualifedElement(el: QualifiedElement<EmberElement>, writer: Ber.Writer): void {
	switch (el.contents.type) {
		case ElementType.Function:
			writer.startSequence(QualifiedFunctionBERID)
			break
		case ElementType.Matrix:
			writer.startSequence(QualifiedMatrixBERID)
			break
		case ElementType.Node:
			writer.startSequence(QualifiedNodeBERID)
			break
		case ElementType.Parameter:
			writer.startSequence(QualifiedParameterBERID)
			break
		case ElementType.Template:
			writer.startSequence(QualifiedTemplateBERID)
			break
	}

	writer.startSequence(Ber.CONTEXT(0))
	writer.writeRelativeOID(el.path, Ber.BERDataTypes.RELATIVE_OID)
	writer.endSequence()

	encodeTree(el, writer)
}

================
File: src/encodings/ber/encoder/RootElement.ts
================
import { RootElement } from '../../../types/types'
import { Writer } from '../../../Ber'
import { encodeNumberedElement } from './Tree'
import { encodeQualifedElement } from './Qualified'

export function encodeRootElement(el: RootElement, writer: Writer): void {
	if ('path' in el) {
		encodeQualifedElement(el, writer)
	} else {
		encodeNumberedElement(el, writer)
	}
}

================
File: src/encodings/ber/encoder/StreamDescription.ts
================
import * as Ber from '../../../Ber'
import { StreamDescription, StreamFormat } from '../../../model/StreamDescription'
import { StreamDescriptionBERID } from '../constants'

export function encodeStreamDescription(description: StreamDescription, writer: Ber.Writer): void {
	writer.startSequence(StreamDescriptionBERID)

	writer.writeIfDefined(
		description.format && formatToInt(description.format),
		writer.writeInt,
		0,
		Ber.BERDataTypes.INTEGER
	)
	writer.writeIfDefined(description.offset, writer.writeInt, 1, Ber.BERDataTypes.INTEGER)

	writer.endSequence()
}

function formatToInt(format: StreamFormat): number {
	const formatToInt = {
		[StreamFormat.UInt8]: 0,
		[StreamFormat.UInt16BE]: 2,
		[StreamFormat.UInt16LE]: 3,
		[StreamFormat.UInt32BE]: 4,
		[StreamFormat.UInt32LE]: 5,
		[StreamFormat.UInt64BE]: 6,
		[StreamFormat.UInt64LE]: 7,
		[StreamFormat.Int8]: 8,
		[StreamFormat.Int16BE]: 10,
		[StreamFormat.Int16LE]: 11,
		[StreamFormat.Int32BE]: 12,
		[StreamFormat.Int32LE]: 13,
		[StreamFormat.Int64BE]: 14,
		[StreamFormat.Int64LE]: 15,
		[StreamFormat.Float32BE]: 20,
		[StreamFormat.Float32LE]: 21,
		[StreamFormat.Float64BE]: 22,
		[StreamFormat.Float64LE]: 23,
	}

	return formatToInt[format]
}

================
File: src/encodings/ber/encoder/StreamEntry.ts
================
import * as Ber from '../../../Ber'
import { StreamEntry } from '../../../model/StreamEntry'
import { StreamEntryBERID } from '../constants'

export function encodeStreamEntry(entry: StreamEntry, ber: Ber.Writer): void {
	ber.startSequence(StreamEntryBERID)
	if (entry.identifier !== null) {
		ber.startSequence(Ber.CONTEXT(0))
		ber.writeInt(entry.identifier)
		ber.endSequence()
	}
	if (entry.value !== null) {
		ber.startSequence(Ber.CONTEXT(1))
		ber.writeValue(entry.value)
		ber.endSequence()
	}
	ber.endSequence()
}

================
File: src/encodings/ber/encoder/StringIntegerCollection.ts
================
import * as Ber from '../../../Ber'
import { StringIntegerCollection } from '../../../types/types'
import { StringIntegerCollectionBERID, StringIntegerPairBERID } from '../constants'

export function encodeStringIntegerCollection(collection: StringIntegerCollection, writer: Ber.Writer): void {
	writer.startSequence(StringIntegerCollectionBERID)
	for (const [key, value] of collection) {
		writer.startSequence(Ber.CONTEXT(0))

		writer.startSequence(StringIntegerPairBERID)
		writer.startSequence(Ber.CONTEXT(0))
		writer.writeString(key, Ber.BERDataTypes.STRING)
		writer.endSequence()
		writer.startSequence(Ber.CONTEXT(1))
		writer.writeInt(value)
		writer.endSequence()
		writer.endSequence()

		writer.endSequence()
	}
	writer.endSequence()
}

================
File: src/encodings/ber/encoder/Template.ts
================
import * as Ber from '../../../Ber'
import { Template } from '../../../model/Template'
import { encodeNumberedElement } from './Tree'

export function encodeTemplate(template: Template, writer: Ber.Writer): void {
	if (template.element != null) {
		writer.startSequence(Ber.CONTEXT(1))
		encodeNumberedElement(template.element, writer)
		writer.endSequence()
	}

	if (template.description != null) {
		writer.startSequence(Ber.CONTEXT(2))
		writer.writeString(template.description, Ber.BERDataTypes.STRING)
		writer.endSequence()
	}
}

================
File: src/encodings/ber/encoder/Tree.ts
================
import { NumberedTreeNode, TreeElement, QualifiedElement } from '../../../types/types'
import * as Ber from '../../../Ber'
import { ElementType, EmberElement } from '../../../model/EmberElement'
import { encodeEmberElement } from './EmberElement'
import { encodeCommand } from './Command'
import { encodeTemplate } from './Template'
import { Template } from '../../../model/Template'
import { Matrix } from '../../../model/Matrix'
import { encodeConnection } from './Connection'
import { encodeTarget, encodeSource } from './Matrix'
import {
	MatrixBERID,
	FunctionBERID,
	NodeBERID,
	ParameterBERID,
	TemplateBERID,
	ElementCollectionBERID,
} from '../constants'
import { Connection } from '../../../model/Connection'

export function encodeNumberedElement(el: NumberedTreeNode<EmberElement>, writer: Ber.Writer): void {
	if (el.contents.type === ElementType.Command) {
		// Command is a special case
		if (isQualified(el)) throw new Error('Command cannot be qualified')

		encodeCommand(el.contents, writer)
		return
	}

	switch (el.contents.type) {
		case ElementType.Function:
			writer.startSequence(FunctionBERID)
			break
		case ElementType.Matrix:
			writer.startSequence(MatrixBERID)
			break
		case ElementType.Node:
			writer.startSequence(NodeBERID) // start Node
			break
		case ElementType.Parameter:
			writer.startSequence(ParameterBERID)
			break
		case ElementType.Template:
			writer.startSequence(TemplateBERID)
			break
	}

	writer.startSequence(Ber.CONTEXT(0)) // start number
	writer.writeInt(el.number, Ber.BERDataTypes.INTEGER)
	writer.endSequence()

	encodeTree(el, writer)
}

export function encodeTree(el: TreeElement<EmberElement>, writer: Ber.Writer): void {
	if (isTemplate(el.contents)) {
		encodeTemplate(el.contents, writer)
		writer.endSequence() // end node
		return
	}

	// Encode Contents:
	if (Object.values<any>(el.contents).filter((v) => v !== undefined).length > 1) {
		writer.startSequence(Ber.CONTEXT(1)) // start contents
		encodeEmberElement(el.contents, writer)
		writer.endSequence() // end contents
	}

	if (hasChildren(el)) {
		writer.startSequence(Ber.CONTEXT(2)) // start children
		writer.startSequence(ElementCollectionBERID) // start ElementCollection
		if (el.children) {
			for (const child of Object.values<NumberedTreeNode<EmberElement>>(el.children)) {
				writer.startSequence(Ber.CONTEXT(0)) // start child
				encodeNumberedElement(child, writer)
				writer.endSequence() // end child
			}
		}
		writer.endSequence() // end ElementCollection
		writer.endSequence() // end children
	}

	// Matrix contains some other props as well
	if (isMatrix(el.contents)) {
		// encode targets
		if (el.contents.targets) {
			writer.startSequence(Ber.CONTEXT(3)) // start targets
			writer.startSequence(Ber.BERDataTypes.SEQUENCE) // start sequence
			// write target collection
			for (const target of el.contents.targets) {
				writer.startSequence(Ber.CONTEXT(0)) // start child
				encodeTarget(target, writer)
				writer.endSequence() // end child
			}
			writer.endSequence() // end sequence
			writer.endSequence() // end children
		}
		if (el.contents.sources) {
			writer.startSequence(Ber.CONTEXT(4))
			writer.startSequence(Ber.BERDataTypes.SEQUENCE)
			// write sources collection
			for (const source of el.contents.sources) {
				writer.startSequence(Ber.CONTEXT(0))
				encodeSource(source, writer)
				writer.endSequence()
			}
			writer.endSequence()
			writer.endSequence()
		}
		if (el.contents.connections) {
			writer.startSequence(Ber.CONTEXT(5))
			writer.startSequence(Ber.BERDataTypes.SEQUENCE)
			// write connections collection
			for (const connection of Object.values<Connection>(el.contents.connections as { [target: string]: Connection })) {
				writer.startSequence(Ber.CONTEXT(0))
				encodeConnection(connection, writer)
				writer.endSequence()
			}
			writer.endSequence()
			writer.endSequence()
		}
	}

	writer.endSequence() // end node
}

function hasChildren(el: TreeElement<EmberElement>): boolean {
	return (
		'children' in el &&
		el.children !== undefined &&
		!(el.contents.type === ElementType.Command || el.contents.type === ElementType.Template)
	)
}

function isQualified(el: TreeElement<EmberElement>): el is QualifiedElement<EmberElement> {
	return 'path' in el
}

function isMatrix(el: EmberElement): el is Matrix {
	return el.type === ElementType.Matrix
}

function isTemplate(el: EmberElement): el is Template {
	return el.type === ElementType.Template
}

================
File: src/encodings/ber/constants.ts
================
import * as Ber from '../../Ber'

export {
	RootBERID,
	ParameterBERID,
	CommandBERID,
	NodeBERID,
	ElementCollectionBERID,
	StreamEntryBERID,
	StreamEntriesBERID,
	StringIntegerPairBERID,
	StringIntegerCollectionBERID,
	QualifiedParameterBERID,
	QualifiedNodeBERID,
	RootElementsBERID,
	StreamDescriptionBERID,
	MatrixBERID,
	TargetBERID,
	SourceBERID,
	ConnectionBERID,
	QualifiedMatrixBERID,
	LabelBERID,
	FunctionBERID,
	QualifiedFunctionBERID,
	FunctionArgumentBERID,
	InvocationBERID,
	InvocationResultBERID,
	TemplateBERID,
	QualifiedTemplateBERID,
}

const RootBERID = Ber.APPLICATION(0)
const ParameterBERID = Ber.APPLICATION(1)
const CommandBERID = Ber.APPLICATION(2)
const NodeBERID = Ber.APPLICATION(3)
const ElementCollectionBERID = Ber.APPLICATION(4)
const StreamEntryBERID = Ber.APPLICATION(5)
const StreamEntriesBERID = Ber.APPLICATION(6)
const StringIntegerPairBERID = Ber.APPLICATION(7)
const StringIntegerCollectionBERID = Ber.APPLICATION(8)
const QualifiedParameterBERID = Ber.APPLICATION(9)
const QualifiedNodeBERID = Ber.APPLICATION(10)
const RootElementsBERID = Ber.APPLICATION(11)
const StreamDescriptionBERID = Ber.APPLICATION(12)
const MatrixBERID = Ber.APPLICATION(13)
const TargetBERID = Ber.APPLICATION(14)
const SourceBERID = Ber.APPLICATION(15)
const ConnectionBERID = Ber.APPLICATION(16)
const QualifiedMatrixBERID = Ber.APPLICATION(17)
const LabelBERID = Ber.APPLICATION(18)
const FunctionBERID = Ber.APPLICATION(19)
const QualifiedFunctionBERID = Ber.APPLICATION(20)
const FunctionArgumentBERID = Ber.APPLICATION(21)
const InvocationBERID = Ber.APPLICATION(22)
const InvocationResultBERID = Ber.APPLICATION(23)
const TemplateBERID = Ber.APPLICATION(24)
const QualifiedTemplateBERID = Ber.APPLICATION(25)

================
File: src/encodings/ber/index.ts
================
import { Root, RootType, RootElement, Collection } from '../../types/types'
import * as Ber from '../../Ber'
import { encodeInvocationResult } from './encoder/InvocationResult'
import { InvocationResult } from '../../model/InvocationResult'
import { encodeRootElement } from './encoder/RootElement'
import { StreamEntry } from '../../model/StreamEntry'
import { encodeStreamEntry } from './encoder/StreamEntry'
import { decodeInvocationResult } from './decoder/InvocationResult'
import { decodeRootElements } from './decoder/Tree'
import { decodeStreamEntries } from './decoder/StreamEntry'
import { DecodeResult, DecodeOptions, defaultDecode, unknownApplication, makeResult } from './decoder/DecodeResult'
import { RootBERID, RootElementsBERID, StreamEntriesBERID, InvocationResultBERID } from './constants'
import { NumberedTreeNodeImpl } from '../../model/Tree'
import { EmberNodeImpl } from '../../model/EmberNode'

export { berEncode, berDecode }

function berEncode(el: Root, rootType: RootType): Buffer {
	const writer = new Ber.Writer()
	writer.startSequence(RootBERID) // Start ROOT

	switch (rootType) {
		case RootType.Elements:
			writer.startSequence(RootElementsBERID) // Start RootElementCollection
			for (const rootEl of Object.values<RootElement>(el as Collection<RootElement>)) {
				writer.startSequence(Ber.CONTEXT(0))
				encodeRootElement(rootEl, writer)
				writer.endSequence()
			}
			writer.endSequence() // End RootElementCollection
			break
		case RootType.Streams:
			writer.startSequence(StreamEntriesBERID) // Start StreamCollection
			for (const entry of Object.values<StreamEntry>(el as Collection<StreamEntry>)) {
				writer.startSequence(Ber.CONTEXT(0))
				encodeStreamEntry(entry, writer)
				writer.endSequence()
			}
			writer.endSequence() // End StreamCollection
			break
		case RootType.InvocationResult:
			encodeInvocationResult(el as InvocationResult, writer)
			break
	}

	writer.endSequence() // End ROOT
	return writer.buffer
}

function berDecode(b: Buffer, options: DecodeOptions = defaultDecode): DecodeResult<Root> {
	const reader = new Ber.Reader(b)
	const errors = new Array<Error>()

	const tag = reader.peek()

	if (tag !== RootBERID) {
		unknownApplication(errors, 'decode root', tag, options)
		return makeResult([new NumberedTreeNodeImpl(-1, new EmberNodeImpl())], errors)
	}

	reader.readSequence(tag)
	const rootSeqType = reader.peek()

	if (rootSeqType === RootElementsBERID) {
		// RootElementCollection
		const root: DecodeResult<Collection<RootElement>> = decodeRootElements(reader, options)
		return root
	} else if (rootSeqType === StreamEntriesBERID) {
		// StreamCollection
		const root: DecodeResult<Collection<StreamEntry>> = decodeStreamEntries(reader, options)
		return root
	} else if (rootSeqType === InvocationResultBERID) {
		// InvocationResult
		const root: DecodeResult<InvocationResult> = decodeInvocationResult(reader, options)
		return root
	}

	unknownApplication(errors, 'decode root', rootSeqType, options)
	return makeResult([new NumberedTreeNodeImpl(-1, new EmberNodeImpl())], errors)
}

================
File: src/model/__tests__/EmberElement.test.ts
================
import { ElementType, isEmberElement } from '../EmberElement'

describe('model/EmberElement', () => {
	describe('isEmberElement()', () => {
		describe('non-object inputs', () => {
			test('should fail for null input', () => {
				const actual = isEmberElement(null)

				expect(actual).toBe(false)
			})

			test('should fail for no input', () => {
				// typescript blocks a call with no args, but explicit undefined is just as good
				const actual = isEmberElement(undefined)

				expect(actual).toBe(false)
			})

			test('should fail for string input', () => {
				const actual = isEmberElement('not good enough')

				expect(actual).toBe(false)
			})
		})

		describe('Parameter type', () => {
			test('should be true when number property has a number value', () => {
				const actual = isEmberElement({ type: ElementType.Parameter })

				expect(actual).toBe(true)
			})

			test('should be true when input has no number property', () => {
				const actual = isEmberElement({ type: ElementType.Parameter })

				expect(actual).toBe(true)
			})
		})

		describe('Node type', () => {
			test('should be true when number property has a number value', () => {
				const actual = isEmberElement({ type: ElementType.Node, number: 0 })

				expect(actual).toBe(true)
			})

			test('should be true when input has no number property', () => {
				const actual = isEmberElement({ type: ElementType.Parameter })

				expect(actual).toBe(true)
			})
		})

		describe('Missing/invalid parameter type property', () => {
			test('should fail with invalid type property', () => {
				const actual = isEmberElement({ type: -47, number: 42 })

				expect(actual).toBe(false)
			})

			test('should fail with valid number value', () => {
				const actual = isEmberElement({ number: 0 })

				expect(actual).toBe(false)
			})

			test('should fail with missing number value', () => {
				const actual = isEmberElement({ thisIs: 'irrelevant' })

				expect(actual).toBe(false)
			})

			test('should fail with invalid number value', () => {
				const actual = isEmberElement({ number: 'whatever' })

				expect(actual).toBe(false)
			})
		})
	})
})

================
File: src/model/__tests__/Parameter.test.ts
================
import { isParameter, ParameterType, Parameter } from '../Parameter'
import { ElementType } from '../EmberElement'

describe('model/Parameter', () => {
	describe('isParameter()', () => {
		const validParameter: Parameter = {
			type: ElementType.Parameter,
			parameterType: ParameterType.Integer,
			templateReference: '1',
			// number: 1
			// templateReference: {
			// 	resolve: () => ({ value: { number: 1, type: ElementType.Template } })
			// }
		}

		describe('mandatory properties', () => {
			test('should pass when all mandatory properties are present and their values valid', () => {
				const actual = isParameter(validParameter)

				expect(actual).toBe(true)
			})

			test('should fail when missing type property', () => {
				const invalid = Object.assign({}, validParameter)
				// @ts-expect-error: delete non-optional for robustness testing
				delete invalid.type

				const actual = isParameter(invalid)

				expect(actual).toBe(false)
			})

			test('should fail when type property is not Parameter', () => {
				const invalid: any = Object.assign({}, validParameter, {
					type: ElementType.Node,
				})

				const actual = isParameter(invalid)

				expect(actual).toBe(false)
			})

			test('should fail when missing parameterType property', () => {
				const invalid = Object.assign({}, validParameter)
				// @ts-expect-error: delete non-optional for robustness testing
				delete invalid.parameterType

				const actual = isParameter(invalid)

				expect(actual).toBe(false)
			})

			test('should fail when missing templateReference property', () => {
				const invalid = Object.assign({}, validParameter)
				delete invalid.templateReference

				const actual = isParameter(invalid)

				expect(actual).toBe(false)
			})
		})
	})
})

================
File: src/model/Command.ts
================
import { ElementType, EmberBaseElement } from './EmberElement'
import { Invocation } from './Invocation'

export {
	CommandType,
	FieldFlags,
	Command,
	Subscribe,
	Unsubscribe,
	GetDirectory,
	Invoke,
	SubscribeImpl,
	UnsubscribeImpl,
	GetDirectoryImpl,
	InvokeImpl,
}

enum CommandType {
	Subscribe = 30,
	Unsubscribe = 31,
	GetDirectory = 32,
	Invoke = 33,
}

/** Parameters that a consumer is interested in. */
enum FieldFlags {
	Sparse = 'SPARSE',
	All = 'ALL',
	Default = 'DEFAULT',
	Identifier = 'IDENTIFIER',
	Description = 'DESCRIPTION',
	Tree = 'TREE',
	Value = 'VALUE',
	Connections = 'CONNECTIONS',
}

/**
 *  A command - from a consumer to a provider - may be appended to a node,
 *  parameter or a matrix as child element.
 */
interface Command extends EmberBaseElement {
	type: ElementType.Command
	number: CommandType
}

/**
 *  Subscribe to a stream of updates for a parameter that has a stream identifier.
 *  Parameters with a stream identifier only transmit changes to subscribers.
 */
interface Subscribe extends Command {
	number: CommandType.Subscribe
}

/**
 *  Unsubscribe from a stream of updates for a parameter.
 */
interface Unsubscribe extends Command {
	number: CommandType.Unsubscribe
}

/**
 *  Requests all child nodes and parameters of the node containing the command,
 *  including all attributes of the reported entities.
 */
interface GetDirectory extends Command {
	number: CommandType.GetDirectory
	/** Properties a cosumer is interested in. */
	dirFieldMask?: FieldFlags
}

/**
 *  Invoke a function.
 */
interface Invoke extends Command {
	number: CommandType.Invoke
	/** Identifier and arguments to use to invoke a function. */
	invocation?: Invocation
}

export function isInvoke(command: Command | null): command is Invoke {
	return command !== null && command.number === CommandType.Invoke
}

export function isGetDirectory(command: Command | null): command is GetDirectory {
	return command !== null && command.number === CommandType.GetDirectory
}

abstract class CommandImpl implements Command {
	public abstract number: number
	public type: ElementType.Command = ElementType.Command
	// constructor() {}
}

class SubscribeImpl extends CommandImpl implements Subscribe {
	public readonly number: CommandType.Subscribe = CommandType.Subscribe
	constructor() {
		super()
	}
}

class UnsubscribeImpl extends CommandImpl implements Unsubscribe {
	public readonly number: CommandType.Unsubscribe = CommandType.Unsubscribe
	constructor() {
		super()
	}
}

class GetDirectoryImpl extends CommandImpl implements GetDirectory {
	public readonly number: CommandType.GetDirectory = CommandType.GetDirectory

	constructor(public dirFieldMask?: FieldFlags) {
		super()
	}
}

class InvokeImpl extends CommandImpl implements Invoke {
	public readonly number: CommandType.Invoke = CommandType.Invoke
	constructor(public invocation?: Invocation) {
		super()
	}
}

================
File: src/model/Connection.ts
================
export { Connection, ConnectionDisposition, ConnectionOperation, ConnectionImpl }

/** How to interpret the set of sources in a connection. */
enum ConnectionOperation {
	/** List of sources is absolute. Default. Set on tally for all responses from a provider. */
	Absolute = 'ABSOLUTE',
	/** Consumer request that the sources should be connected to the target. */
	Connect = 'CONNECT',
	/** Consumer requests that the sources should be disconnected from the target. */
	Disconnect = 'DISCONNECT',
}

/** Execution state of a connection operation. */
enum ConnectionDisposition {
	/** Sources is the absolute set of current connections. */
	Tally = 'TALLY',
	/** Connection has changed. Sources property contains absolute set of current connections. */
	Modified = 'MODIFIED',
	/** Connect operation queued and connection is not yet current. */
	Pending = 'PENDING',
	/** Connect operation not executed as the target is locked.
	 *  Sources property contains absolute set of current connections. */
	Locked = 'LOCKED',
}

/**
 *  Description of, or details of request and response to connect or disconnect
 *  a target to some sources.
 */
interface Connection {
	/** Number of the element targeted by the connection. */
	target: number
	/** Numbers of all sources connected to the target. If omitted, there are no active connections. */
	sources?: Array<number>
	/** How to interpret the set of sources. */
	operation?: ConnectionOperation
	/** Indicates the execution state of an connection operation. Response from providers only. */
	disposition?: ConnectionDisposition
}

class ConnectionImpl implements Connection {
	constructor(
		public target: number,
		public sources?: Array<number>,
		public operation?: ConnectionOperation,
		public disposition?: ConnectionDisposition
	) {}
}

================
File: src/model/EmberElement.ts
================
import { Parameter } from './Parameter'
import { EmberFunction } from './EmberFunction'
import { EmberNode } from './EmberNode'
import { Matrix } from './Matrix'
import { Command } from './Command'
import { Template } from './Template'

export { ElementType, EmberElement, EmberBaseElement, isEmberElement }

/** Type specifyer for ember elements. */
enum ElementType {
	Parameter = 'PARAMETER',
	Node = 'NODE',
	Command = 'COMMAND',
	Matrix = 'MATRIX',
	Function = 'FUNCTION',
	Template = 'TEMPLATE',
}

type EmberElement = Command | EmberFunction | EmberNode | Matrix | Parameter | Template
/** Generic type for all ember elements. */
interface EmberBaseElement {
	type: ElementType
}

function isEmberElement(obj: unknown): obj is EmberElement {
	if (obj === undefined || obj === null) {
		return false
	}

	if (!(typeof obj === 'object' && 'type' in obj)) return false

	const { type } = obj as { type: unknown }

	if (!type || !Object.values<ElementType>(ElementType).includes(type as any)) {
		return false
	}

	return true
}

================
File: src/model/EmberFunction.ts
================
import { EmberBaseElement, ElementType } from './EmberElement'
import { FunctionArgument } from './FunctionArgument'
import { RelativeOID } from '../types/types'

export { EmberFunction, EmberFunctionImpl }

/**
 *  Function call.  A means to make a remote procedure call throug the Ember
 *  interface. Function are invoked using the [Invoke] command.
 */
interface EmberFunction extends EmberBaseElement {
	type: ElementType.Function
	/** Name. */
	identifier?: string
	/** Display name. */
	description?: string
	/** Function arguments by name and type. */
	args?: Array<FunctionArgument>
	/** Function results by name and type. */
	result?: Array<FunctionArgument>
	/** Definition of the elements default structure. */
	templateReference?: RelativeOID
}

class EmberFunctionImpl implements EmberFunction {
	public readonly type: ElementType.Function = ElementType.Function
	constructor(
		public identifier?: string,
		public description?: string,
		public args?: Array<FunctionArgument>,
		public result?: Array<FunctionArgument>,
		public templateReference?: RelativeOID
	) {}
}

================
File: src/model/EmberNode.ts
================
import { EmberBaseElement, ElementType } from './EmberElement'
import { RelativeOID } from '../types/types'

export { EmberNode, EmberNodeImpl }

/**
 *  A node represents a device or one of its components. Like the parameter,
 *  it must contain a number which identifies the node while the session is active.
 */
interface EmberNode extends EmberBaseElement {
	type: ElementType.Node
	/** Name of the node, unique within the current context. */
	identifier?: string
	/** Display name of a node, displayed by a UI. */
	description?: string
	/** True if the current node is a root node. */
	isRoot?: boolean
	/** True if node is online, the default. If offline, all children are also offline. */
	isOnline?: boolean
	/** List of schemas that the sub-tree under this node complies with. `\n` separators. */
	schemaIdentifiers?: string
	/** Path of a template containing structure and defaults of this element. */
	templateReference?: RelativeOID
}

class EmberNodeImpl implements EmberNode {
	public readonly type: ElementType.Node = ElementType.Node
	constructor(
		public identifier?: string,
		public description?: string,
		public isRoot?: boolean,
		public isOnline?: boolean,
		public schemaIdentifiers?: string,
		public templateReference?: RelativeOID
	) {}
}

================
File: src/model/FunctionArgument.ts
================
import { ParameterType } from './Parameter'

export { FunctionArgument, FunctionArgumentImpl }

/**
 *  Description of an argument of a function.
 */
interface FunctionArgument {
	/** Type. */
	type: ParameterType
	/** Name. May be omitted if function takes only one argument. */

	name?: string
}

class FunctionArgumentImpl implements FunctionArgument {
	constructor(public type: ParameterType, public name?: string) {}
}

================
File: src/model/index.ts
================
import { EmberElement, ElementType } from './EmberElement'
import { EmberFunction, EmberFunctionImpl } from './EmberFunction'
import { EmberNode, EmberNodeImpl } from './EmberNode'
import { FunctionArgument, FunctionArgumentImpl } from './FunctionArgument'
import { Invocation } from './Invocation'
import { InvocationResult } from './InvocationResult'
import { Label } from './Label'
import { Matrix, MatrixType, MatrixAddressingMode, Connections, MatrixImpl } from './Matrix'
import { Parameter, ParameterType, ParameterAccess, ParameterImpl } from './Parameter'
import { StreamDescription, StreamFormat } from './StreamDescription'
import { StreamEntry } from './StreamEntry'
import { Template, TemplateImpl } from './Template'
import { TreeElement, NumberedTreeNode, QualifiedElement, NumberedTreeNodeImpl, QualifiedElementImpl } from './Tree'

export {
	EmberElement,
	ElementType,
	EmberFunction,
	EmberFunctionImpl,
	EmberNode,
	EmberNodeImpl,
	FunctionArgument,
	FunctionArgumentImpl,
	Invocation,
	InvocationResult,
	Label,
	Matrix,
	MatrixType,
	MatrixAddressingMode,
	Connections,
	MatrixImpl,
	Parameter,
	ParameterType,
	ParameterAccess,
	ParameterImpl,
	StreamDescription,
	StreamFormat,
	StreamEntry,
	Template,
	TemplateImpl,
	TreeElement,
	NumberedTreeNode,
	QualifiedElement,
	NumberedTreeNodeImpl,
	QualifiedElementImpl,
}

================
File: src/model/Invocation.ts
================
import { EmberTypedValue } from '../types/types'

export { Invocation, InvocationImpl }

/**
 *  Part of a consumer's command that requests the invocation of the parent function
 *  by a provider.
 */
interface Invocation {
	/** Identifier generated by the consumer and used to link invocations to their
	 *  invocation results. */
	id?: number
	/** Values of the arguments associated with the funtion. */
	args: Array<EmberTypedValue>
}

class InvocationImpl implements Invocation {
	constructor(public id: number | undefined, public args: Array<EmberTypedValue>) {}
}

================
File: src/model/InvocationResult.ts
================
import { EmberTypedValue } from '../types/types'

export { InvocationResult, InvocationResultImpl }

/**
 *  Result of a function invocation, sent from provider to consumer.
 */
interface InvocationResult {
	/** Matches the invocation identifier */
	id: number
	/** True if no errors were encountered when executing the function. */
	success?: boolean
	/** Return value of the function call, matching the expected result tyoes. */
	result?: Array<EmberTypedValue>
}

class InvocationResultImpl implements InvocationResult {
	constructor(public id: number, public success?: boolean, public result?: Array<EmberTypedValue>) {}
}

================
File: src/model/Label.ts
================
import { RelativeOID } from '../types/types'

export { Label, LabelImpl }

/** Labelled nodes. */
interface Label {
	/** Absolute path to a node under which label parameters associated with signals reside. */
	basePath: RelativeOID
	/** Free-text description of the label. Used by consumers to let the user choose the label to display. */
	description: string
}

class LabelImpl implements Label {
	constructor(public basePath: string, public description: string) {}
}

================
File: src/model/Matrix.ts
================
import { EmberBaseElement, ElementType } from './EmberElement'
import { Connection } from './Connection'
import { Label } from './Label'
import { RelativeOID } from '../types/types'

export { Matrix, MatrixType, MatrixAddressingMode, Connections, MatrixImpl }

/**
 *  Type of a matrix.
 */
enum MatrixType {
	/** One source may be connected to n targets, but each target must not be
	 *  connected to more than one source. */
	OneToN = 'ONE_TO_N',
	/** One source may be connected to only one target, and each target must
	 *  not be connected to more than one source. */
	OneToOne = 'ONE_TO_ONE',
	/** A source may be connected to n targets, and a target may have n sources
	 *  connected to it. */
	NToN = 'N_TO_N',
}

/**
 *  Addressing mode for a matrix.
 */
enum MatrixAddressingMode {
	/** Signal numbers are row/column indices. */
	Linear = 'LINEAR',
	/** Signal numbers are random. */
	NonLinear = 'NON_LINEAR',
}

/**
 *  Dictionary or targets, indexed by element number.
 */
interface Connections {
	[target: number]: Connection
}

/**
 *  A two-dimensional array of Boolean values used for eg. signal routing, bus
 *  assignments on mixing consoles etc..
 */
interface Matrix extends EmberBaseElement {
	type: ElementType.Matrix
	/** Target objects, the columns of the matrix. */
	targets?: Array<number>
	/** Source objects, the row of the matric. */
	sources?: Array<number>
	/** Describes the targets active connections. */
	connections?: Connections
	/** Name. */
	identifier: string
	/** Display name. */
	description?: string
	/** Matrix type. */
	matrixType?: MatrixType
	/** Matrix adressing mode. */
	addressingMode?: MatrixAddressingMode
	/** Linear matrix: number of columns. Nonlinear matrix: number of targets. */
	targetCount?: number
	/** Linear matirx: number of rows. Nonlinear matrix: number of sources. */
	sourceCount?: number
	/** For n-to-n matrices, the maximum number of total connections. */
	maximumTotalConnects?: number
	/** For n-to-n matrices, maximum number of sources for any single target. */
	maximumConnectsPerTarget?: number
	/** Reference to parameters associated with signals, e.g. relative levels. */
	parametersLocation?: RelativeOID | number
	/** For n-to-n matrices, element number of the parameter for gain or ration
	 *  of a connection. */
	gainParameterNumber?: number
	/** Labels for signals. */
	labels?: Array<Label>
	/** List of schemas that the matrix complies with. `\n` separators. */
	schemaIdentifiers?: string
	/** Path of a template containing structure and defaults of this element. */
	templateReference?: RelativeOID
}

class MatrixImpl implements Matrix {
	public readonly type: ElementType.Matrix = ElementType.Matrix
	constructor(
		public identifier: string,
		public targets?: Array<number>,
		public sources?: Array<number>,
		public connections?: Connections,
		public description?: string,
		public matrixType?: MatrixType,
		public addressingMode?: MatrixAddressingMode,
		public targetCount?: number,
		public sourceCount?: number,
		public maximumTotalConnects?: number,
		public maximumConnectsPerTarget?: number,
		public parametersLocation?: RelativeOID | number,
		public gainParameterNumber?: number,
		public labels?: Array<Label>,
		public schemaIdentifiers?: string,
		public templateReference?: RelativeOID
	) {}
}

================
File: src/model/Parameter.ts
================
import { EmberBaseElement, ElementType, isEmberElement } from './EmberElement'
import { EmberValue, MinMax, StringIntegerCollection, RelativeOID } from '../types/types'
import { StreamDescription } from './StreamDescription'

export { Parameter, ParameterType, ParameterAccess, isParameter, ParameterImpl }

enum ParameterType {
	Null = 'NULL',
	Integer = 'INTEGER',
	Real = 'REAL',
	String = 'STRING',
	Boolean = 'BOOLEAN',
	Trigger = 'TRIGGER',
	Enum = 'ENUM',
	Octets = 'OCTETS',
}

enum ParameterAccess {
	None = 'NONE',
	Read = 'READ',
	Write = 'WRITE',
	ReadWrite = 'READ_WRITE',
}

// TODO break down further by ParamterType?
/**
 *  An entity that contains a value.
 *
 *  A value may be _null_, allowing a provider to inform a consumer that a value
 *  is not currently present.
 */
interface Parameter extends EmberBaseElement {
	type: ElementType.Parameter
	/** Hint to the parameter's type. */
	parameterType: ParameterType
	/** Name. Must be unique within the current scope. */
	identifier?: string
	/** Display name. Used for UI presentation. */
	description?: string
	/** Current value. Must be integer, real or string. Enumerations are converted to 0-based indexes. */
	value?: EmberValue
	/** Largest allowed value. */
	maximum?: MinMax
	/** Smallest allowed value. */
	minimum?: MinMax
	/** Permitted access. */
	access?: ParameterAccess
	/** C-style format string to e.g. append a unit, control number of digits displayed etc.. */
	format?: string
	/** List of enumeration value names, separated by line feed `\n`. */
	enumeration?: string
	/** For a device unable to process decimal values, a factor may be used.
	 *  The consumer then has to divide the reported value when it displays it
	 *  and multiply it with this factor when it wants to change the parameter.
	 */
	factor?: number // Integer32
	/** True if the parameter's node is online. */

	isOnline?: boolean
	/** Transform a paramter value to its displayed form. Two formulas must be
	 *  provided, separated by a linefeed `\n`, the first from prvider to consumer
	 *  and the seconds from consumer to provider.
	 */
	formula?: string
	/** Incrementing and decrementing step. (Deprecated - use factor instead.) */
	step?: number // Integer32
	/** Default value. */
	defaultValue?: EmberValue
	/** Identifies an audio level meter, or any other frequently changing data stream. */
	streamIdentifier?: number // BER readInt
	/** Detailed description of an enumeration. */
	enumMap?: StringIntegerCollection
	/** For streams where each value has more than one component. */
	streamDescriptor?: StreamDescription
	schemaIdentifiers?: string
	templateReference?: RelativeOID
}

/**
 * Type predicate for Parameter interface.
 * TODO: write tests for actual values and optional properties
 *
 * @param obj - object to check
 * @returns true if object is a valid Parameter, false if not
 */
function isParameter(obj: unknown): obj is Parameter {
	if (!isEmberElement(obj)) {
		return false
	}

	const { type, parameterType, templateReference } = obj as any
	if (type !== ElementType.Parameter) {
		return false
	}

	if (!parameterType || !templateReference) {
		return false
	}

	return true
}

class ParameterImpl implements Parameter {
	public readonly type: ElementType.Parameter = ElementType.Parameter
	constructor(
		public parameterType: ParameterType,
		public identifier?: string,
		public description?: string,
		public value?: EmberValue,
		public maximum?: MinMax,
		public minimum?: MinMax,
		public access?: ParameterAccess,
		public format?: string,
		public enumeration?: string,
		public factor?: number, // Integer32
		public isOnline?: boolean,
		public formula?: string,
		public step?: number, // Integer32
		public defaultValue?: EmberValue,
		public streamIdentifier?: number, // BER readInt
		public enumMap?: StringIntegerCollection,
		public streamDescriptor?: StreamDescription,
		public schemaIdentifiers?: string,
		public templateReference?: RelativeOID
	) {}
}

================
File: src/model/StreamDescription.ts
================
export { StreamDescription, StreamFormat }

enum StreamFormat {
	UInt8 = 'UInt8',
	UInt16BE = 'UInt16BE',
	UInt16LE = 'UInt16LE',
	UInt32BE = 'UInt32BE',
	UInt32LE = 'UInt32LE',
	UInt64BE = 'UInt64BE',
	UInt64LE = 'UInt64LE',
	Int8 = 'Int8',
	Int16BE = 'Int16BE',
	Int16LE = 'Int16LE',
	Int32BE = 'Int32BE',
	Int32LE = 'Int32LE',
	Int64BE = 'Int64BE',
	Int64LE = 'Int64LE',
	Float32BE = 'Float32BE',
	Float32LE = 'Float32LE',
	Float64BE = 'Float64BE',
	Float64LE = 'Float64LE',
}

interface StreamDescription {
	format: StreamFormat
	offset: number // Integer32
}

export class StreamDescriptionImpl implements StreamDescription {
	constructor(public format: StreamFormat, public offset: number) {}
}

================
File: src/model/StreamEntry.ts
================
import { EmberTypedValue } from '../types/types'

export { StreamEntry }

interface StreamEntry {
	identifier: number // Integer32
	value: EmberTypedValue // not null
}

export class StreamEntryImpl implements StreamEntry {
	constructor(public identifier: number, public value: EmberTypedValue) {}
}

================
File: src/model/Template.ts
================
import { ElementType, EmberBaseElement } from './EmberElement'
import { Parameter } from './Parameter'
import { Matrix } from './Matrix'
import { EmberFunction } from './EmberFunction'
import { EmberNode } from './EmberNode'
import { NumberedTreeNode } from '../types/types'

export { Template, TemplateImpl }

/**
 *  Common set of parameters, attributes and sub-trees that can be referred to
 *  by other elements.
 */
interface Template extends EmberBaseElement {
	type: ElementType.Template
	/** Templated properties. */
	element?: NumberedTreeNode<Parameter | EmberNode | Matrix | EmberFunction>
	/** Details of the template. */
	description?: string
}

class TemplateImpl implements Template {
	public readonly type: ElementType.Template = ElementType.Template
	constructor(
		public element?: NumberedTreeNode<Parameter | EmberNode | Matrix | EmberFunction>,
		public description?: string
	) {}
}

================
File: src/model/Tree.ts
================
import { EmberElement } from './EmberElement'
import { RelativeOID, RootElement, Collection } from '../types/types'

export { TreeElement, NumberedTreeNode, QualifiedElement, NumberedTreeNodeImpl, QualifiedElementImpl }

interface TreeElement<T extends EmberElement> {
	parent?: RootElement
	contents: T
	children?: Collection<NumberedTreeNode<EmberElement>>
}

interface NumberedTreeNode<T extends EmberElement> extends TreeElement<T> {
	number: number
}

interface QualifiedElement<T extends EmberElement> extends TreeElement<T> {
	path: RelativeOID
	parent: undefined
}

abstract class TreeElementImpl<T extends EmberElement> implements TreeElement<T> {
	constructor(
		public contents: T,
		public children?: Collection<NumberedTreeNode<EmberElement>>,
		public parent?: RootElement
	) {}
}

class NumberedTreeNodeImpl<T extends EmberElement> extends TreeElementImpl<T> implements NumberedTreeNode<T> {
	constructor(
		public number: number,
		contents: T,
		children?: Collection<NumberedTreeNode<EmberElement>>,
		parent?: RootElement
	) {
		super(contents, children, parent)
	}
}

class QualifiedElementImpl<T extends EmberElement> extends TreeElementImpl<T> implements QualifiedElement<T> {
	parent = undefined

	constructor(public path: RelativeOID, contents: T, children?: Collection<NumberedTreeNode<EmberElement>>) {
		super(contents, children)
	}
}

================
File: src/S101/index.ts
================
import S101Codec from './S101Codec'

export { S101Codec }

================
File: src/S101/S101Codec.ts
================
import { EventEmitter } from 'eventemitter3'
import { SmartBuffer } from 'smart-buffer'
import Debug from 'debug'
import { format } from 'util'
import { berDecode } from '../encodings/ber'

const debug = Debug('emberplus-connection:S101Codec')

const S101_BOF = 0xfe
const S101_EOF = 0xff
const S101_CE = 0xfd
const S101_XOR = 0x20
const S101_INV = 0xf8

const SLOT = 0x00

const MSG_EMBER = 0x0e

const CMD_EMBER = 0x00
const CMD_KEEPALIVE_REQ = 0x01
const CMD_KEEPALIVE_RESP = 0x02

const VERSION = 0x01

const FLAG_SINGLE_PACKET = 0xc0
const FLAG_FIRST_MULTI_PACKET = 0x80
const FLAG_LAST_MULTI_PACKET = 0x40
const FLAG_EMPTY_PACKET = 0x20
const FLAG_MULTI_PACKET = 0x00

const DTD_GLOW = 0x01
const DTD_VERSION_MAJOR = 0x02
const DTD_VERSION_MINOR = 0x1f

const CRC_TABLE = [
	0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf, 0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5,
	0xe97e, 0xf8f7, 0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e, 0x9cc9, 0x8d40, 0xbfdb, 0xae52,
	0xdaed, 0xcb64, 0xf9ff, 0xe876, 0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd, 0xad4a, 0xbcc3,
	0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5, 0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
	0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974, 0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9,
	0x2732, 0x36bb, 0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3, 0x5285, 0x430c, 0x7197, 0x601e,
	0x14a1, 0x0528, 0x37b3, 0x263a, 0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72, 0x6306, 0x728f,
	0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9, 0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
	0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738, 0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862,
	0x9af9, 0x8b70, 0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7, 0x0840, 0x19c9, 0x2b52, 0x3adb,
	0x4e64, 0x5fed, 0x6d76, 0x7cff, 0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036, 0x18c1, 0x0948,
	0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e, 0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
	0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd, 0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226,
	0xd0bd, 0xc134, 0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c, 0xc60c, 0xd785, 0xe51e, 0xf497,
	0x8028, 0x91a1, 0xa33a, 0xb2b3, 0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb, 0xd68d, 0xc704,
	0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232, 0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
	0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1, 0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb,
	0x0e70, 0x1ff9, 0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330, 0x7bc7, 0x6a4e, 0x58d5, 0x495c,
	0x3de3, 0x2c6a, 0x1ef1, 0x0f78,
]

export type S101CodecEvents = {
	emberPacket: [packet: Buffer]
	emberStreamPacket: [packet: Buffer]
	keepaliveReq: []
	keepaliveResp: []
}

export default class S101Codec extends EventEmitter<S101CodecEvents> {
	inbuf = new SmartBuffer()
	emberbuf = new SmartBuffer()
	escaped = false

	private multiPacketBuffer?: SmartBuffer
	private isMultiPacket = false

	dataIn(buf: Buffer): void {
		for (let i = 0; i < buf.length; i++) {
			const b = buf.readUInt8(i)
			if (this.escaped) {
				this.inbuf.writeUInt8(b ^ S101_XOR)
				this.escaped = false
			} else if (b === S101_CE) {
				this.escaped = true
			} else if (b === S101_BOF) {
				this.inbuf.clear()
				this.escaped = false
			} else if (b === S101_EOF) {
				this.inbuf.moveTo(0)
				this.handleFrame(this.inbuf)
				this.inbuf.clear()
			} else {
				this.inbuf.writeUInt8(b)
			}
		}
	}

	handleFrame(frame: SmartBuffer): void {
		if (!this.validateFrame(frame.toBuffer())) {
			throw new Error(format('dropping frame of length %d with invalid CRC', frame.length))
		}

		const slot = frame.readUInt8()
		const message = frame.readUInt8()
		if (slot != SLOT || message != MSG_EMBER) {
			throw new Error(
				format('dropping frame of length %d (not an ember frame; slot=%d, msg=%d)', frame.length, slot, message)
			)
		}

		const command = frame.readUInt8()
		if (command === CMD_KEEPALIVE_REQ) {
			debug('received keepalive request')
			this.emit('keepaliveReq')
		} else if (command === CMD_KEEPALIVE_RESP) {
			debug('received keepalive response')
			this.emit('keepaliveResp')
		} else if (command === CMD_EMBER) {
			const remainingData = frame.readBuffer()
			const emberFrame = SmartBuffer.fromBuffer(remainingData)
			this.handleEmberFrame(emberFrame)
		} else {
			throw new Error(format('dropping frame of length %d with unknown command %d', frame.length, command))
		}
	}

	handleEmberFrame(frame: SmartBuffer): void {
		const version = frame.readUInt8()
		const flags = frame.readUInt8()
		const dtd = frame.readUInt8()
		let appBytes = frame.readUInt8()

		if (version !== VERSION) {
			debug('Warning: Unknown ember frame version %d', version)
		}

		if (dtd !== DTD_GLOW) {
			// Don't throw, just warn and continue processing
			debug('Warning: Received frame with DTD %d, expected %d', dtd, DTD_GLOW)
		}

		if (appBytes < 2) {
			debug('Warning: Frame missing Glow DTD version')
			frame.skip(appBytes)
		} else {
			frame.skip(1) // Skip minor version
			frame.skip(1) // Skip major version
			appBytes -= 2
			if (appBytes > 0) {
				frame.skip(appBytes)
				debug('Warning: App bytes with unknown meaning left over')
			}
		}

		let payload = frame.readBuffer()
		payload = payload.slice(0, payload.length - 2) // Remove CRC

		if ((flags & FLAG_SINGLE_PACKET) === FLAG_SINGLE_PACKET) {
			if ((flags & FLAG_EMPTY_PACKET) === 0) {
				this.handleEmberPacket(payload)
			}
		} else {
			// Multi-packet handling
			if ((flags & FLAG_FIRST_MULTI_PACKET) === FLAG_FIRST_MULTI_PACKET) {
				debug('multi ember packet start')
				this.multiPacketBuffer = new SmartBuffer()
				this.isMultiPacket = true
				this.multiPacketBuffer.writeBuffer(payload)
			} else if (this.isMultiPacket && this.multiPacketBuffer) {
				this.multiPacketBuffer.writeBuffer(payload)

				if ((flags & FLAG_LAST_MULTI_PACKET) === FLAG_LAST_MULTI_PACKET) {
					debug('multi ember packet end')
					const completeData = this.multiPacketBuffer.toBuffer()
					// Check if this is a stream packet, can also be a normal packet
					if (completeData[0] === 0x60 && completeData[2] === 0x66) {
						this.handleEmberStreamPacket(completeData)
					} else {
						this.handleEmberPacket(completeData)
					}
					this.resetMultiPacketBuffer()
				}
			}
		}
	}

	private handleEmberPacket(data: Buffer): void {
		try {
			const decoded = berDecode(data)
			if (data[0] === 0x60) {
				// Root tag check
				if (decoded.value) {
					this.emit('emberPacket', data)
				}
			}
		} catch (error) {
			console.error('Error decoding packet:', error)
		}
	}

	private handleEmberStreamPacket(data: Buffer): void {
		try {
			const decoded = berDecode(data)
			if (data[0] === 0x60 && data[2] === 0x66) {
				// Root and stream tag check
				if (decoded.value) {
					this.emit('emberStreamPacket', data)
				}
			}
		} catch (error) {
			console.error('Error decoding stream packet:', error)
			this.resetMultiPacketBuffer()
		}
	}

	resetMultiPacketBuffer(): void {
		this.multiPacketBuffer = undefined
		this.isMultiPacket = false
	}

	encodeBER(data: Buffer): Buffer[] {
		const frames = []
		const encbuf = new SmartBuffer()
		for (let i = 0; i < data.length; i++) {
			const b = data.readUInt8(i)
			if (b < S101_INV) {
				encbuf.writeUInt8(b)
			} else {
				encbuf.writeUInt8(S101_CE)
				encbuf.writeUInt8(b ^ S101_XOR)
			}

			if (encbuf.length >= 1024 && i < data.length - 1) {
				if (frames.length === 0) {
					frames.push(this._makeBERFrame(FLAG_FIRST_MULTI_PACKET, encbuf.toBuffer()))
				} else {
					frames.push(this._makeBERFrame(FLAG_MULTI_PACKET, encbuf.toBuffer()))
				}
				encbuf.clear()
			}
		}

		if (frames.length == 0) {
			frames.push(this._makeBERFrame(FLAG_SINGLE_PACKET, encbuf.toBuffer()))
		} else {
			frames.push(this._makeBERFrame(FLAG_LAST_MULTI_PACKET, encbuf.toBuffer()))
		}

		return frames
	}

	keepAliveRequest(): Buffer {
		const packet = new SmartBuffer()
		packet.writeUInt8(S101_BOF)
		packet.writeUInt8(SLOT)
		packet.writeUInt8(MSG_EMBER)
		packet.writeUInt8(CMD_KEEPALIVE_REQ)
		packet.writeUInt8(VERSION)
		return this._finalizeBuffer(packet)
	}

	keepAliveResponse(): Buffer {
		const packet = new SmartBuffer()
		packet.writeUInt8(S101_BOF)
		packet.writeUInt8(SLOT)
		packet.writeUInt8(MSG_EMBER)
		packet.writeUInt8(CMD_KEEPALIVE_RESP)
		packet.writeUInt8(VERSION)
		return this._finalizeBuffer(packet)
	}

	validateFrame(buf: Buffer): boolean {
		return this._calculateCRC(buf) == 0xf0b8
	}

	private _makeBERFrame(flags: number, data: Buffer) {
		const frame = new SmartBuffer()
		frame.writeUInt8(S101_BOF)
		frame.writeUInt8(SLOT)
		frame.writeUInt8(MSG_EMBER)
		frame.writeUInt8(CMD_EMBER)
		frame.writeUInt8(VERSION)
		frame.writeUInt8(flags)
		frame.writeUInt8(DTD_GLOW)
		frame.writeUInt8(2) // number of app bytes
		frame.writeUInt8(DTD_VERSION_MINOR)
		frame.writeUInt8(DTD_VERSION_MAJOR)
		frame.writeBuffer(data)
		return this._finalizeBuffer(frame)
	}

	private _finalizeBuffer(smartbuf: SmartBuffer) {
		const crc = ~this._calculateCRCCE(smartbuf.toBuffer().slice(1, smartbuf.length)) & 0xffff
		const crcHi = crc >> 8
		const crcLo = crc & 0xff

		if (crcLo < S101_INV) {
			smartbuf.writeUInt8(crcLo)
		} else {
			smartbuf.writeUInt8(S101_CE)
			smartbuf.writeUInt8(crcLo ^ S101_XOR)
		}

		if (crcHi < S101_INV) {
			smartbuf.writeUInt8(crcHi)
		} else {
			smartbuf.writeUInt8(S101_CE)
			smartbuf.writeUInt8(crcHi ^ S101_XOR)
		}

		smartbuf.writeUInt8(S101_EOF)
		return smartbuf.toBuffer()
	}

	private _calculateCRC(buf: Buffer) {
		let crc = 0xffff
		for (let i = 0; i < buf.length; i++) {
			const b = buf.readUInt8(i)
			crc = ((crc >> 8) ^ CRC_TABLE[(crc ^ b) & 0xff]) & 0xffff
		}
		return crc
	}

	private _calculateCRCCE(buf: Buffer) {
		let crc = 0xffff
		for (let i = 0; i < buf.length; i++) {
			let b = buf.readUInt8(i)
			if (b == S101_CE) {
				b = S101_XOR ^ buf.readUInt8(++i)
			}
			crc = ((crc >> 8) ^ CRC_TABLE[(crc ^ b) & 0xff]) & 0xffff
		}
		return crc
	}
}

================
File: src/types/index.ts
================
import {
	EmberTreeNode,
	EmberValue,
	EmberTypedValue,
	Root,
	RootElement,
	MinMax,
	StringIntegerCollection,
	RootType,
	RelativeOID,
} from './types'

export {
	EmberTreeNode,
	EmberValue,
	EmberTypedValue,
	Root,
	RootElement,
	MinMax,
	StringIntegerCollection,
	RootType,
	RelativeOID,
}

================
File: src/types/types.ts
================
import { EmberElement } from '../model/EmberElement'
import { EmberFunction } from '../model/EmberFunction'
import { Parameter, ParameterType } from '../model/Parameter'
import { Template } from '../model/Template'
import { Matrix } from '../model/Matrix'
import { EmberNode } from '../model/EmberNode'
import { StreamEntry } from '../model/StreamEntry'
import { InvocationResult } from '../model/InvocationResult'
import { TreeElement, NumberedTreeNode, QualifiedElement } from '../model/Tree'

export {
	TreeElement,
	NumberedTreeNode,
	QualifiedElement,
	EmberTreeNode,
	EmberValue,
	EmberTypedValue,
	Root,
	RootElement,
	MinMax,
	StringIntegerCollection,
	RootType,
	RelativeOID,
	literal,
	Collection,
}

type EmberTreeNode<T extends EmberElement> = NumberedTreeNode<T>
type RootElement =
	| NumberedTreeNode<EmberElement>
	| QualifiedElement<Parameter>
	| QualifiedElement<EmberNode>
	| QualifiedElement<Matrix>
	| QualifiedElement<EmberFunction>
	| QualifiedElement<Template>
type Root = Collection<RootElement> | Collection<StreamEntry> | InvocationResult

enum RootType {
	Elements,
	Streams,
	InvocationResult,
}

// number is either Integer64 or REAL
type EmberValue = number | string | boolean | Buffer | null
interface EmberTypedValue {
	type: ParameterType
	value: EmberValue
}

type MinMax = number | null
type StringIntegerCollection = Map<string, number>
type RelativeOID = string

function literal<T>(arg: T): T {
	return arg
}

type Collection<T> = { [index: number]: T }

================
File: src/Errors.ts
================
export {
	UnimplementedEmberTypeError,
	InvalidEmberNode,
	InvalidRequestFormat,
	InvalidEmberResponse,
	InvalidRequest,
	InvalidSourcesFormat,
	UnknownElement,
	MissingElementContents,
	MissingElementNumber,
	InvalidCommand,
	EmberTimeoutError,
	EmberAccessError,
	ASN1Error,
	S101SocketError,
	InvalidBERFormat,
	InvalidResultFormat,
	InvalidMatrixSignal,
	InvalidRequesrFormat,
	InvalidStringPair,
	PathDiscoveryFailure,
}

class UnimplementedEmberTypeError extends Error {
	constructor(tag: number) {
		super()
		this.name = this.constructor.name
		const identifier = (tag & 0xc0) >> 6
		const value = (tag & 0x1f).toString()
		let tagStr = tag.toString()
		if (identifier == 0) {
			tagStr = '[UNIVERSAL ' + value + ']'
		} else if (identifier == 1) {
			tagStr = '[APPLICATION ' + value + ']'
		} else if (identifier == 2) {
			tagStr = '[CONTEXT ' + value + ']'
		} else {
			tagStr = '[PRIVATE ' + value + ']'
		}
		this.message = 'Unimplemented EmBER type ' + tagStr
	}
}

class S101SocketError extends Error {
	constructor(message: string | undefined) {
		super(message)
	}
}

class ASN1Error extends Error {
	constructor(message: string | undefined) {
		super(message)
	}
}

class EmberAccessError extends Error {
	constructor(message: string | undefined) {
		super(message)
	}
}

class EmberTimeoutError extends Error {
	constructor(message: string | undefined) {
		super(message)
	}
}

class InvalidCommand extends Error {
	constructor(number: number) {
		super(`Invalid command ${number}`)
	}
}

class MissingElementNumber extends Error {
	constructor() {
		super('Missing element number')
	}
}

class MissingElementContents extends Error {
	constructor(path: string) {
		super(`Missing element contents at ${path}`)
	}
}

class UnknownElement extends Error {
	constructor(path: string) {
		super(`No element at path ${path}`)
	}
}

class InvalidRequest extends Error {
	constructor() {
		super('Invalid Request')
	}
}

class InvalidRequestFormat extends Error {
	constructor(path: string) {
		super(`Invalid Request Format with path ${path}`)
	}
}

class InvalidEmberNode extends Error {
	constructor(path = 'unknown', info = '') {
		super(`Invalid Ember Node at ${path}: ${info}`)
	}
}

class InvalidEmberResponse extends Error {
	constructor(req: string) {
		super(`Invalid Ember Response to ${req}`)
	}
}

class PathDiscoveryFailure extends Error {
	constructor(path: string) {
		super(PathDiscoveryFailure.getMessage(path))
	}

	setPath(path: string): void {
		this.message = PathDiscoveryFailure.getMessage(path)
	}

	static getMessage(path: string): string {
		return `Failed path discovery at ${path}`
	}
}

class InvalidSourcesFormat extends Error {
	constructor() {
		super('Sources should be an array')
	}
}

class InvalidBERFormat extends Error {
	/**
	 *
	 * @param {string} info
	 */
	constructor(info = '') {
		super(`Invalid BER format: ${info}`)
	}
}

class InvalidResultFormat extends Error {
	constructor(info = '') {
		super(`Invalid Result format: ${info}`)
	}
}

class InvalidMatrixSignal extends Error {
	constructor(value: number, info: string) {
		super(`Invalid Matrix Signal ${value}: ${info}`)
	}
}

class InvalidStringPair extends Error {
	constructor() {
		super('Invalid StringPair Value')
	}
}

class InvalidRequesrFormat extends Error {
	constructor(path: string) {
		super(`Can't process request for node ${path}`)
	}
}

================
File: src/index.ts
================
import { EmberClient, EmberClientEvents } from './Ember/Client/index'
import { EmberLib } from './Ember/Lib/index'
import { EmberServer, EmberServerEvents } from './Ember/Server/index'
import { S101Codec } from './S101/index'
import { S101Client } from './Ember/Socket/index'
// import { EmberTreeNode, TreeElement } from './types/types'
import { berEncode, berDecode } from './encodings/ber/index'
// import { EmberElement } from './model/EmberElement'

// import {
// 	EmberTreeNode,
// 	EmberValue,
// 	EmberTypedValue,
// 	Root,
// 	RootElement,
// 	MinMax,
// 	StringIntegerCollection,
// 	RootType,
// 	RelativeOID,
// }
import * as Types from './types'
import * as Model from './model'

const Decoder = EmberLib.DecodeBuffer

// TODO
// function isValid(_el: EmberTreeNode<EmberElement>): boolean {
// 	return false
// }

// TODO
// function toJSON(_el: TreeElement<EmberElement>): Record<string, any> {
// 	return null
// }

// TODO
// function fromJSON(json: Record<string, any>): TreeElement<EmberElement> {
// 	return null
// }

export {
	EmberClient,
	EmberClientEvents,
	Decoder,
	EmberLib,
	EmberServer,
	EmberServerEvents,
	S101Codec,
	S101Client,
	berEncode,
	berDecode,
	// isValid,
	// toJSON,
	// fromJSON,
	Types,
	Model,
}

================
File: .editorconfig
================
root = true

[*]
indent_style = tab
indent_size = 2
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = false
end_of_line = lf

================
File: .eslintignore
================
node_modules
/dist
/scratch
/build
package-lock.json
/lib
/coverage

# old src folders/files
/Ber
/EmberClient
/EmberLib
/EmberServer
/EmberSocket
/Ember
/test
/Errors.js
/s101.js
/sample.js
/serve.js

================
File: .eslintrc.json
================
{
	"extends": "./node_modules/@sofie-automation/code-standard-preset/eslint/main",
	"overrides": [
		{
			"files": "*",
			"rules": {
				"@typescript-eslint/unbound-method": "off",
				"@typescript-eslint/no-for-in-array": "off"
			}
		}
	]
}

================
File: .gitattributes
================
* text=auto eol=lf

================
File: .gitignore
================
/.idea/*
.vscode
node_modules
.*.swp
/coverage
package-lock.json
yarn-error.log
/lib
/scratch

.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

================
File: .prettierignore
================
CHANGELOG.md
package.json

================
File: .repopackignore
================
node_modules/
.git/
build/
dist/
__mocks__/

================
File: .yarnrc.yml
================
nodeLinker: node-modules

plugins:
  - path: .yarn/plugins/@yarnpkg/plugin-version.cjs
    spec: "@yarnpkg/plugin-version"
  - path: .yarn/plugins/@yarnpkg/plugin-interactive-tools.cjs
    spec: "@yarnpkg/plugin-interactive-tools"

yarnPath: .yarn/releases/yarn-3.6.3.cjs

================
File: CHANGELOG.md
================
# Changelog

All notable changes to this project will be documented in this file. See [Convential Commits](https://www.conventionalcommits.org/en/v1.0.0/#specification) for commit guidelines.

## [0.2.2](https://github.com/nrkno/sofie-emberplus-connection/compare/v0.2.1...v0.2.2) (Fri Sep 20 2024)


### Fixes

* extra getDir for parameters to explicitly express interest in value changes [c6f684c](https://github.com/nrkno/sofie-emberplus-connection/commit/c6f684cc3d4870c971de3446360464fae055b284)
* **(Provider)** handle getDirectory on empty node correctly [8abda16](https://github.com/nrkno/sofie-emberplus-connection/commit/8abda1609cb19bf77d6d5548c34437d7ce7b9d62)
* handle getDirectory on root multiple times [cb375cc](https://github.com/nrkno/sofie-emberplus-connection/commit/cb375cc41ac2f3205b970fc6a13fa533ae0b362e)
* handle getDirectory on paramater [e8f131d](https://github.com/nrkno/sofie-emberplus-connection/commit/e8f131d096641bff1d36acef90a18b9d0a31353a)

## [0.2.1](https://github.com/nrkno/sofie-emberplus-connection/compare/v0.2.0...v0.2.1) (Mon Oct 16 2023)


## [0.2.0](https://github.com/nrkno/sofie-emberplus-connection/compare/v0.1.2...v0.2.0) (Mon Oct 16 2023)


### Fixes

* Setting 2 full path properties fails SOFIE-2628 (#34) [3d756ae](https://github.com/nrkno/sofie-emberplus-connection/commit/3d756aec59998015d4f0f331720dcb517d677b43)
* children should be stored in object [ee926d2](https://github.com/nrkno/sofie-emberplus-connection/commit/ee926d21cafc3368dac152daa122b35310aa2c6a)
* :bug: relative to issue #32 [70e8333](https://github.com/nrkno/sofie-emberplus-connection/commit/70e8333294a79db518729604fb0ac7e8e68cc9bb)
* implement timeout for keepalive requests [d59b7b2](https://github.com/nrkno/sofie-emberplus-connection/commit/d59b7b2a0418ce16fcf3f7ed384beb0346562f63)

### Features

* use typed eventemitter3 [ff3551e](https://github.com/nrkno/sofie-emberplus-connection/commit/ff3551e3667ffd39148745184058f8664adbde03)

### [0.1.2](https://github.com/nrkno/sofie-emberplus-connection/compare/v0.0.2...v0.1.2) (2022-01-17)


### ⚠ BREAKING CHANGES

* drop node 10 support

### Features

* emberplus provider ([babc51c](https://github.com/nrkno/sofie-emberplus-connection/commit/babc51c7b9f328d36fc0e327dfde2a60255d1ee6))
* optional path delimiter ([b7bf058](https://github.com/nrkno/sofie-emberplus-connection/commit/b7bf058ce192dfb863374eadbb783f706f01b777)), closes [#17](https://github.com/nrkno/sofie-emberplus-connection/issues/17)


### Bug Fixes

* **ber:** enum value is encoded as int ([4e2267a](https://github.com/nrkno/sofie-emberplus-connection/commit/4e2267a0e9a5b4be02e62d628361666b7cbf7e8b))
* client socket should send keepAlives ([88534e2](https://github.com/nrkno/sofie-emberplus-connection/commit/88534e2a77e5b39913f70136afa90863e67ae9da))
* codecov ([3db375b](https://github.com/nrkno/sofie-emberplus-connection/commit/3db375b03f72b25f41bc39a0dc2e6b817f8f779d))
* empty parameter type ([d69e0d7](https://github.com/nrkno/sofie-emberplus-connection/commit/d69e0d72b86d7230bbf52dc55609c0850ced87a4))
* increase robustness in connection / invocation decoder ([ef28575](https://github.com/nrkno/sofie-emberplus-connection/commit/ef28575e0835f8e3f3d682898d4d24647fb8b8c1))
* **provider:** build correct path from children in request [publish] ([7dcfda5](https://github.com/nrkno/sofie-emberplus-connection/commit/7dcfda5937f85cb2cf8066620d6a1beb22da0e69))
* **provider:** catch and emit errors from clients ([cdece29](https://github.com/nrkno/sofie-emberplus-connection/commit/cdece29a4210381704bface783d227f3b8af857a))
* **provider:** requests consisting of NumberedTreeNodes ([732e393](https://github.com/nrkno/sofie-emberplus-connection/commit/732e3935a252d668c7ca0eee569b34e20a4bd49a))
* Updated since the repo name has changed ([3917fc8](https://github.com/nrkno/sofie-emberplus-connection/commit/3917fc850dbc722655e17bcf11b002117ad0f758))


* drop node 10 support ([2753c36](https://github.com/nrkno/sofie-emberplus-connection/commit/2753c3665ba649926511e11a3df8f58683e127fe))

### [0.1.1](https://github.com/nrkno/sofie-emberplus-connection/compare/0.1.0...0.1.1) (2022-01-17)


### Bug Fixes

* codecov ([3db375b](https://github.com/nrkno/sofie-emberplus-connection/commit/3db375b03f72b25f41bc39a0dc2e6b817f8f779d))

## [0.1.0](https://github.com/nrkno/sofie-emberplus-connection/compare/0.0.4...0.1.0) (2022-01-17)

### ⚠ BREAKING CHANGES

- drop node 10 support

### Features

- optional path delimiter ([b7bf058](https://github.com/nrkno/sofie-emberplus-connection/commit/b7bf058ce192dfb863374eadbb783f706f01b777)), closes [#17](https://github.com/nrkno/sofie-emberplus-connection/issues/17)

### Bug Fixes

- empty parameter type ([d69e0d7](https://github.com/nrkno/sofie-emberplus-connection/commit/d69e0d72b86d7230bbf52dc55609c0850ced87a4))
- Updated since the repo name has changed ([3917fc8](https://github.com/nrkno/sofie-emberplus-connection/commit/3917fc850dbc722655e17bcf11b002117ad0f758))

- drop node 10 support ([2753c36](https://github.com/nrkno/sofie-emberplus-connection/commit/2753c3665ba649926511e11a3df8f58683e127fe))

### [0.0.4](https://github.com/nrkno/tv-automation-emberplus-connection/compare/0.0.3...0.0.4) (2020-12-01)

### Bug Fixes

- **provider:** build correct path from children in request [publish] ([7dcfda5](https://github.com/nrkno/tv-automation-emberplus-connection/commit/7dcfda5937f85cb2cf8066620d6a1beb22da0e69))
- **provider:** requests consisting of NumberedTreeNodes ([732e393](https://github.com/nrkno/tv-automation-emberplus-connection/commit/732e3935a252d668c7ca0eee569b34e20a4bd49a))

### [0.0.3](https://github.com/nrkno/tv-automation-emberplus-connection/compare/v0.0.2...v0.0.3) (2020-08-17)

### Features

- emberplus provider ([babc51c](https://github.com/nrkno/tv-automation-emberplus-connection/commit/babc51c7b9f328d36fc0e327dfde2a60255d1ee6))

### Bug Fixes

- **provider:** catch and emit errors from clients ([cdece29](https://github.com/nrkno/tv-automation-emberplus-connection/commit/cdece29a4210381704bface783d227f3b8af857a))
- client socket should send keepAlives ([88534e2](https://github.com/nrkno/tv-automation-emberplus-connection/commit/88534e2a77e5b39913f70136afa90863e67ae9da))
- increase robustness in connection / invocation decoder ([ef28575](https://github.com/nrkno/tv-automation-emberplus-connection/commit/ef28575e0835f8e3f3d682898d4d24647fb8b8c1))
- **ber:** enum value is encoded as int ([4e2267a](https://github.com/nrkno/tv-automation-emberplus-connection/commit/4e2267a0e9a5b4be02e62d628361666b7cbf7e8b))

### 0.0.2 (2020-06-08)

### Features

- basic type predicate for Parameter interface ([19570fe](https://github.com/nrkno/tv-automation-emberplus-connection/commit/19570fe3709aa5986863099d8ccd3e9d9e390659))
- Ber.Reader converted to TypeScript ([3858f61](https://github.com/nrkno/tv-automation-emberplus-connection/commit/3858f619fabe71cf1f7f48ff0a4295fe2de888e6))
- Ber.Writer converted to TypeScript ([bea3219](https://github.com/nrkno/tv-automation-emberplus-connection/commit/bea3219491cfb7b6a0c88ccb0a581955f406a916))
- convert error classes to typescript ([adb4cc4](https://github.com/nrkno/tv-automation-emberplus-connection/commit/adb4cc4bc94911c6c130b53cc52d87714385f3b8))
- create library index ([fc9d513](https://github.com/nrkno/tv-automation-emberplus-connection/commit/fc9d513c522c1dafe15da78365d34961a7c32caa))
- forgiving decoder ([03c72c5](https://github.com/nrkno/tv-automation-emberplus-connection/commit/03c72c5e2875d0e97df817ad3a088ae59adf8197))
- hack setValue to immediately resolve - added setValueWithHacksaw() function from NRKNO fork ([3b382b7](https://github.com/nrkno/tv-automation-emberplus-connection/commit/3b382b7352dfde79e295b94956f1f76a765dd5e8))
- library skeleton ([5d0c922](https://github.com/nrkno/tv-automation-emberplus-connection/commit/5d0c922012a6ae55b3bba843af4da6f763061666))
- reconnection logic (ported from nrkno/develop branch) ([232d508](https://github.com/nrkno/tv-automation-emberplus-connection/commit/232d5086cc3644297d961c1e0a2b5ad1446a45d4))
- remove creation of a new reader for each tag ([e64d11d](https://github.com/nrkno/tv-automation-emberplus-connection/commit/e64d11dfcae956e137f69e2a17d591da757fd19d))
- resends, timeouts, refactor for collections ([138241d](https://github.com/nrkno/tv-automation-emberplus-connection/commit/138241d1ac6af8ee4a1a10ab4b45ed85e9f808b9))
- separate method for ber encoding ember+ data structures ([4b9f947](https://github.com/nrkno/tv-automation-emberplus-connection/commit/4b9f9471024e7c915be71c371b3ed719c3be541f))
- setValueNoAck - rename of function and cleanup ([82618c3](https://github.com/nrkno/tv-automation-emberplus-connection/commit/82618c3ccc13b6355c893a47bafd1d226c7e86ae))
- type predicate function for EmberElement interface ([331f623](https://github.com/nrkno/tv-automation-emberplus-connection/commit/331f623eee4583c8b13f6b53f3dee1ade7c48638))
- **ber encoding:** Adds type to Ember.ParameterContents objects. Allows for explicitly setting Real ParameterContents types to enforce correct encoding. ([153eed8](https://github.com/nrkno/tv-automation-emberplus-connection/commit/153eed853b31eeaf5f79b76bf603ba01e2c4e177))
- **Functions:** Adds Invoke method for QualifiedFunctions with InvocationResult. ([9013dfe](https://github.com/nrkno/tv-automation-emberplus-connection/commit/9013dfea6b2392ca97f6e4423a3a98d5b6f087bb))

### Bug Fixes

- add missing code, pass tests ([dd3d884](https://github.com/nrkno/tv-automation-emberplus-connection/commit/dd3d88430f421b43f9f3b613cfccc2e0beb4ab2e))
- better error message for getEleByPath ([8c1c5be](https://github.com/nrkno/tv-automation-emberplus-connection/commit/8c1c5bee5f95e13298fe318af1be00349c34a92d))
- changes is an array [publish] ([f41e58d](https://github.com/nrkno/tv-automation-emberplus-connection/commit/f41e58d832ed6a19d5220eba04c4b54427d0a482))
- convert tree arrays into collections ([6974cc9](https://github.com/nrkno/tv-automation-emberplus-connection/commit/6974cc9085fee76e9cf30f980c32c6a374de8f41))
- do not expand functions and offline nodes ([fad784e](https://github.com/nrkno/tv-automation-emberplus-connection/commit/fad784e3cef4d635021fc8a2774a03ee30117a5c))
- fix Ber writeReal and writeValue ([d39e90a](https://github.com/nrkno/tv-automation-emberplus-connection/commit/d39e90a746f5c41ff45f8f08231c5885b22bbc2c))
- getDirectory on node should auto subscribe to child modification ([66578f0](https://github.com/nrkno/tv-automation-emberplus-connection/commit/66578f008ab3f7c127bdcfbb1dc2247deb675a77))
- handle indefinite lengths and empty contents ([34f7ff3](https://github.com/nrkno/tv-automation-emberplus-connection/commit/34f7ff3bd90345126ff92e1ffc6b9b617e5f6e55))
- make linting job actually work ([d7eef92](https://github.com/nrkno/tv-automation-emberplus-connection/commit/d7eef926fc864324b1dc9b10c63c6faf02d372a1))
- missing continue for error recovery ([9b3935f](https://github.com/nrkno/tv-automation-emberplus-connection/commit/9b3935f91e6a02173eefe48b796b5f118f1ee720))
- missing skipNext for error recovery ([53b7434](https://github.com/nrkno/tv-automation-emberplus-connection/commit/53b74344c5a644a95112bb049f30ab1881cf3216))
- promise didn´t resolve ([9110000](https://github.com/nrkno/tv-automation-emberplus-connection/commit/91100007882c08b814b84424726ea21543e4345d))
- reading and writing NULL values ([fcf979e](https://github.com/nrkno/tv-automation-emberplus-connection/commit/fcf979eb78a5c8acecbc83f3e6a2cc947fb4c3d0))
- write zero-length buffers and null parameters ([d910ef6](https://github.com/nrkno/tv-automation-emberplus-connection/commit/d910ef64a8426d6c90d24d54603642a74344c1e7))
- **ber encoding:** Fixed unecessary nesting of ParameterContents if using strong typed ParameterContents ([1661251](https://github.com/nrkno/tv-automation-emberplus-connection/commit/16612512a242232f9595c02265d16e7efbe77d61))
- **KeepAliveRequest:** Fixes broken KeepAlieveRequest. ([8a99bb6](https://github.com/nrkno/tv-automation-emberplus-connection/commit/8a99bb624c695f76bf9ae30b3a0d63e413bdcd52))

================
File: CONTRIBUTING.md
================
# How to Contribute to this Repository

Before contributing to this specific repository, please read the [Contribution Guidelines](https://nrkno.github.io/sofie-core/docs/for-developers/contribution-guidelines) for the Sofie project.


## Branches
This repository uses the **_master_** as the main branch, we require you to base your contributions on the master branch.

================
File: jest.config.js
================
module.exports = {
	moduleFileExtensions: ['ts', 'js'],
	transform: {
		'^.+\\.(ts|tsx)$': [
			'ts-jest',
			{
				tsconfig: 'tsconfig.json',
				diagnostics: { ignoreCodes: [6133] },
			},
		],
	},
	testMatch: ['**/__tests__/**/*.spec.(ts|js)'],
	testPathIgnorePatterns: ['integrationTests'],
	testEnvironment: 'node',
	collectCoverageFrom: [
		'**/src/**/*.{ts,js}',
		'!**/node_modules/**',
		'!**/__tests__/**',
		'!**/__mocks__/**',
		'!**/src/copy/**',
		'!**/dist/**',
		'!**/src/types/**',
	],
	coverageProvider: 'v8',
	coverageDirectory: './coverage/',
}

================
File: LICENSE
================
Copyright (c) 2017 MIT Media Lab

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
	"name": "emberplus-connection",
	"version": "0.2.2",
	"description": "Javascript implementation of the Ember+ automation protocol",
	"engines": {
		"node": ">=14.18"
	},
	"files": [
		"dist/**/*"
	],
	"main": "dist/index.js",
	"types": "dist/index.d.ts",
	"scripts": {
		"prepare": "run husky install",
		"build": "rimraf dist && run build:main",
		"build:main": "tsc -p tsconfig.build.json",
		"lint:raw": "run eslint --ext .ts --ext .js --ext .tsx --ext .jsx --ignore-pattern dist",
		"lint": "run lint:raw .",
		"lint-fix": "run lint --fix",
		"unit": "jest --coverage",
		"test": "run lint && jest test",
		"test:coverage": "run test -- --coverage",
		"cov": "jest --coverage; open-cli coverage/lcov-report/index.html",
		"cov-open": "open-cli coverage/lcov-report/index.html",
		"changelog": "sofie-version",
		"release": "run reset && run test && sofie-version",
		"reset": "git clean -dfx && git reset --hard && yarn",
		"validate:dependencies": "yarn npm audit --environment production && run license-validate",
		"validate:dev-dependencies": "yarn npm audit --environment development",
		"license-validate": "sofie-licensecheck --allowPackages caniuse-lite@1.0.30001541",
		"husky": "./node_modules/.bin/husky",
		"eslint": "./node_modules/.bin/eslint",
		"prettier": "./node_modules/.bin/prettier",
		"lint-staged": "./node_modules/.bin/lint-staged"
	},
	"contributors": [
		"Gilles Dufour <dufour.gilles@gmail.com> (www.gdnet.be)",
		"Brian Mayton <bmayton@bdm.cc> (http://bdm.cc)",
		"Ola Christian Gundelsby <ola.christian.gundelsby@nrk.no> (https://nrk.no)",
		"Balte de Wit <contact@balte.nl> (https://superfly.tv/)",
		"Richard Cartwright (https://superfly.tv/)"
	],
	"repository": {
		"type": "git",
		"url": "git+https://github.com/nrkno/sofie-emberplus-connection"
	},
	"license": "MIT",
	"dependencies": {
		"asn1": "evs-broadcast/node-asn1",
		"debug": "^4.3.4",
		"eventemitter3": "^4.0.7",
		"long": "^3.2.0",
		"smart-buffer": "^3.0.3",
		"tslib": "^2.6.2"
	},
	"devDependencies": {
		"@sofie-automation/code-standard-preset": "~2.5.2",
		"@types/debug": "^4.1.9",
		"@types/jest": "^29.5.5",
		"@types/long": "^4.0.1",
		"jest": "^29.7.0",
		"rimraf": "^5.0.5",
		"ts-jest": "^29.1.1",
		"typescript": "~4.9"
	},
	"bugs": {
		"url": "https://github.com/nrkno/sofie-emberplus-connection/issues"
	},
	"homepage": "https://github.com/nrkno/sofie-emberplus-connection#readme",
	"keywords": [
		"emberplus",
		"lawo"
	],
	"prettier": "@sofie-automation/code-standard-preset/.prettierrc.json",
	"lint-staged": {
		"*.{css,json,md,scss}": [
			"yarn prettier --write"
		],
		"*.{ts,tsx,js,jsx}": [
			"yarn lint:raw --fix"
		]
	},
	"packageManager": "yarn@3.6.3"
}

================
File: README.md
================
# Ember+ Connection (Sofie-specific Fork)

A TypeScript implementation of [Lawo's Ember+](https://github.com/Lawo/ember-plus) control protocol for _Node_, used by the [**Sofie** TV Automation System](https://github.com/nrkno/Sofie-TV-automation/).

It has been tested with _Lawo Ruby_, _Lawo R3lay_, and _Lawo MxGUI_.

The current version is very losely based on the original library and Mr Gilles Dufour's rewrites. It is however rewritten almost completely from scratch and bears little to no resemblance to earlier libraries.

### Repository-specific Info for Developers

- [Developer Info](DEVELOPER.md)
- [Contribution Guidelines](CONTRIBUTING.md)

### General Sofie System Info

- [Documentation](https://nrkno.github.io/sofie-core/)
- [Releases](https://nrkno.github.io/sofie-core/releases)

---

## Example Usage

### Client

Get Full tree:

```javascript
const { EmberClient, StreamManager } = require('emberplus-connection')
const client = new EmberClient('10.9.8.7', 9000)
client.on('error', (e) => {
	console.log(e)
})
await client.connect()

// If you want to listen to stream updates - you can do it like this:
client.on('streamUpdate', (path, value) => {
	console.log('Stream Update:', {
		path: path,
		value: value,
	})
})
// Get Root info
const req = await client.getDirectory(client.tree)
await req.response
// Get a Specific Node
const node = await client.getElementByPath('0.0.2')
console.log(node)
// Get a node by its path identifiers
const node2 = await client.getElementByPath('path.to.node')
console.log(node2)
// Get a node by its path descriptions
const node3 = await client.getElementByPath('descr1.descr2.descr3')
console.log(node3)
// Expand entire tree under node 0
await client.expand(client.tree)
console.log(client.tree)
```

Subsribe to changes

```javascript
const { EmberClient, EmberLib } = require('emberplus-connection')

const client = new EmberClient(HOST, PORT)
client
	.connect()
	.then(async () => (await client.getDirectory(client.tree)).response)
	.then(() => {
		console.log(client.tree, null, 4)
	})
	.then(() => client.getElementByPath('scoreMaster/router/labels/group 1'))
	.then((node) => {
		// For streams, use subscribe
		return client.subscribe(node, (update) => {
			console.log(udpate)
		})
	})
	.then(() => client.getElementByPath('0.2'))
	.then(async (node) => {
		// You can get the internal node path, the internal path can be different from the requested,
		// depending on wheter you request a numbered node or via the description
		console.log('This is the internal node path :', client.getInternalNodePath(node))

		// For non-streams a getDirectory will automatically subscribe for update
		return (
			await client.getDirectory(node, (update) => {
				console.log(udpate)
			})
		).response
	})
	// You can also provide a callback to the getElementByPath
	// Be carefull that subscription will be done for all elements in the path
	.then(() =>
		client.getElementByPath('0.3', (update) => {
			console.log(update)
		})
	)
```

### Setting New Value

```javascript
client = new EmberClient(LOCALHOST, PORT)
await client.connect()
await (
	await client.getDirectory()
).response
const req = await client.setValue(await client.getElementByPath('0.0.1'), 'gdnet')
await req.response
console.log('result', req.response)
return client.disconnect().then(() => {
	console.log('disconnected')
})
```

### Invoking Function

```javascript
const { EmberClient, EmberLib } = require('node-emberplus')

const client = new EmberClient(HOST, PORT)
await client.connect()
await (
	await client.getDirectory()
).response
const fn = await client.getElementByPath('path.to.function')
const req = await client.invoke(fn, 1, 2, 3)
console.log('result', await req.response)
```

### Basic Server

```javascript
const {
	EmberServer,
	NumberedTreeNodeImpl,
	EmberNodeImpl,
	ParameterImpl,
	ParameterType,
	EmberFunctionImpl,
	ParameterAccess,
	MatrixImpl,
	MatrixType,
	MatrixAddressingMode,
} = require('emberplus-connection')

const s = new EmberServer(9000) // start server on port 9000

s.onInvocation = (emberFunction, invocation) => {
	// handle function invocations
	return { id: invocation.contents.invocation.id, success: true }
}
s.onSetValue = async (node, value) => {
	// handle setting values
	s.update(node, { value })

	return true
}
s.onMatrixOperation = (matrix, connections) => {
	// handle matrix operations
	for (const connection of Object.values(connections)) {
		s.updateMatrixConnection(matrix, connection)
	}
}

const tree = {
	// create a tree for the provider
	1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Root', undefined, undefined, true), {
		1: new NumberedTreeNodeImpl(1, new EmberNodeImpl('Node', undefined, undefined, true), {
			1: new NumberedTreeNodeImpl(
				1,
				new ParameterImpl(
					ParameterType.Integer,
					'Value1',
					undefined,
					2,
					undefined,
					undefined,
					ParameterAccess.ReadWrite
				)
			),
			2: new NumberedTreeNodeImpl(
				2,
				new ParameterImpl(
					ParameterType.Integer,
					'Value2',
					undefined,
					2,
					undefined,
					undefined,
					ParameterAccess.ReadWrite
				)
			),
			3: new NumberedTreeNodeImpl(
				3,
				new ParameterImpl(
					ParameterType.Integer,
					'Value3',
					undefined,
					2,
					undefined,
					undefined,
					ParameterAccess.ReadWrite
				)
			),
		}),

		2: new NumberedTreeNodeImpl(2, new EmberNodeImpl('Functions', undefined, undefined, true), {
			1: new NumberedTreeNodeImpl(
				1,
				new EmberFunctionImpl(undefined, undefined) //, [{ type: ParameterType.Boolean, name: 'Test' }])
			),
		}),

		3: new NumberedTreeNodeImpl(3, new EmberNodeImpl('Matrices', undefined, undefined, true), {
			1: new NumberedTreeNodeImpl(
				1,
				new MatrixImpl(
					'Test Matrix',
					[1, 2, 3, 4, 5],
					[1, 2, 3, 4, 5],
					{},
					undefined,
					MatrixType.NToN,
					MatrixAddressingMode.NonLinear,
					5,
					5
				)
			),
		}),
	}),
}

s.init(tree) // initiate the provider with the tree
```

---

_The NRK logo is a registered trademark of Norsk rikskringkasting AS. The license does not grant any right to use, in any way, any trademarks, service marks or logos of Norsk rikskringkasting AS._

================
File: tsconfig.build.json
================
{
	"extends": "@sofie-automation/code-standard-preset/ts/tsconfig.lib",
	"include": ["src/**/*.ts"],
	"exclude": ["node_modules/**", "src/**/*spec.ts", "src/**/__tests__/*", "src/**/__mocks__/*"],
	"compilerOptions": {
		"outDir": "./dist",
		"baseUrl": "./",
		"paths": {
			"*": ["./node_modules/*"],
			"emberplus-connection": ["./src/index.ts"]
		},
		"types": ["node"],
		"esModuleInterop": true
	}
}

================
File: tsconfig.json
================
{
	"extends": "./tsconfig.build.json",
	"exclude": ["node_modules/**"],
	"compilerOptions": {
		"types": ["jest", "node"]
	}
}
